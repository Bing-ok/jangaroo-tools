package net.jangaroo.jooc.mvnplugin.sencha;

import net.jangaroo.jooc.mvnplugin.MavenSenchaConfiguration;
import net.jangaroo.jooc.mvnplugin.Type;
import net.jangaroo.jooc.mvnplugin.sencha.configurer.AppConfigurer;
import net.jangaroo.jooc.mvnplugin.sencha.configurer.Configurer;
import net.jangaroo.jooc.mvnplugin.sencha.configurer.DefaultSenchaWorkspaceConfigurer;
import net.jangaroo.jooc.mvnplugin.sencha.configurer.PackagesConfigurer;
import net.jangaroo.jooc.mvnplugin.sencha.executor.SenchaCmdExecutor;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.project.MavenProject;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;

public class SenchaWorkspaceHelper extends AbstractSenchaHelper<MavenSenchaConfiguration> {

  private final static String AUTO_CONTENT_COMMENT = "DO NOT CHANGE - This file was automatically generated by the " +
          "jangaroo-maven-plugin and it will be overwritten by the next call of the plugin's " +
          "goal \"generate-sencha-workspace\".";

  private final Configurer[] workspaceConfigurers;
  private final String senchaWorkspacePath;

  public SenchaWorkspaceHelper(MavenProject project, MavenSenchaConfiguration senchaConfiguration, Log log) {
    super(project, senchaConfiguration, log);

    this.senchaWorkspacePath = getProject().getBasedir().getAbsolutePath();

    PackagesConfigurer packagesConfigurer = new PackagesConfigurer(project, senchaConfiguration);
    AppConfigurer appConfigurer = new AppConfigurer(project);

    this.workspaceConfigurers = new Configurer[]{
            DefaultSenchaWorkspaceConfigurer.getInstance(),
            packagesConfigurer,
            appConfigurer
    };
  }

  @Override
  public void createModule() throws MojoExecutionException {
    File workingDirectory;
    try {
      workingDirectory = getProject().getBasedir().getCanonicalFile();
    } catch (IOException e) {
      throw new MojoExecutionException("Could not determine project base directory", e);
    }

    if (!workingDirectory.exists() && !workingDirectory.mkdirs()) {
      throw new MojoExecutionException("Could not create working directory");
    }

    if (null == SenchaUtils.findClosestSenchaWorkspaceDir(workingDirectory.getParentFile())) {

      Path senchaCfg = Paths.get(workingDirectory.getAbsolutePath(), SenchaUtils.SENCHA_WORKSPACE_CONFIG);
      try {
        // delete existing senchaCfg so that Sencha Cmd is forced to re-create it
        Files.deleteIfExists(senchaCfg);
      } catch (IOException ioe) {
        throw new MojoExecutionException("Could not delete existing sencha.cfg file in " + senchaCfg);
      }


      getLog().info("Generating Sencha workspace module");
      SenchaCmdExecutor senchaCmdExecutor = new SenchaCmdExecutor(workingDirectory, "generate workspace .", getLog());
      senchaCmdExecutor.execute();

      // sencha.cfg should be recreated
      if (Files.exists(senchaCfg)) {

        try {
          List<String> senchaCfgTmpContent = Files.readAllLines(senchaCfg, Charset.forName("UTF-8"));

          // prepend comment and delete first comment line with usually contains the date time
          if (senchaCfgTmpContent.get(0).startsWith("#")) { // if the first
            senchaCfgTmpContent.remove(0);
          }

          List<String> newSenchaCfg = new ArrayList<>(senchaCfgTmpContent.size());
          newSenchaCfg.add("#");
          newSenchaCfg.add("# " + AUTO_CONTENT_COMMENT);
          newSenchaCfg.add("#");
          newSenchaCfg.add("");
          newSenchaCfg.addAll(senchaCfgTmpContent);

          newSenchaCfg.add("ext.dir=" + SenchaUtils.generateAbsolutePathUsingPlaceholder(Type.WORKSPACE, getSenchaConfiguration().getExtFrameworkDir()));

          Files.write(senchaCfg, newSenchaCfg, Charset.forName("UTF-8"));
        } catch (IOException e) {
          throw new MojoExecutionException("Modifying sencha.cfg file failed", e);
        }

      } else {
        throw new MojoExecutionException("Could not find sencha.cfg file in " + senchaCfg);
      }

    } else {
      getLog().info("Skipping generate workspace because there already is a workspace in the directory hierarchy");
    }

  }


  @Override
  public void prepareModule() throws MojoExecutionException {
    File workingDirectory;
    workingDirectory = new File(senchaWorkspacePath);

    if (!workingDirectory.exists()) {
      getLog().info("Generating Sencha package into: " + workingDirectory.getPath());
      getLog().debug("Created " + workingDirectory.mkdirs());
    }

    if (null == SenchaUtils.findClosestSenchaWorkspaceDir(workingDirectory.getParentFile())) {
      writeWorkspaceJson(workingDirectory);
    } else {
      getLog().info("Skipping preparation of workspace because there already is a workspace in the directory hierarchy");
    }
  }

  @Override
  public File packageModule() throws MojoExecutionException {
    // nothing to do
    return null;
  }


  private void writeWorkspaceJson(File workingDirectory) throws MojoExecutionException {
    Map<String, Object> workspaceConfig = getWorkspaceConfig();

    File fWorkspaceJson = new File(workingDirectory.getAbsolutePath() + File.separator + SenchaUtils.SENCHA_WORKSPACE_FILENAME);
    try (PrintWriter pw = new PrintWriter(new FileWriter(fWorkspaceJson), false)) {
      pw.println("/**");
      pw.println(" * " + AUTO_CONTENT_COMMENT);
      pw.println(" */");
      SenchaUtils.getObjectMapper().writerWithDefaultPrettyPrinter().writeValue(pw, workspaceConfig);
    } catch (IOException e) {
      throw new MojoExecutionException("Could not write " + SenchaUtils.SENCHA_WORKSPACE_FILENAME, e);
    }
  }

  private Map<String, Object> getWorkspaceConfig() throws MojoExecutionException {
    return getConfig(workspaceConfigurers);
  }
}

package net.jangaroo.jooc.mvnplugin.sencha;

import net.jangaroo.jooc.mvnplugin.Type;
import net.jangaroo.jooc.mvnplugin.sencha.configbuilder.SenchaWorkspaceConfigBuilder;
import net.jangaroo.jooc.mvnplugin.sencha.executor.SenchaCmdExecutor;
import org.apache.commons.io.FilenameUtils;
import org.apache.maven.plugin.MojoExecutionException;
import org.apache.maven.plugin.logging.Log;
import org.apache.maven.project.MavenProject;

import java.io.File;
import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.nio.charset.Charset;
import java.nio.file.Files;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.ArrayList;
import java.util.Collections;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;

public class SenchaWorkspaceHelper extends AbstractSenchaHelper<SenchaConfiguration, SenchaWorkspaceConfigBuilder> {

  private final static String AUTO_CONTENT_COMMENT = "DO NOT CHANGE - This file was automatically generated by the " +
          "jangaroo-maven-plugin and it will be overwritten by the next call of the plugin's " +
          "goal \"generate-sencha-workspace\".";

  private final String senchaWorkspacePath;

  public SenchaWorkspaceHelper(MavenProject project, SenchaConfiguration senchaConfiguration, Log log) {
    super(project, senchaConfiguration, log);

    this.senchaWorkspacePath = getProject().getBasedir().getAbsolutePath();
  }

  public void createModule() throws MojoExecutionException {
    File workingDirectory;
    try {
      workingDirectory = getProject().getBasedir().getCanonicalFile();
    } catch (IOException e) {
      throw new MojoExecutionException("Could not determine project base directory", e);
    }

    if (!workingDirectory.exists() && !workingDirectory.mkdirs()) {
      throw new MojoExecutionException("Could not create working directory");
    }

    if (null == SenchaUtils.findClosestSenchaWorkspaceDir(workingDirectory.getParentFile())) {

      Path senchaCfg = Paths.get(workingDirectory.getAbsolutePath(), SenchaUtils.SENCHA_WORKSPACE_CONFIG);
      try {
        // delete existing senchaCfg so that Sencha Cmd is forced to re-create it
        Files.deleteIfExists(senchaCfg);
      } catch (IOException ioe) {
        throw new MojoExecutionException("Could not delete existing sencha.cfg file in " + senchaCfg);
      }


      getLog().info("Generating Sencha workspace module");
      SenchaCmdExecutor senchaCmdExecutor = new SenchaCmdExecutor(workingDirectory, "generate workspace .", getLog());
      senchaCmdExecutor.execute();

      // sencha.cfg should be recreated
      if (Files.exists(senchaCfg)) {

        try {
          List<String> senchaCfgTmpContent = Files.readAllLines(senchaCfg, Charset.forName("UTF-8"));

          // prepend comment and delete first comment line with usually contains the date time
          if (senchaCfgTmpContent.get(0).startsWith("#")) { // if the first
            senchaCfgTmpContent.remove(0);
          }

          List<String> newSenchaCfg = new ArrayList<>(senchaCfgTmpContent.size());
          newSenchaCfg.add("#");
          newSenchaCfg.add("# " + AUTO_CONTENT_COMMENT);
          newSenchaCfg.add("#");
          newSenchaCfg.add("");
          newSenchaCfg.addAll(senchaCfgTmpContent);

          newSenchaCfg.add("ext.dir=" + SenchaUtils.generateAbsolutePathUsingPlaceholder(Type.WORKSPACE, getSenchaConfiguration().getExtFrameworkDir()));

          Files.write(senchaCfg, newSenchaCfg, Charset.forName("UTF-8"));
        } catch (IOException e) {
          throw new MojoExecutionException("Modifying sencha.cfg file failed", e);
        }

      } else {
        throw new MojoExecutionException("Could not find sencha.cfg file in " + senchaCfg);
      }

    } else {
      getLog().info("Skipping generate workspace because there already is a workspace in the directory hierarchy");
    }

  }


  public void prepareModule() throws MojoExecutionException {
    File workingDirectory;
    workingDirectory = new File(senchaWorkspacePath);

    if (!workingDirectory.exists()) {
      getLog().info("Generating Sencha package into: " + workingDirectory.getPath());
      getLog().debug("Created " + workingDirectory.mkdirs());
    }

    if (null == SenchaUtils.findClosestSenchaWorkspaceDir(workingDirectory.getParentFile())) {
      writeWorkspaceJson(workingDirectory);
    } else {
      getLog().info("Skipping preparation of workspace because there already is a workspace in the directory hierarchy");
    }
  }


  private void writeWorkspaceJson(File workingDirectory) throws MojoExecutionException {
    Map<String, Object> workspaceConfig = getConfig();

    File fWorkspaceJson = new File(workingDirectory.getAbsolutePath() + File.separator + SenchaUtils.SENCHA_WORKSPACE_FILENAME);
    try (PrintWriter pw = new PrintWriter(new FileWriter(fWorkspaceJson), false)) {
      pw.println("/**");
      pw.println(" * " + AUTO_CONTENT_COMMENT);
      pw.println(" */");
      SenchaUtils.getObjectMapper().writerWithDefaultPrettyPrinter().writeValue(pw, workspaceConfig);
    } catch (IOException e) {
      throw new MojoExecutionException("Could not write " + SenchaUtils.SENCHA_WORKSPACE_FILENAME, e);
    }
  }

  @Override
  protected SenchaWorkspaceConfigBuilder createSenchaConfigBuilder() {
    return new SenchaWorkspaceConfigBuilder();
  }

  @Override
  protected void configure(SenchaWorkspaceConfigBuilder configBuilder) throws MojoExecutionException {
    configurePackages(configBuilder);
    configureApps(configBuilder);
  }

  public void configurePackages(SenchaWorkspaceConfigBuilder configBuilder) throws MojoExecutionException {
    List<String> localPathsToPackages = getLocalPathsToPackages();
    for (String packagesDir : localPathsToPackages) {
      configBuilder.packagesDir(packagesDir);
    }
    configBuilder.packagesExtract(getSenchaConfiguration().getPackagesDir());
  }

  private List<String> getLocalPathsToPackages() throws MojoExecutionException {
    List<String> result = new ArrayList<>();

    // first package path indicates the path other packages are generated from, this needs to be the workspace dir
    result.add(absolutePath(""));

    Set<MavenProject> senchaPackages = new HashSet<>();

    List<MavenProject> projectsInReactor = getProject().getCollectedProjects();

    if (null != projectsInReactor) {

      for (MavenProject project : projectsInReactor) {
        String packageType = project.getPackaging();
        if (Type.JANGAROO_PKG_PACKAGING.equals(packageType)) {
          senchaPackages.add(project);
        }
      }

    }

    Path rootPath = getProject().getBasedir().toPath().normalize();

    for (MavenProject senchaPackage : senchaPackages) {

      Path path = Paths.get(senchaPackage.getBuild().getDirectory() + SenchaUtils.LOCAL_PACKAGES_PATH);
      Path relativePath = rootPath.relativize(path);
      String relativePathString = FilenameUtils.separatorsToUnix(relativePath.toString());

      if (relativePathString.isEmpty()) {
        throw new MojoExecutionException("Cannot handle project because not relative path to root workspace could be build");
      }

      result.add(SenchaUtils.PLACEHOLDERS.get(Type.WORKSPACE) + SenchaUtils.SEPARATOR + relativePathString);

    }

    // sort resulting paths deterministically so that it remains the same no matter what OS you are using
    Collections.sort(result);

    return Collections.unmodifiableList(result);
  }

  private void configureApps(SenchaWorkspaceConfigBuilder configBuilder) throws MojoExecutionException {
    List<String> localPathsToApps = getLocalPathsToApps();
    for (String localPathsToApp : localPathsToApps) {
      configBuilder.app(localPathsToApp);
    }
  }

  private List<String> getLocalPathsToApps() throws MojoExecutionException {
    List<String> result = new ArrayList<>();

    Set<MavenProject> senchaApps = new HashSet<>();

    List<MavenProject> projectsInReactor = getProject().getCollectedProjects();

    if (null != projectsInReactor) {

      // filter apps from all projects
      for (MavenProject project : projectsInReactor) {
        String packaging = project.getPackaging();
        if (Type.JANGAROO_APP_PACKAGING.equals(packaging)) {
          senchaApps.add(project);
        }
      }

    }

    if (!senchaApps.isEmpty()) {
      Path rootPath = getProject().getBasedir().toPath().normalize();

      for (MavenProject senchaApp : senchaApps) {

        Path path = Paths.get(senchaApp.getBuild().getDirectory() + SenchaUtils.APP_TARGET_DIRECTORY);
        Path relativePath = rootPath.relativize(path);
        String relativePathString = FilenameUtils.separatorsToUnix(relativePath.toString());

        if (relativePathString.isEmpty()) {
          throw new MojoExecutionException("Cannot handle project because not relative path to root workspace could be build");
        }

        result.add(relativePathString);

      }

      // sort resulting paths deterministically so that it remains the same no matter what OS you are using
      Collections.sort(result);
    }

    return Collections.unmodifiableList(result);
  }

  private String absolutePath(String path) {
    return SenchaUtils.generateAbsolutePathUsingPlaceholder(Type.WORKSPACE, path);
  }

  @Override
  protected String getDefaultsJsonFileName() {
    return "default.workspace.json";
  }
}

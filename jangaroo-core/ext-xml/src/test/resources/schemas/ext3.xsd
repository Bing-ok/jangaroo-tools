<?xml version="1.0" encoding="UTF-8"?>
<xs:schema attributeFormDefault="unqualified" elementFormDefault="qualified" targetNamespace="http://extjs.com/ext3" xmlns:ext="http://extjs.com/ext3" xmlns:xs="http://www.w3.org/2001/XMLSchema">
  <xs:complexType name='ext.Component'>
        <xs:all>
            <xs:element name='plugins' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An object or array of objects that will provide custom functionality for this component. The only requirement for a valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is created, if any plugins are available, the component will call the init method on each plugin, passing a reference to itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='applyTo' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in the document that specifies some structural markup for this component.</p><div><ul><li><b>Description</b> : <div style="margin-left: 2em">When <tt>applyTo</tt> is used, constituent parts of the component can also be specified by id or CSS class name within the main element, and the component being created may attempt to create its subcomponents from that markup if applicable.</div></li><li><b>Notes</b> : <div style="margin-left: 2em"><div class="sub-desc">When using this config, a call to render() is not required.</div><div class="sub-desc">If applyTo is specified, any value passed for {@link #renderTo} will be ignored and the target element's parent node will automatically be used as the component's container.</div></div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='renderTo' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>Specify the id of the element, a DOM element or an existing Element that this component will be rendered into.</p><div><ul><li><b>Notes</b> : <div style="margin-left: 2em"><div class="sub-desc">Do <u>not</u> use this option if the Component is to be a child item of a {@link Ext.Container Container}. It is the responsibility of the {@link Ext.Container Container}'s {@link Ext.Container#layout layout manager} to render and manage its child items.</div><div class="sub-desc">When using this config, a call to render() is not required.</div></div></li></ul></div><p>See <tt>{@link #render}</tt> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='stateEvents' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>An array of events that, when fired, should trigger this component to save its state (defaults to none). <code>stateEvents</code> may be any type of event supported by this component, including browser or custom events (e.g., <tt>['click', 'customerchange']</tt>).</p><p>See <code>{@link #stateful}</code> for an explanation of saving and restoring Component state.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='autoEl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A tag name or {@link Ext.DomHelper DomHelper} spec used to create the {@link #getEl Element} which will encapsulate this Component.</p><p>You do not normally need to specify this. For the base classes {@link Ext.Component}, {@link Ext.BoxComponent}, and {@link Ext.Container}, this defaults to <b><tt>'div'</tt></b>. The more complex Ext classes use a more complex DOM structure created by their own onRender methods.</p><p>This is intended to allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example usage:</p><pre><code>{
xtype: 'box',
autoEl: {
tag: 'img',
src: 'http://www.example.com/example.jpg'
}
}, {
xtype: 'box',
autoEl: {
tag: 'blockquote',
html: 'autoEl is cool!'
}
}, {
xtype: 'container',
autoEl: 'ul',
cls: 'ux-unordered-list',
items: {
xtype: 'box',
autoEl: 'li',
html: 'First list item'
}
}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='fieldLabel'>
          <xs:annotation>
            <xs:documentation>
@event disable Fires after the component is disabled. @param {Ext.Component} this @event enable Fires after the component is enabled. @param {Ext.Component} this @event beforeshow Fires before the component is shown by calling the {@link #show} method. Return false from an event handler to stop the show. @param {Ext.Component} this @event show Fires after the component is shown when calling the {@link #show} method. @param {Ext.Component} this @event beforehide Fires before the component is hidden by calling the {@link #hide} method. Return false from an event handler to stop the hide. @param {Ext.Component} this @event hide Fires after the component is hidden. Fires after the component is hidden when calling the {@link #hide} method. @param {Ext.Component} this @event beforerender Fires before the component is {@link #rendered}. Return false from an event handler to stop the {@link #render}. @param {Ext.Component} this @event render Fires after the component markup is {@link #rendered}. @param {Ext.Component} this @event afterrender <p>Fires after the component rendering is finished.</p><p>The afterrender event is fired after this Component has been {@link #rendered}, been postprocesed by any afterRender method defined for the Component, and, if {@link #stateful}, after state has been restored.</p>@param {Ext.Component} this @event beforedestroy Fires before the component is {@link #destroy}ed. Return false from an event handler to stop the {@link #destroy}. @param {Ext.Component} this @event destroy Fires after the component is {@link #destroy}ed. @param {Ext.Component} this @event beforestaterestore Fires before the state of the component is restored. Return false from an event handler to stop the restore. @param {Ext.Component} this @param {Object} state The hash of state values returned from the StateProvider. If this event is not vetoed, then the state object is passed to <b><tt>applyState</tt></b>. By default, that simply copies property values into this Component. The method maybe overriden to provide custom state restoration. @event staterestore Fires after the state of the component is restored. @param {Ext.Component} this @param {Object} state The hash of state values returned from the StateProvider. This is passed to <b><tt>applyState</tt></b>. By default, that simply copies property values into this Component. The method maybe overriden to provide custom state restoration. @event beforestatesave Fires before the state of the component is saved to the configured state provider. Return false to stop the save. @param {Ext.Component} this @param {Object} state The hash of state values. This is determined by calling <b><tt>getState()</tt></b> on the Component. This method must be provided by the developer to return whetever representation of state is required, by default, Ext.Component has a null implementation. @event statesave Fires after the state of the component is saved to the configured state provider. @param {Ext.Component} this @param {Object} state The hash of state values. This is determined by calling <b><tt>getState()</tt></b> on the Component. This method must be provided by the developer to return whetever representation of state is required, by default, Ext.Component has a null implementation. <p>The label text to display next to this Component (defaults to '').</p><br/><p><b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use the <b>{@link Ext.layout.FormLayout FormLayout}</b> layout manager (e.g. {@link Ext.form.FormPanel} or specifying <tt>layout:'form'</tt>).</p><br/><p>Also see <tt>{@link #hideLabel}</tt> and {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}.</p>Example use:<pre><code>new Ext.FormPanel({
height: 100,
renderTo: Ext.getBody(),
items: [{
xtype: 'textfield',
fieldLabel: 'Name'
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='labelStyle'>
          <xs:annotation>
            <xs:documentation>
<p>A CSS style specification string to apply directly to this field's label. Defaults to the container's labelStyle value if set (e.g., <tt>{@link Ext.layout.FormLayout#labelStyle}</tt> , or '').</p><br/><p><b>Note</b>: see the note for <code>{@link #clearCls}</code>.</p><br/><p>Also see <code>{@link #hideLabel}</code> and <code>{@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}.</code></p>Example use:<pre><code>new Ext.FormPanel({
height: 100,
renderTo: Ext.getBody(),
items: [{
xtype: 'textfield',
fieldLabel: 'Name',
labelStyle: 'font-weight:bold;'
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='labelSeparator'>
          <xs:annotation>
            <xs:documentation>
<p>The separator to display after the text of each <tt>{@link #fieldLabel}</tt>. This property may be configured at various levels. The order of precedence is:</p><div class="mdetail-params"><ul><li>field / component level</li><li>container level</li><li>{@link Ext.layout.FormLayout#labelSeparator layout level} (defaults to colon <tt>':'</tt>)</li></ul></div>To display no separator for this field's label specify empty string ''.<br/><br/> <br/><p><b>Note</b>: see the note for <tt>{@link #clearCls}</tt>.</p><br/><p>Also see <tt>{@link #hideLabel}</tt> and {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}.</p>Example use:<pre><code>new Ext.FormPanel({
height: 100,
renderTo: Ext.getBody(),
layoutConfig: {
labelSeparator: '~'   // layout config has lowest priority (defaults to ':')
},
{@link Ext.layout.FormLayout#labelSeparator labelSeparator}: '&gt;&gt;',     // config at container level
items: [{
xtype: 'textfield',
fieldLabel: 'Field 1',
labelSeparator: '...' // field/component level config supersedes others
},{
xtype: 'textfield',
fieldLabel: 'Field 2' // labelSeparator will be '='
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideLabel'>
          <xs:annotation>
            <xs:documentation>
<p><tt>true</tt> to completely hide the label element ({@link #fieldLabel label} and {@link #labelSeparator separator}). Defaults to <tt>false</tt>. By default, even if you do not specify a <tt>{@link #fieldLabel}</tt> the space will still be reserved so that the field will line up with other fields that do have labels. Setting this to <tt>true</tt> will cause the field to not reserve that space.</p><br/><p><b>Note</b>: see the note for <tt>{@link #clearCls}</tt>.</p><br/>Example use:<pre><code>new Ext.FormPanel({
height: 100,
renderTo: Ext.getBody(),
items: [{
xtype: 'textfield'
hideLabel: true
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='clearCls'>
          <xs:annotation>
            <xs:documentation>
<p>The CSS class used to to apply to the special clearing div rendered directly after each form field wrapper to provide field clearing (defaults to <tt>'x-form-clear-left'</tt>).</p><br/><p><b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use the <b>{@link Ext.layout.FormLayout FormLayout}</b> layout manager (e.g. {@link Ext.form.FormPanel} or specifying <tt>layout:'form'</tt>) and either a <tt>{@link #fieldLabel}</tt> is specified or <tt>isFormField=true</tt> is specified.</p><br/><p>See {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl} also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemCls'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use the <b>{@link Ext.layout.FormLayout FormLayout}</b> layout manager (e.g. {@link Ext.form.FormPanel} or specifying <tt>layout:'form'</tt>).</p><br/><p>An additional CSS class to apply to the div wrapping the form item element of this field. If supplied, <tt>itemCls</tt> at the <b>field</b> level will override the default <tt>itemCls</tt> supplied at the <b>container</b> level. The value specified for <tt>itemCls</tt> will be added to the default class (<tt>'x-form-item'</tt>).</p><p>Since it is applied to the item wrapper (see {@link Ext.layout.FormLayout}.{@link Ext.layout.FormLayout#fieldTpl fieldTpl}), it allows you to write standard CSS rules that can apply to the field, the label (if specified), or any other element within the markup for the field.</p><br/><p><b>Note</b>: see the note for <tt>{@link #fieldLabel}</tt>.</p><br/>Example use:<pre><code>// Apply a style to the field's label:
&lt;style&gt;
.required .x-form-item-label {font-weight:bold;color:red;}
&lt;/style&gt;

new Ext.FormPanel({
height: 100,
renderTo: Ext.getBody(),
items: [{
xtype: 'textfield',
fieldLabel: 'Name',
itemCls: 'required' //this label will be styled
},{
xtype: 'textfield',
fieldLabel: 'Favorite Color'
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='anchor'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this Component is rendered by a Container which has been configured to use an <b>{@link Ext.layout.AnchorLayout AnchorLayout}</b> based layout manager, for example:</p><div class="mdetail-params"><ul><li>{@link Ext.form.FormPanel}</li><li>specifying <code>layout: 'anchor' // or 'form', or 'absolute'</code></li></ul></div><br/><br/> <p>See {@link Ext.layout.AnchorLayout}.{@link Ext.layout.AnchorLayout#anchor anchor} also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='id'>
          <xs:annotation>
            <xs:documentation>
<p>The <b>unique</b> id of this component (defaults to an {@link #getId auto-assigned id}). You should assign an id if you need to be able to access the component later and you do not have an object reference available (e.g., using {@link Ext}.{@link Ext#getCmp getCmp}).</p><p>Note that this id will also be used as the element id for the containing HTML element that is rendered to the page for this component. This allows you to write id-based CSS rules to style the specific instance of this component uniquely, and also to select sub-elements using this component's id as the parent.</p><p><b>Note</b>: to avoid complications imposed by a unique <tt>id</tt> also see <code>{@link #itemId}</code> and <code>{@link #ref}</code>.</p><p><b>Note</b>: to access the container of an item see <code>{@link #ownerCt}</code>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemId'>
          <xs:annotation>
            <xs:documentation>
<p>An <tt>itemId</tt> can be used as an alternative way to get a reference to a component when no object reference is available. Instead of using an <code>{@link #id}</code> with {@link Ext}.{@link Ext#getCmp getCmp}, use <code>itemId</code> with {@link Ext.Container}.{@link Ext.Container#getComponent getComponent} which will retrieve <code>itemId</code>'s or <tt>{@link #id}</tt>'s. Since <code>itemId</code>'s are an index to the container's internal MixedCollection, the <code>itemId</code> is scoped locally to the container -- avoiding potential conflicts with {@link Ext.ComponentMgr} which requires a <b>unique</b> <code>{@link #id}</code>.</p><pre><code>var c = new Ext.Panel({ //
{@link Ext.BoxComponent#height height}: 300,
{@link #renderTo}: document.body,
{@link Ext.Container#layout layout}: 'auto',
{@link Ext.Container#items items}: [
{
itemId: 'p1',
{@link Ext.Panel#title title}: 'Panel 1',
{@link Ext.BoxComponent#height height}: 150
},
{
itemId: 'p2',
{@link Ext.Panel#title title}: 'Panel 2',
{@link Ext.BoxComponent#height height}: 150
}
]
})
p1 = c.{@link Ext.Container#getComponent getComponent}('p1'); // not the same as {@link Ext#getCmp Ext.getCmp()}
p2 = p1.{@link #ownerCt}.{@link Ext.Container#getComponent getComponent}('p2'); // reference via a sibling
</code></pre><p>Also see <tt>{@link #id}</tt> and <code>{@link #ref}</code>.</p><p><b>Note</b>: to access the container of an item see <tt>{@link #ownerCt}</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='xtype'>
          <xs:annotation>
            <xs:documentation>
The registered <tt>xtype</tt> to create. This config option is not used when passing a config object into a constructor. This config option is used only when lazy instantiation is being used, and a child item of a Container is being specified not as a fully instantiated Component, but as a <i>Component config object</i>. The <tt>xtype</tt> will be looked up at render time up to determine what type of child Component to create.<br/><br/>The predefined xtypes are listed {@link Ext.Component here}. <br/><br/>If you subclass Components to create your own Components, you may register them using {@link Ext.ComponentMgr#registerType} in order to be able to take advantage of lazy instantiation and rendering.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ptype'>
          <xs:annotation>
            <xs:documentation>
The registered <tt>ptype</tt> to create. This config option is not used when passing a config object into a constructor. This config option is used only when lazy instantiation is being used, and a Plugin is being specified not as a fully instantiated Component, but as a <i>Component config object</i>. The <tt>ptype</tt> will be looked up at render time up to determine what type of Plugin to create.<br/><br/>If you create your own Plugins, you may register them using {@link Ext.ComponentMgr#registerPlugin} in order to be able to take advantage of lazy instantiation and rendering.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='cls'>
          <xs:annotation>
            <xs:documentation>
An optional extra CSS class that will be added to this component's Element (defaults to ''). This can be useful for adding customized styles to the component or any of its children using standard CSS rules.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='overCls'>
          <xs:annotation>
            <xs:documentation>
An optional extra CSS class that will be added to this component's Element when the mouse moves over the Element, and removed when the mouse moves out. (defaults to ''). This can be useful for adding customized 'active' or 'hover' styles to the component or any of its children using standard CSS rules.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='style'>
          <xs:annotation>
            <xs:documentation>
A custom style specification to be applied to this component's Element. Should be a valid argument to {@link Ext.Element#applyStyles}. <pre><code>new Ext.Panel({
title: 'Some Title',
renderTo: Ext.getBody(),
width: 400, height: 300,
layout: 'form',
items: [{
xtype: 'textarea',
style: {
width: '95%',
marginBottom: '10px'
}
},
new Ext.Button({
text: 'Send',
minWidth: '100',
style: {
marginBottom: '10px'
}
})
]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ctCls'>
          <xs:annotation>
            <xs:documentation>
<p>An optional extra CSS class that will be added to this component's container. This can be useful for adding customized styles to the container or any of its children using standard CSS rules. See {@link Ext.layout.ContainerLayout}.{@link Ext.layout.ContainerLayout#extraCls extraCls} also.</p><p><b>Note</b>: <tt>ctCls</tt> defaults to <tt>''</tt> except for the following class which assigns a value by default:</p><div class="mdetail-params"><ul><li>{@link Ext.layout.Box Box Layout} : <tt>'x-box-layout-ct'</tt></li></ul></div>To configure the above Class with an extra CSS class append to the default. For example, for BoxLayout (Hbox and Vbox):<pre><code>ctCls: 'x-box-layout-ct custom-class'
</code></pre><br/><br/>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disabled'>
          <xs:annotation>
            <xs:documentation>
Render this component disabled (default is false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hidden'>
          <xs:annotation>
            <xs:documentation>
Render this component hidden (default is false). If <tt>true</tt>, the {@link #hide} method will be called internally.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='plugins'>
          <xs:annotation>
            <xs:documentation>
An object or array of objects that will provide custom functionality for this component. The only requirement for a valid plugin is that it contain an init method that accepts a reference of type Ext.Component. When a component is created, if any plugins are available, the component will call the init method on each plugin, passing a reference to itself. Each plugin can then call methods or respond to events on the component as needed to provide its functionality.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='applyTo'>
          <xs:annotation>
            <xs:documentation>
<p>Specify the id of the element, a DOM element or an existing Element corresponding to a DIV that is already present in the document that specifies some structural markup for this component.</p><div><ul><li><b>Description</b> : <div style="margin-left: 2em">When <tt>applyTo</tt> is used, constituent parts of the component can also be specified by id or CSS class name within the main element, and the component being created may attempt to create its subcomponents from that markup if applicable.</div></li><li><b>Notes</b> : <div style="margin-left: 2em"><div class="sub-desc">When using this config, a call to render() is not required.</div><div class="sub-desc">If applyTo is specified, any value passed for {@link #renderTo} will be ignored and the target element's parent node will automatically be used as the component's container.</div></div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='renderTo'>
          <xs:annotation>
            <xs:documentation>
<p>Specify the id of the element, a DOM element or an existing Element that this component will be rendered into.</p><div><ul><li><b>Notes</b> : <div style="margin-left: 2em"><div class="sub-desc">Do <u>not</u> use this option if the Component is to be a child item of a {@link Ext.Container Container}. It is the responsibility of the {@link Ext.Container Container}'s {@link Ext.Container#layout layout manager} to render and manage its child items.</div><div class="sub-desc">When using this config, a call to render() is not required.</div></div></li></ul></div><p>See <tt>{@link #render}</tt> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='stateful'>
          <xs:annotation>
            <xs:documentation>
<p>A flag which causes the Component to attempt to restore the state of internal properties from a saved state on startup. The component must have either a <code>{@link #stateId}</code> or <code>{@link #id}</code> assigned for state to be managed. Auto-generated ids are not guaranteed to be stable across page loads and cannot be relied upon to save and restore the same state for a component.</p><p>For state saving to work, the state manager's provider must have been set to an implementation of {@link Ext.state.Provider} which overrides the {@link Ext.state.Provider#set set} and {@link Ext.state.Provider#get get} methods to save and recall name/value pairs. A built-in implementation, {@link Ext.state.CookieProvider} is available.</p><p>To set the state provider for the current page:</p><pre><code>Ext.state.Manager.setProvider(new Ext.state.CookieProvider({
expires: new Date(new Date().getTime()+(1000*60*60*24*7)), //7 days from now
}));
</code></pre><p>A stateful Component attempts to save state when one of the events listed in the <code>{@link #stateEvents}</code> configuration fires.</p><p>To save state, a stateful Component first serializes its state by calling <b><code>getState</code></b>. By default, this function does nothing. The developer must provide an implementation which returns an object hash which represents the Component's restorable state.</p><p>The value yielded by getState is passed to {@link Ext.state.Manager#set} which uses the configured {@link Ext.state.Provider} to save the object keyed by the Component's <code>{@link stateId}</code>, or, if that is not specified, its <code>{@link #id}</code>.</p><p>During construction, a stateful Component attempts to <i>restore</i> its state by calling {@link Ext.state.Manager#get} passing the <code>{@link #stateId}</code>, or, if that is not specified, the <code>{@link #id}</code>.</p><p>The resulting object is passed to <b><code>applyState</code></b>. The default implementation of <code>applyState</code> simply copies properties into the object, but a developer may override this to support more behaviour.</p><p>You can perform extra processing on state save and restore by attaching handlers to the {@link #beforestaterestore}, {@link #staterestore}, {@link #beforestatesave} and {@link #statesave} events.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='stateId'>
          <xs:annotation>
            <xs:documentation>
The unique id for this component to use for state management purposes (defaults to the component id if one was set, otherwise null if the component is using a generated id). <p>See <code>{@link #stateful}</code> for an explanation of saving and restoring Component state.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='stateEvents'>
          <xs:annotation>
            <xs:documentation>
<p>An array of events that, when fired, should trigger this component to save its state (defaults to none). <code>stateEvents</code> may be any type of event supported by this component, including browser or custom events (e.g., <tt>['click', 'customerchange']</tt>).</p><p>See <code>{@link #stateful}</code> for an explanation of saving and restoring Component state.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoEl'>
          <xs:annotation>
            <xs:documentation>
<p>A tag name or {@link Ext.DomHelper DomHelper} spec used to create the {@link #getEl Element} which will encapsulate this Component.</p><p>You do not normally need to specify this. For the base classes {@link Ext.Component}, {@link Ext.BoxComponent}, and {@link Ext.Container}, this defaults to <b><tt>'div'</tt></b>. The more complex Ext classes use a more complex DOM structure created by their own onRender methods.</p><p>This is intended to allow the developer to create application-specific utility Components encapsulated by different DOM elements. Example usage:</p><pre><code>{
xtype: 'box',
autoEl: {
tag: 'img',
src: 'http://www.example.com/example.jpg'
}
}, {
xtype: 'box',
autoEl: {
tag: 'blockquote',
html: 'autoEl is cool!'
}
}, {
xtype: 'container',
autoEl: 'ul',
cls: 'ux-unordered-list',
items: {
xtype: 'box',
autoEl: 'li',
html: 'First list item'
}
}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledClass'>
          <xs:annotation>
            <xs:documentation>
CSS class added to the component when it is disabled (defaults to 'x-item-disabled').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowDomMove'>
          <xs:annotation>
            <xs:documentation>
Whether the component can move the Dom node when rendering (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoShow'>
          <xs:annotation>
            <xs:documentation>
True if the component should check for hidden classes (e.g. 'x-hidden' or 'x-hide-display') and remove them on render (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hideMode'>
          <xs:annotation>
            <xs:documentation>
<p>How this component should be hidden. Supported values are <tt>'visibility'</tt> (css visibility), <tt>'offsets'</tt> (negative offset position) and <tt>'display'</tt> (css display).</p><br/><p><b>Note</b>: the default of <tt>'display'</tt> is generally preferred since items are automatically laid out when they are first shown (no sizing is done while hidden).</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideParent'>
          <xs:annotation>
            <xs:documentation>
True to hide and show the component's container when hide/show is called on the component, false to hide and show the component itself (defaults to false). For example, this can be used as a shortcut for a hide button on a window by setting hide:true on the button when adding it to its parent container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ref'>
          <xs:annotation>
            <xs:documentation>
<p>The {@link Ext.Element} which encapsulates this Component. Read-only.</p><p>This will <i>usually</i> be a &lt;DIV&gt; element created by the class's onRender method, but that may be overridden using the <code>{@link #autoEl}</code> config.</p><br/><p><b>Note</b>: this element will not be available until this Component has been rendered.</p><br/><p>To add listeners for <b>DOM events</b> to this Component (as opposed to listeners for this Component's own Observable events), see the {@link Ext.util.Observable#listeners listeners} config for a suggestion, or use a render listener directly:</p><pre><code>new Ext.Panel({
title: 'The Clickable Panel',
listeners: {
render: function(p) {
// Append the Panel to the click handler's argument list.
p.getEl().on('click', handlePanelClick.createDelegate(null, [p], true));
},
single: true  // Remove the listener after first invocation
}
});
</code></pre><p>See also <tt>{@link #getEl getEl}</tt></p><tt>@type Ext.Element @property el This Component's owner {@link Ext.Container Container} (defaults to undefined, and is set automatically when this Component is added to a Container). Read-only.</tt><p><tt><b>Note</b>: to access items within the Container see <tt>{@link #itemId}</tt>.</tt></p>@type Ext.Container @property ownerCt True if this component is hidden. Read-only. @type Boolean @property hidden True if this component is disabled. Read-only. @type Boolean @property disabled True if this component has been rendered. Read-only. @type Boolean @property rendered <p>Render this Component into the passed HTML element.</p><p style="font-weight: bold">If you are using a {@link Ext.Container Container} object to house this Component, then do not use the render method.</p><p>A Container's child Components are rendered by that Container's {@link Ext.Container#layout layout} manager when the Container is first rendered.</p><p>Certain layout managers allow dynamic addition of child components. Those that do include {@link Ext.layout.CardLayout}, {@link Ext.layout.AnchorLayout}, {@link Ext.layout.FormLayout}, {@link Ext.layout.TableLayout}.</p><p>If the Container is already rendered when a new child Component is added, you may need to call the Container's {@link Ext.Container#doLayout doLayout} to refresh the view which causes any unrendered child Components to be rendered. This is required so that you can add multiple child components if needed while only refreshing the layout once.</p><p>When creating complex UIs, it is important to remember that sizing and positioning of child items is the responsibility of the Container's {@link Ext.Container#layout layout} manager. If you expect child items to be sized in response to user interactions, you must configure the Container with a layout manager which creates and manages the type of layout you have in mind.</p><p style="font-weight: bold">Omitting the Container's {@link Ext.Container#layout layout} config means that a basic layout manager is used which does nothing but render child components sequentially into the Container. No sizing or positioning will be performed in this situation.</p>@param {Element/HTMLElement/String} container (optional) The element this Component should be rendered into. If it is being created from existing markup, this should be omitted. @param {String/Number} position (optional) The element ID or DOM node index within the container <b>before</b> which this component will be inserted (defaults to appending to the end of the container) <p>A path specification, relative to the Component's {@link #ownerCt} specifying into which ancestor Container to place a named reference to this Component.</p><p>The ancestor axis can be traversed by using '/' characters in the path. For example, to put a reference to a Toolbar Button into <i>the Panel which owns the Toolbar</i>:</p><pre><code>var myGrid = new Ext.grid.EditorGridPanel({
title: 'My EditorGridPanel',
store: myStore,
colModel: myColModel,
tbar: [{
text: 'Save',
handler: saveChanges,
disabled: true,
ref: '../saveButton'
}],
listeners: {
afteredit: function() {
//          The button reference is in the GridPanel
myGrid.saveButton.enable();
}
}
});
</code></pre><p>In the code above, if the ref had been <code>'saveButton'</code> the reference would have been placed into the Toolbar. Each '/' in the ref moves up one level from the Component's {@link #ownerCt}.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
  </xs:complexType>
  <xs:element name='component' type='ext:ext.Component'>
    <xs:annotation>
      <xs:documentation>
Registers a component. @param {Ext.Component} c The component Unregisters a component. @param {Ext.Component} c The component Returns a component by {@link Ext.Component#id id}. For additional details see {@link Ext.util.MixedCollection#get}. @param {String} id The component {@link Ext.Component#id id} @return Ext.Component The Component, <code>undefined</code> if not found, or <code>null</code> if a Class was found. Registers a function that will be called when a specified component is added to ComponentMgr @param {String} id The component {@link Ext.Component#id id} @param {Function} fn The callback function @param {Object} scope The scope of the callback The MixedCollection used internally for the component cache. An example usage may be subscribing to events on the MixedCollection to monitor addition or removal. Read-only. @type {MixedCollection} Checks if a Component type is registered. @param {Ext.Component} xtype The mnemonic string by which the Component class may be looked up @return {Boolean} Whether the type is registered. <p>Registers a new Component constructor, keyed by a new {@link Ext.Component#xtype}.</p><p>Use this method (or its alias {@link Ext#reg Ext.reg}) to register new subclasses of {@link Ext.Component} so that lazy instantiation may be used when specifying child Components. see {@link Ext.Container#items}</p>@param {String} xtype The mnemonic string by which the Component class may be looked up. @param {Constructor} cls The new Component class. Creates a new Component from the specified config object using the config object's {@link Ext.component#xtype xtype} to determine the class to instantiate. @param {Object} config A configuration object for the Component you wish to create. @param {Constructor} defaultType The constructor to provide the default Component type if the config object does not contain a <code>xtype</code>. (Optional if the config contains a <code>xtype</code>). @return {Ext.Component} The newly instantiated Component. <p>Registers a new Plugin constructor, keyed by a new {@link Ext.Component#ptype}.</p><p>Use this method (or its alias {@link Ext#preg Ext.preg}) to register new plugins for {@link Ext.Component}s so that lazy instantiation may be used when specifying Plugins.</p>@param {String} ptype The mnemonic string by which the Plugin class may be looked up. @param {Constructor} cls The new Plugin class. Creates a new Plugin from the specified config object using the config object's {@link Ext.component#ptype ptype} to determine the class to instantiate. @param {Object} config A configuration object for the Plugin you wish to create. @param {Constructor} defaultType The constructor to provide the default Plugin type if the config object does not contain a <code>ptype</code>. (Optional if the config contains a <code>ptype</code>). @return {Ext.Component} The newly instantiated Plugin. Shorthand for {@link Ext.ComponentMgr#registerType} @param {String} xtype The {@link Ext.component#xtype mnemonic string} by which the Component class may be looked up. @param {Constructor} cls The new Component class. @member Ext @method reg Shorthand for {@link Ext.ComponentMgr#registerPlugin} @param {String} ptype The {@link Ext.component#ptype mnemonic string} by which the Plugin class may be looked up. @param {Constructor} cls The new Plugin class. @member Ext @method preg Shorthand for {@link Ext.ComponentMgr#create} Creates a new Component from the specified config object using the config object's {@link Ext.component#xtype xtype} to determine the class to instantiate. @param {Object} config A configuration object for the Component you wish to create. @param {Constructor} defaultType The constructor to provide the default Component type if the config object does not contain a <code>xtype</code>. (Optional if the config contains a <code>xtype</code>). @return {Ext.Component} The newly instantiated Component. @member Ext @method create This Component's initial configuration specification. Read-only. @type Object @property initialConfig
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.BoxComponent'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:all>
            <xs:element name='margins' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p><b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the <b>{@link Ext.layout.BorderLayout BorderLayout}</b> or one of the two <b>{@link Ext.layout.BoxLayout BoxLayout} subclasses.</b></p><p>An object containing margins to apply to this BoxComponent in the format:</p><pre><code>{
top: (top margin),
right: (right margin),
bottom: (bottom margin),
left: (left margin)
}</code></pre><p>May also be a string containing space-separated, numeric margin values. The order of the sides associated with each value matches the way CSS processes margin values:</p><div class="mdetail-params"><ul><li>If there is only one value, it applies to all sides.</li><li>If there are two values, the top and bottom borders are set to the first value and the right and left are set to the second.</li><li>If there are three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the third.</li><li>If there are four values, they apply to the top, right, bottom, and left, respectively.</li></ul></div><br/><br/> <p>Defaults to:</p><pre><code>{top:0, right:0, bottom:0, left:0}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='tabTip'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this BoxComponent is a child item of a TabPanel.</p>A string to be used as innerHTML (html tags are accepted) to show in a tooltip when mousing over the associated tab selector element. {@link Ext.QuickTips}.init() must be called in order for the tips to render.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='region'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the <b>{@link Ext.layout.BorderLayout BorderLayout}</b> layout manager (e.g. specifying <tt>layout:'border'</tt>).</p><br/><p>See {@link Ext.layout.BorderLayout} also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='margins'>
          <xs:annotation>
            <xs:documentation>
<p><b>Note</b>: this config is only used when this BoxComponent is rendered by a Container which has been configured to use the <b>{@link Ext.layout.BorderLayout BorderLayout}</b> or one of the two <b>{@link Ext.layout.BoxLayout BoxLayout} subclasses.</b></p><p>An object containing margins to apply to this BoxComponent in the format:</p><pre><code>{
top: (top margin),
right: (right margin),
bottom: (bottom margin),
left: (left margin)
}</code></pre><p>May also be a string containing space-separated, numeric margin values. The order of the sides associated with each value matches the way CSS processes margin values:</p><div class="mdetail-params"><ul><li>If there is only one value, it applies to all sides.</li><li>If there are two values, the top and bottom borders are set to the first value and the right and left are set to the second.</li><li>If there are three values, the top is set to the first value, the left and right are set to the second, and the bottom is set to the third.</li><li>If there are four values, they apply to the top, right, bottom, and left, respectively.</li></ul></div><br/><br/> <p>Defaults to:</p><pre><code>{top:0, right:0, bottom:0, left:0}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='x'>
          <xs:annotation>
            <xs:documentation>
The local x (left) coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='y'>
          <xs:annotation>
            <xs:documentation>
The local y (top) coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageX'>
          <xs:annotation>
            <xs:documentation>
The page level x coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageY'>
          <xs:annotation>
            <xs:documentation>
The page level y coordinate for this component if contained within a positioning container.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='height'>
          <xs:annotation>
            <xs:documentation>
The height of this component in pixels (defaults to auto). <b>Note</b> to express this dimension as a percentage or offset see {@link Ext.Component#anchor}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='width'>
          <xs:annotation>
            <xs:documentation>
The width of this component in pixels (defaults to auto). <b>Note</b> to express this dimension as a percentage or offset see {@link Ext.Component#anchor}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoHeight'>
          <xs:annotation>
            <xs:documentation>
<p>True to use height:'auto', false to use fixed height (or allow it to be managed by its parent Container's {@link Ext.Container#layout layout manager}. Defaults to false.</p><p><b>Note</b>: Although many components inherit this config option, not all will function as expected with a height of 'auto'. Setting autoHeight:true means that the browser will manage height based on the element's contents, and that Ext will not manage it at all.</p><p>If the <i>browser</i> is managing the height, be aware that resizes performed by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the height might result in elements needing to be synchronized with the new height. Example:</p><pre><code>var w = new Ext.Window({
title: 'Window',
width: 600,
autoHeight: true,
items: {
title: 'Collapse Me',
height: 400,
collapsible: true,
border: false,
listeners: {
beforecollapse: function() {
w.el.shadow.hide();
},
beforeexpand: function() {
w.el.shadow.hide();
},
collapse: function() {
w.syncShadow();
},
expand: function() {
w.syncShadow();
}
}
}
}).show();
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoWidth'>
          <xs:annotation>
            <xs:documentation>
<p>True to use width:'auto', false to use fixed width (or allow it to be managed by its parent Container's {@link Ext.Container#layout layout manager}. Defaults to false.</p><p><b>Note</b>: Although many components inherit this config option, not all will function as expected with a width of 'auto'. Setting autoWidth:true means that the browser will manage width based on the element's contents, and that Ext will not manage it at all.</p><p>If the <i>browser</i> is managing the width, be aware that resizes performed by the browser in response to changes within the structure of the Component cannot be detected. Therefore changes to the width might result in elements needing to be synchronized with the new width. For example, where the target element is:</p><pre><code>&lt;div id='grid-container' style='margin-left:25%;width:50%'&gt;&lt;/div&gt;
</code></pre>A Panel rendered into that target element must listen for browser window resize in order to relay its child items when the browser changes its width:<pre><code>var myPanel = new Ext.Panel({
renderTo: 'grid-container',
monitorResize: true, // relay on browser resize
title: 'Panel',
height: 400,
autoWidth: true,
layout: 'hbox',
layoutConfig: {
align: 'stretch'
},
defaults: {
flex: 1
},
items: [{
title: 'Box 1',
}, {
title: 'Box 2'
}, {
title: 'Box 3'
}],
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='box' type='ext:ext.BoxComponent' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
Displays the shadow under the target element @param {Mixed} targetEl The id or element under which the shadow should display Returns true if the shadow is visible, else false Direct alignment when values are already available. Show must be called at least once before calling this method to ensure it is initialized. @param {Number} left The target element left position @param {Number} top The target element top position @param {Number} width The target element width @param {Number} height The target element height Hides this shadow Adjust the z-index of this shadow @param {Number} zindex The new z-index
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Spacer'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='spacer' type='ext:ext.Spacer' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
@event resize Fires after the component is resized. @param {Ext.Component} this @param {Number} adjWidth The box-adjusted width that was set @param {Number} adjHeight The box-adjusted height that was set @param {Number} rawWidth The width that was originally specified @param {Number} rawHeight The height that was originally specified @event move Fires after the component is moved. @param {Ext.Component} this @param {Number} x The new x position @param {Number} y The new y position Sets the width and height of this BoxComponent. This method fires the {@link #resize} event. This method can accept either width and height as separate arguments, or you can pass a size object like <code>{width:10, height:20}</code>. @param {Mixed} width The new width to set. This may be one of:<div class="mdetail-params"><ul><li>A Number specifying the new width in the {@link #getEl Element}'s {@link Ext.Element#defaultUnit}s (by default, pixels).</li><li>A String used to set the CSS width style.</li><li>A size object in the format <code>{width: widthValue, height: heightValue}</code>.</li><li><code>undefined</code> to leave the width unchanged.</li></ul></div>@param {Mixed} height The new height to set (not required if a size object is passed as the first arg). This may be one of:<div class="mdetail-params"><ul><li>A Number specifying the new height in the {@link #getEl Element}'s {@link Ext.Element#defaultUnit}s (by default, pixels).</li><li>A String used to set the CSS height style. Animation may <b>not</b> be used.</li><li><code>undefined</code> to leave the height unchanged.</li></ul></div>@return {Ext.BoxComponent} this Sets the width of the component. This method fires the {@link #resize} event. @param {Number} width The new width to setThis may be one of:<div class="mdetail-params"><ul><li>A Number specifying the new width in the {@link #getEl Element}'s {@link Ext.Element#defaultUnit}s (by default, pixels).</li><li>A String used to set the CSS width style.</li></ul></div>@return {Ext.BoxComponent} this Sets the height of the component. This method fires the {@link #resize} event. @param {Number} height The new height to set. This may be one of:<div class="mdetail-params"><ul><li>A Number specifying the new height in the {@link #getEl Element}'s {@link Ext.Element#defaultUnit}s (by default, pixels).</li><li>A String used to set the CSS height style.</li><li><i>undefined</i> to leave the height unchanged.</li></ul></div>@return {Ext.BoxComponent} this Gets the current size of the component's underlying element. @return {Object} An object containing the element's size {width: (element width), height: (element height)} Gets the current width of the component's underlying element. @return {Number} Gets the current height of the component's underlying element. @return {Number} Gets the current size of the component's underlying element, including space taken by its margins. @return {Object} An object containing the element's size {width: (element width + left/right margins), height: (element height + top/bottom margins)} Gets the current XY position of the component's underlying element. @param {Boolean} local (optional) If true the element's left and top are returned instead of page XY (defaults to false) @return {Array} The XY position of the element (e.g., [100, 200]) Gets the current box measurements of the component's underlying element. @param {Boolean} local (optional) If true the element's left and top are returned instead of page XY (defaults to false) @return {Object} box An object in the format {x, y, width, height} Sets the current box measurements of the component's underlying element. @param {Object} box An object in the format {x, y, width, height} @return {Ext.BoxComponent} this <p>Returns the outermost Element of this Component which defines the Components overall size.</p><p><i>Usually</i> this will return the same Element as <code>{@link #getEl}</code>, but in some cases, a Component may have some more wrapping Elements around its main active Element.</p><p>An example is a ComboBox. It is encased in a <i>wrapping</i> Element which contains both the <code>&lt;input&gt;</code> Element (which is what would be returned by its <code>{@link #getEl}</code> method, <i>and</i> the trigger button Element. This Element is returned as the <code>resizeEl</code>. Sets the left and top of the component. To set the page XY position instead, use {@link #setPagePosition}. This method fires the {@link #move} event. @param {Number} left The new left @param {Number} top The new top @return {Ext.BoxComponent} this Sets the page XY position of the component. To set the left and top instead, use {@link #setPosition}. This method fires the {@link #move} event. @param {Number} x The new x position @param {Number} y The new y position @return {Ext.BoxComponent} this Force the component's size to recalculate based on the underlying element's current height and width. @return {Ext.BoxComponent} this</p><p>Used to provide a sizable space in a layout.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Container'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:all>
            <xs:element name='layout' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p><b>*Important</b>: In order for child items to be correctly sized and positioned, typically a layout manager <b>must</b> be specified through the <code>layout</code> configuration option.</p><br/><p>The sizing and positioning of child {@link items} is the responsibility of the Container's layout manager which creates and manages the type of layout you have in mind. For example:</p><pre><code>new Ext.Window({
width:300, height: 300,
layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
items: [{
title: 'Panel inside a Window'
}]
}).show();
</code></pre><p>If the {@link #layout} configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the {@link Ext.layout.ContainerLayout default layout manager} will be used which does nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies <code>layout:'form'</code>). Other specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar, Menu, etc.).</p><br/><p><b><code>layout</code></b> may be specified as either as an Object or as a String:</p><div><ul class="mdetail-params"><li><u>Specify as an Object</u></li><li style="list-style: none"><div><ul class="mdetail-params"><li>Example usage:</li><li style="list-style: none"><pre><code>layout: {
type: 'vbox',
padding: '5',
align: 'left'
}
</code></pre></li><li><tt><b>type</b></tt></li><li style="list-style: none"><br/><p>The layout type to be used for this container. If not specified, a default {@link Ext.layout.ContainerLayout} will be created and used.</p><br/><p>Valid layout <tt>type</tt> values are:</p><div class="sub-desc"><ul class="mdetail-params"><li><tt><b>{@link Ext.layout.AbsoluteLayout absolute}</b></tt></li><li><tt><b>{@link Ext.layout.AccordionLayout accordion}</b></tt></li><li><tt><b>{@link Ext.layout.AnchorLayout anchor}</b></tt></li><li><tt><b>{@link Ext.layout.ContainerLayout auto}</b></tt>     <b>Default</b></li><li><tt><b>{@link Ext.layout.BorderLayout border}</b></tt></li><li><tt><b>{@link Ext.layout.CardLayout card}</b></tt></li><li><tt><b>{@link Ext.layout.ColumnLayout column}</b></tt></li><li><tt><b>{@link Ext.layout.FitLayout fit}</b></tt></li><li><tt><b>{@link Ext.layout.FormLayout form}</b></tt></li><li><tt><b>{@link Ext.layout.HBoxLayout hbox}</b></tt></li><li><tt><b>{@link Ext.layout.MenuLayout menu}</b></tt></li><li><tt><b>{@link Ext.layout.TableLayout table}</b></tt></li><li><tt><b>{@link Ext.layout.ToolbarLayout toolbar}</b></tt></li><li><tt><b>{@link Ext.layout.VBoxLayout vbox}</b></tt></li></ul></div></li><li>Layout specific configuration properties</li><li style="list-style: none"><br/><p>Additional layout specific configuration properties may also be specified. For complete details regarding the valid config options for each layout type, see the layout class corresponding to the <tt>type</tt> specified.</p></li></ul></div></li><li><u>Specify as a String</u></li><li style="list-style: none"><div><ul class="mdetail-params"><li>Example usage:</li><li style="list-style: none"><pre><code>layout: 'vbox',
layoutConfig: {
padding: '5',
align: 'left'
}
</code></pre></li><li><tt><b>layout</b></tt></li><li style="list-style: none"><br/><p>The layout <tt>type</tt> to be used for this container (see list of valid layout type values above).</p><br/></li><li><tt><b>{@link #layoutConfig}</b></tt></li><li style="list-style: none"><br/><p>Additional layout specific configuration properties. For complete details regarding the valid config options for each layout type, see the layout class corresponding to the <tt>layout</tt> specified.</p></li></ul></div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='layoutConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    This is a config object containing properties specific to the chosen <b><code>{@link #layout}</code></b> if <b><code>{@link #layout}</code></b> has been specified as a <i>string</i>.<br/><br/>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='items' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <pre><b>** IMPORTANT</b>: be sure to <b>{@link #layout specify a <code>layout</code>} if needed ! **</b></pre><p>A single item, or an array of child Components to be added to this container, for example:</p><pre><code>// specifying a single item
items: {...},
layout: 'fit',    // specify a layout!

// specifying multiple items
items: [{...}, {...}],
layout: 'anchor', // specify a layout!
</code></pre><p>Each item may be:</p><div><ul class="mdetail-params"><li>any type of object based on {@link Ext.Component}</li><li>a fully instanciated object or</li><li>an object literal that:</li><li style="list-style: none"><div><ul class="mdetail-params"><li>has a specified <code>{@link Ext.Component#xtype xtype}</code></li><li>the {@link Ext.Component#xtype} specified is associated with the Component desired and should be chosen from one of the available xtypes as listed in {@link Ext.Component}.</li><li>If an <code>{@link Ext.Component#xtype xtype}</code> is not explicitly specified, the {@link #defaultType} for that Container is used.</li><li>will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object</li></ul></div></li></ul></div><p><b>Notes</b>:</p><div><ul class="mdetail-params"><li>Ext uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out when they are first shown (no sizing is done while hidden), or in response to a {@link #doLayout} call.</li><li>Do not specify <code>{@link Ext.Panel#contentEl contentEl}</code>/ <code>{@link Ext.Panel#html html}</code> with <code>items</code>.</li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='defaults' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A config object that will be applied to all components added to this container either via the {@link #items} config or via the {@link #add} or {@link #insert} methods. The <tt>defaults</tt> config can contain any number of name/value property pairs to be added to each item, and should be valid for the types of items being added to the container. For example, to automatically apply padding to the body of each of a set of contained {@link Ext.Panel} items, you could pass: <tt>defaults: {bodyStyle:'padding:15px'}</tt>.</p><br/><p><b>Note</b>: <tt>defaults</tt> will not be applied to config objects if the option is already specified. For example:</p><pre><code>defaults: {               // defaults are applied to items, not the container
autoScroll:true
},
items: [
{
xtype: 'panel',   // defaults <b>do not</b> have precedence over
id: 'panel1',     // options in config objects, so the defaults
autoScroll: false // will not be applied here, panel1 will be autoScroll:false
},
new Ext.Panel({       // defaults <b>do</b> have precedence over options
id: 'panel2',     // options in components, so the defaults
autoScroll: false // will be applied here, panel2 will be autoScroll:true.
})
]
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='bubbleEvents' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>An array of events that, when fired, should be bubbled to any parent container. Defaults to <tt>['add', 'remove']</tt>.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:boolean' name='monitorResize'>
          <xs:annotation>
            <xs:documentation>
True to automatically monitor window resize events to handle anything that is sensitive to the current size of the viewport. This value is typically managed by the chosen <code>{@link #layout}</code> and should not need to be set manually.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='layout'>
          <xs:annotation>
            <xs:documentation>
<p><b>*Important</b>: In order for child items to be correctly sized and positioned, typically a layout manager <b>must</b> be specified through the <code>layout</code> configuration option.</p><br/><p>The sizing and positioning of child {@link items} is the responsibility of the Container's layout manager which creates and manages the type of layout you have in mind. For example:</p><pre><code>new Ext.Window({
width:300, height: 300,
layout: 'fit', // explicitly set layout manager: override the default (layout:'auto')
items: [{
title: 'Panel inside a Window'
}]
}).show();
</code></pre><p>If the {@link #layout} configuration is not explicitly specified for a general purpose container (e.g. Container or Panel) the {@link Ext.layout.ContainerLayout default layout manager} will be used which does nothing but render child components sequentially into the Container (no sizing or positioning will be performed in this situation). Some container classes implicitly specify a default layout (e.g. FormPanel specifies <code>layout:'form'</code>). Other specific purpose classes internally specify/manage their internal layout (e.g. GridPanel, TabPanel, TreePanel, Toolbar, Menu, etc.).</p><br/><p><b><code>layout</code></b> may be specified as either as an Object or as a String:</p><div><ul class="mdetail-params"><li><u>Specify as an Object</u></li><li style="list-style: none"><div><ul class="mdetail-params"><li>Example usage:</li><li style="list-style: none"><pre><code>layout: {
type: 'vbox',
padding: '5',
align: 'left'
}
</code></pre></li><li><tt><b>type</b></tt></li><li style="list-style: none"><br/><p>The layout type to be used for this container. If not specified, a default {@link Ext.layout.ContainerLayout} will be created and used.</p><br/><p>Valid layout <tt>type</tt> values are:</p><div class="sub-desc"><ul class="mdetail-params"><li><tt><b>{@link Ext.layout.AbsoluteLayout absolute}</b></tt></li><li><tt><b>{@link Ext.layout.AccordionLayout accordion}</b></tt></li><li><tt><b>{@link Ext.layout.AnchorLayout anchor}</b></tt></li><li><tt><b>{@link Ext.layout.ContainerLayout auto}</b></tt>     <b>Default</b></li><li><tt><b>{@link Ext.layout.BorderLayout border}</b></tt></li><li><tt><b>{@link Ext.layout.CardLayout card}</b></tt></li><li><tt><b>{@link Ext.layout.ColumnLayout column}</b></tt></li><li><tt><b>{@link Ext.layout.FitLayout fit}</b></tt></li><li><tt><b>{@link Ext.layout.FormLayout form}</b></tt></li><li><tt><b>{@link Ext.layout.HBoxLayout hbox}</b></tt></li><li><tt><b>{@link Ext.layout.MenuLayout menu}</b></tt></li><li><tt><b>{@link Ext.layout.TableLayout table}</b></tt></li><li><tt><b>{@link Ext.layout.ToolbarLayout toolbar}</b></tt></li><li><tt><b>{@link Ext.layout.VBoxLayout vbox}</b></tt></li></ul></div></li><li>Layout specific configuration properties</li><li style="list-style: none"><br/><p>Additional layout specific configuration properties may also be specified. For complete details regarding the valid config options for each layout type, see the layout class corresponding to the <tt>type</tt> specified.</p></li></ul></div></li><li><u>Specify as a String</u></li><li style="list-style: none"><div><ul class="mdetail-params"><li>Example usage:</li><li style="list-style: none"><pre><code>layout: 'vbox',
layoutConfig: {
padding: '5',
align: 'left'
}
</code></pre></li><li><tt><b>layout</b></tt></li><li style="list-style: none"><br/><p>The layout <tt>type</tt> to be used for this container (see list of valid layout type values above).</p><br/></li><li><tt><b>{@link #layoutConfig}</b></tt></li><li style="list-style: none"><br/><p>Additional layout specific configuration properties. For complete details regarding the valid config options for each layout type, see the layout class corresponding to the <tt>layout</tt> specified.</p></li></ul></div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='layoutConfig'>
          <xs:annotation>
            <xs:documentation>
This is a config object containing properties specific to the chosen <b><code>{@link #layout}</code></b> if <b><code>{@link #layout}</code></b> has been specified as a <i>string</i>.<br/><br/>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bufferResize'>
          <xs:annotation>
            <xs:documentation>
When set to true (50 milliseconds) or a number of milliseconds, the layout assigned for this container will buffer the frequency it calculates and does a re-layout of components. This is useful for heavy containers or containers with a large quantity of sub-components for which frequent layout calls would be expensive. Defaults to <tt>50</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='activeItem'>
          <xs:annotation>
            <xs:documentation>
A string component id or the numeric index of the component that should be initially activated within the container's layout on render. For example, activeItem: 'item-1' or activeItem: 0 (index 0 = the first item in the container's collection). activeItem only applies to layout styles that can display items one at a time (like {@link Ext.layout.AccordionLayout}, {@link Ext.layout.CardLayout} and {@link Ext.layout.FitLayout}). Related to {@link Ext.layout.ContainerLayout#activeItem}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='items'>
          <xs:annotation>
            <xs:documentation>
<pre><b>** IMPORTANT</b>: be sure to <b>{@link #layout specify a <code>layout</code>} if needed ! **</b></pre><p>A single item, or an array of child Components to be added to this container, for example:</p><pre><code>// specifying a single item
items: {...},
layout: 'fit',    // specify a layout!

// specifying multiple items
items: [{...}, {...}],
layout: 'anchor', // specify a layout!
</code></pre><p>Each item may be:</p><div><ul class="mdetail-params"><li>any type of object based on {@link Ext.Component}</li><li>a fully instanciated object or</li><li>an object literal that:</li><li style="list-style: none"><div><ul class="mdetail-params"><li>has a specified <code>{@link Ext.Component#xtype xtype}</code></li><li>the {@link Ext.Component#xtype} specified is associated with the Component desired and should be chosen from one of the available xtypes as listed in {@link Ext.Component}.</li><li>If an <code>{@link Ext.Component#xtype xtype}</code> is not explicitly specified, the {@link #defaultType} for that Container is used.</li><li>will be "lazily instanciated", avoiding the overhead of constructing a fully instanciated Component object</li></ul></div></li></ul></div><p><b>Notes</b>:</p><div><ul class="mdetail-params"><li>Ext uses lazy rendering. Child Components will only be rendered should it become necessary. Items are automatically laid out when they are first shown (no sizing is done while hidden), or in response to a {@link #doLayout} call.</li><li>Do not specify <code>{@link Ext.Panel#contentEl contentEl}</code>/ <code>{@link Ext.Panel#html html}</code> with <code>items</code>.</li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaults'>
          <xs:annotation>
            <xs:documentation>
<p>A config object that will be applied to all components added to this container either via the {@link #items} config or via the {@link #add} or {@link #insert} methods. The <tt>defaults</tt> config can contain any number of name/value property pairs to be added to each item, and should be valid for the types of items being added to the container. For example, to automatically apply padding to the body of each of a set of contained {@link Ext.Panel} items, you could pass: <tt>defaults: {bodyStyle:'padding:15px'}</tt>.</p><br/><p><b>Note</b>: <tt>defaults</tt> will not be applied to config objects if the option is already specified. For example:</p><pre><code>defaults: {               // defaults are applied to items, not the container
autoScroll:true
},
items: [
{
xtype: 'panel',   // defaults <b>do not</b> have precedence over
id: 'panel1',     // options in config objects, so the defaults
autoScroll: false // will not be applied here, panel1 will be autoScroll:false
},
new Ext.Panel({       // defaults <b>do</b> have precedence over options
id: 'panel2',     // options in components, so the defaults
autoScroll: false // will be applied here, panel2 will be autoScroll:true.
})
]
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoDestroy'>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='forceLayout'>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideBorders'>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultType'>
        </xs:attribute>
        <xs:attribute type='xs:string' name='resizeEvent'>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bubbleEvents'>
          <xs:annotation>
            <xs:documentation>
<p>An array of events that, when fired, should be bubbled to any parent container. Defaults to <tt>['add', 'remove']</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='container' type='ext:ext.Container' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Orientation constant - Create a vertical SplitBar @static @type Number Orientation constant - Create a horizontal SplitBar @static @type Number Placement constant - The resizing element is to the left of the splitter element @static @type Number Placement constant - The resizing element is to the right of the splitter element @static @type Number Placement constant - The resizing element is positioned above the splitter element @static @type Number Placement constant - The resizing element is positioned under splitter element @static @type Number <p>Base class for any {@link Ext.BoxComponent} that may contain other Components. Containers handle the basic behavior of containing items, namely adding, inserting and removing items.</p><p>The most commonly used Container classes are {@link Ext.Panel}, {@link Ext.Window} and {@link Ext.TabPanel}. If you do not need the capabilities offered by the aforementioned classes you can create a lightweight Container to be encapsulated by an HTML element to your specifications by using the <tt><b>{@link Ext.Component#autoEl autoEl}</b></tt> config option. This is a useful technique when creating embedded {@link Ext.layout.ColumnLayout column} layouts inside {@link Ext.form.FormPanel FormPanels} for example.</p><p>The code below illustrates both how to explicitly create a Container, and how to implicitly create one using the <b><tt>'container'</tt></b> xtype:</p><pre><code>// explicitly create a Container
var embeddedColumns = new Ext.Container({
autoEl: 'div',  // This is the default
layout: 'column',
defaults: {
// implicitly create Container by specifying xtype
xtype: 'container',
autoEl: 'div', // This is the default.
layout: 'form',
columnWidth: 0.5,
style: {
padding: '10px'
}
},
//  The two items below will be Ext.Containers, each encapsulated by a &lt;DIV&gt; element.
items: [{
items: {
xtype: 'datefield',
name: 'startDate',
fieldLabel: 'Start date'
}
}, {
items: {
xtype: 'datefield',
name: 'endDate',
fieldLabel: 'End date'
}
}]
});</code></pre><br/><br/> <p><u><b>Layout</b></u></p><p>Container classes delegate the rendering of child Components to a layout manager class which must be configured into the Container using the <code><b>{@link #layout}</b></code> configuration property.</p><p>When either specifying child <code>{@link #items}</code> of a Container, or dynamically {@link #add adding} Components to a Container, remember to consider how you wish the Container to arrange those child elements, and whether those child elements need to be sized using one of Ext's built-in <b><code>{@link #layout}</code></b> schemes. By default, Containers use the {@link Ext.layout.ContainerLayout ContainerLayout} scheme which only renders child components, appending them one after the other inside the Container, and <b>does not apply any sizing</b> at all.</p><p>A common mistake is when a developer neglects to specify a <b><code>{@link #layout}</code></b> (e.g. widgets like GridPanels or TreePanels are added to Containers for which no <tt><b>{@link #layout}</b></tt> has been specified). If a Container is left to use the default {@link Ext.layout.ContainerLayout ContainerLayout} scheme, none of its child components will be resized, or changed in any way when the Container is resized.</p><p>Certain layout managers allow dynamic addition of child components. Those that do include {@link Ext.layout.CardLayout}, {@link Ext.layout.AnchorLayout}, {@link Ext.layout.FormLayout}, and {@link Ext.layout.TableLayout}. For example:</p><pre><code>//  Create the GridPanel.
var myNewGrid = new Ext.grid.GridPanel({
store: myStore,
columns: myColumnModel,
title: 'Results', // the title becomes the title of the tab
});

myTabPanel.add(myNewGrid); // {@link Ext.TabPanel} implicitly uses {@link Ext.layout.CardLayout CardLayout}
myTabPanel.{@link Ext.TabPanel#setActiveTab setActiveTab}(myNewGrid);
</code></pre><br/><br/> <p>The example above adds a newly created GridPanel to a TabPanel. Note that a TabPanel uses {@link Ext.layout.CardLayout} as its layout manager which means all its child items are sized to {@link Ext.layout.FitLayout fit} exactly into its client area.</p><p><b><u>Overnesting is a common problem</u></b>. An example of overnesting occurs when a GridPanel is added to a TabPanel by wrapping the GridPanel <i>inside</i> a wrapping Panel (that has no <tt><b>{@link #layout}</b></tt> specified) and then add that wrapping Panel to the TabPanel. The point to realize is that a GridPanel <b>is</b> a Component which can be added directly to a Container. If the wrapping Panel has no <tt><b>{@link #layout}</b></tt> configuration, then the overnested GridPanel will not be sized as expected.</p><p/><p><u><b>Adding via remote configuration</b></u></p><p>A server side script can be used to add Components which are generated dynamically on the server. An example of adding a GridPanel to a TabPanel where the GridPanel is generated by the server based on certain parameters:</p><pre><code>// execute an Ajax request to invoke server side script:
Ext.Ajax.request({
url: 'gen-invoice-grid.php',
// send additional parameters to instruct server script
params: {
startDate: Ext.getCmp('start-date').getValue(),
endDate: Ext.getCmp('end-date').getValue()
},
// process the response object to add it to the TabPanel:
success: function(xhr) {
var newComponent = eval(xhr.responseText); // see discussion below
myTabPanel.add(newComponent); // add the component to the TabPanel
myTabPanel.setActiveTab(newComponent);
},
failure: function() {
Ext.Msg.alert("Grid create failed", "Server communication failure");
}
});
</code></pre><p>The server script needs to return an executable Javascript statement which, when processed using <tt>eval()</tt>, will return either a config object with an {@link Ext.Component#xtype xtype}, or an instantiated Component. The server might return this for example:</p><pre><code>(function() {
function formatDate(value){
return value ? value.dateFormat('M d, Y') : '';
};

var store = new Ext.data.Store({
url: 'get-invoice-data.php',
baseParams: {
startDate: '01/01/2008',
endDate: '01/31/2008'
},
reader: new Ext.data.JsonReader({
record: 'transaction',
idProperty: 'id',
totalRecords: 'total'
}, [
'customer',
'invNo',
{name: 'date', type: 'date', dateFormat: 'm/d/Y'},
{name: 'value', type: 'float'}
])
});

var grid = new Ext.grid.GridPanel({
title: 'Invoice Report',
bbar: new Ext.PagingToolbar(store),
store: store,
columns: [
{header: "Customer", width: 250, dataIndex: 'customer', sortable: true},
{header: "Invoice Number", width: 120, dataIndex: 'invNo', sortable: true},
{header: "Invoice Date", width: 100, dataIndex: 'date', renderer: formatDate, sortable: true},
{header: "Value", width: 120, dataIndex: 'value', renderer: 'usMoney', sortable: true}
],
});
store.load();
return grid;  // return instantiated component
})();
</code></pre><p>When the above code fragment is passed through the <tt>eval</tt> function in the success handler of the Ajax request, the code is executed by the Javascript processor, and the anonymous function runs, and returns the instantiated grid component.</p><p>Note: since the code above is <i>generated</i> by a server script, the <tt>baseParams</tt> for the Store, the metadata to allow generation of the Record layout, and the ColumnModel can all be generated into the code since these are all known on the server.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Viewport'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:boolean' name='deferHeight'>
          <xs:annotation>
            <xs:documentation>
@hide
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='viewport' type='ext:ext.Viewport' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>
@property activeItem @hide <p>A specialized container representing the viewable application area (the browser viewport).</p><p>The Viewport renders itself to the document body, and automatically sizes itself to the size of the browser viewport and manages window resizing. There may only be one Viewport created in a page. Inner layouts are available by virtue of the fact that all {@link Ext.Panel Panel}s added to the Viewport, either through its {@link #items}, or through the items, or the {@link #add} method of any of its child Panels may themselves have a layout.</p><p>The Viewport does not provide scrolling, so child Panels within the Viewport should provide for scrolling if needed using the {@link #autoScroll} config.</p><p>An example showing a classic application border layout:</p><pre><code>new Ext.Viewport({
layout: 'border',
items: [{
region: 'north',
html: '&lt;h1 class="x-panel-header"&gt;Page Title&lt;/h1&gt;',
autoHeight: true,
border: false,
margins: '0 0 5 0'
}, {
region: 'west',
collapsible: true,
title: 'Navigation',
width: 200
// the west region might typically utilize a {@link Ext.tree.TreePanel TreePanel} or a Panel with {@link Ext.layout.AccordionLayout Accordion layout} 
}, {
region: 'south',
title: 'Title for Panel',
collapsible: true,
html: 'Information goes here',
split: true,
height: 100,
minHeight: 100
}, {
region: 'east',
title: 'Title for the Grid Panel',
collapsible: true,
split: true,
width: 200,
xtype: 'grid',
// remaining grid configuration not shown ...
// notice that the GridPanel is added directly as the region
// it is not "overnested" inside another Panel
}, {
region: 'center',
xtype: 'tabpanel', // TabPanel itself has no title
items: {
title: 'Default Tab',
html: 'The first tab\'s content. Others may be added dynamically'
}
}]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Panel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:all>
            <xs:element name='bodyCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The Panel's body {@link Ext.Element Element} which may be used to contain HTML content. The content may be specified in the {@link #html} config, or it may be loaded using the {@link autoLoad} config, or through the Panel's {@link #getUpdater Updater}. Read-only. <p>If this is used to load visible HTML elements in either way, then the Panel may not be used as a Layout for hosting nested Panels.</p><p>If this Panel is intended to be used as the host of a Layout (See {@link #layout} then the body Element must not be loaded or changed - it is under the control of the Panel's Layout.<br/></p><p><b>Note</b>: see the Note for <code>{@link Ext.Component#el el}</code> also.</p>@type Ext.Element @property body The Panel's bwrap {@link Ext.Element Element} used to contain other Panel elements (tbar, body, bbar, footer). See {@link #bodyCfg}. Read-only. @type Ext.Element @property bwrap True if this panel is collapsed. Read-only. @type Boolean @property collapsed <p>A {@link Ext.DomHelper DomHelper} element specification object may be specified for any Panel Element.</p><p>By default, the Default element in the table below will be used for the html markup to create a child element with the commensurate Default class name (<code>baseCls</code> will be replaced by <code>{@link #baseCls}</code>):</p><pre>Panel      Default  Default             Custom      Additional       Additional
Element    element  class               element     class            style
========   ==========================   =========   ==============   ===========
{@link #header}     div      {@link #baseCls}+'-header'   {@link #headerCfg}   headerCssClass   headerStyle
{@link #bwrap}      div      {@link #baseCls}+'-bwrap'     {@link #bwrapCfg}    bwrapCssClass    bwrapStyle
+ tbar     div      {@link #baseCls}+'-tbar'       {@link #tbarCfg}     tbarCssClass     tbarStyle
+ {@link #body}     div      {@link #baseCls}+'-body'       {@link #bodyCfg}     {@link #bodyCssClass}     {@link #bodyStyle}
+ bbar     div      {@link #baseCls}+'-bbar'       {@link #bbarCfg}     bbarCssClass     bbarStyle
+ {@link #footer}   div      {@link #baseCls}+'-footer'   {@link #footerCfg}   footerCssClass   footerStyle
</pre><p>Configuring a Custom element may be used, for example, to force the {@link #body} Element to use a different form of markup than is created by default. An example of this might be to {@link Ext.Element#createChild create a child} Panel containing a custom content, such as a header, or forcing centering of all Panel content by having the body be a &lt;center&gt; element:</p><pre><code>new Ext.Panel({
title: 'Message Title',
renderTo: Ext.getBody(),
width: 200, height: 130,
<b>bodyCfg</b>: {
tag: 'center',
cls: 'x-panel-body',  // Default class not applied if Custom element specified
html: 'Message'
},
footerCfg: {
tag: 'h2',
cls: 'x-panel-footer'        // same as the Default class
html: 'footer html'
},
footerCssClass: 'custom-footer', // additional css class, see {@link Ext.element#addClass addClass}
footerStyle:    'background-color:red' // see {@link #bodyStyle}
});
</code></pre><p>The example above also explicitly creates a <code>{@link #footer}</code> with custom markup and styling applied.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='headerCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #header} Element. See <code>{@link #bodyCfg}</code> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='bwrapCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bwrap} Element. See <code>{@link #bodyCfg}</code> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='tbarCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #tbar} Element. See <code>{@link #bodyCfg}</code> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='bbarCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bbar} Element. See <code>{@link #bodyCfg}</code> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='footerCfg' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #footer} Element. See <code>{@link #bodyCfg}</code> also.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='tbar' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>The top toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button configs to be added to the toolbar. Note that this is not available as a property after render. To access the top toolbar after render, use {@link #getTopToolbar}.</p><p><b>Note:</b> Although a Toolbar may contain Field components, these will <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy, and so are not scanned to collect form items. However, the values <b>will</b> be submitted because form submission parameters are collected from the DOM tree.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='bbar' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>The bottom toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button configs to be added to the toolbar. Note that this is not available as a property after render. To access the bottom toolbar after render, use {@link #getBottomToolbar}.</p><p><b>Note:</b> Although a Toolbar may contain Field components, these will <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy, and so are not scanned to collect form items. However, the values <b>will</b> be submitted because form submission parameters are collected from the DOM tree.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='fbar' minOccurs="0" maxOccurs="1">
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='buttons' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <code>buttons</code> will be used as <code>{@link Ext.Container#items items}</code> for the toolbar in the footer (<code>{@link #fbar}</code>). Typically the value of this configuration property will be an array of {@link Ext.Button}s or {@link Ext.Button} configuration objects. If an item is configured with <code>minWidth</code> or the Panel is configured with <code>minButtonWidth</code>, that width will be applied to the item.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='autoLoad' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A valid url spec according to the Updater {@link Ext.Updater#update} method. If autoLoad is not null, the panel will attempt to load its contents immediately upon render.<p>The URL will become the default URL for this panel's {@link #body} element, so it may be {@link Ext.Element#refresh refresh}ed at any time.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='bodyCssClass' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Additional css class selector to be applied to the {@link #body} element in the format expected by {@link Ext.Element#addClass} (defaults to null). See {@link #bodyCfg}.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='bodyStyle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Custom CSS styles to be applied to the {@link #body} element in the format expected by {@link Ext.Element#applyStyles} (defaults to null). See {@link #bodyCfg}.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='tools' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an {@link Ext.Element Element} referenced by a public property called <code>tools.<i>&lt;tool-type&gt;</i></code> <p>Each tool config may contain the following properties:</p><div class="mdetail-params"><ul><li><b>id</b> : String<div class="sub-desc"><b>Required.</b> The type of tool to create. By default, this assigns a CSS class of the form <code>x-tool-<i>&lt;tool-type&gt;</i></code> to the resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below. The developer may implement custom tools by supplying alternate CSS rules and background images: <div style="margin-left: 2em"><div><code>toggle</code> (Created by default when {@link #collapsible} is <code>true</code>)</div><div><code>close</code></div><div><code>minimize</code></div><div><code>maximize</code></div><div><code>restore</code></div><div><code>gear</code></div><div><code>pin</code></div><div><code>unpin</code></div><div><code>right</code></div><div><code>left</code></div><div><code>up</code></div><div><code>down</code></div><div><code>refresh</code></div><div><code>minus</code></div><div><code>plus</code></div><div><code>help</code></div><div><code>search</code></div><div><code>save</code></div><div><code>print</code></div></div></div></li><li><b>handler</b> : Function<div class="sub-desc"><b>Required.</b> The function to call when clicked. Arguments passed are:<ul><li><b>event</b> : Ext.EventObject<div class="sub-desc">The click event.</div></li><li><b>toolEl</b> : Ext.Element<div class="sub-desc">The tool Element.</div></li><li><b>panel</b> : Ext.Panel<div class="sub-desc">The host Panel</div></li><li><b>tc</b> : Ext.Panel<div class="sub-desc">The tool configuration object</div></li></ul></div></li><li><b>stopEvent</b> : Boolean<div class="sub-desc">Defaults to true. Specify as false to allow click event to propagate.</div></li><li><b>scope</b> : Object<div class="sub-desc">The scope in which to call the handler.</div></li><li><b>qtip</b> : String/Object<div class="sub-desc">A tip string, or a config argument to {@link Ext.QuickTip#register}</div></li><li><b>hidden</b> : Boolean<div class="sub-desc">True to initially render hidden.</div></li><li><b>on</b> : Object<div class="sub-desc">A listener config object specifiying event listeners in the format of an argument to {@link #addListener}</div></li></ul></div><p>Note that, apart from the toggle tool which is provided when a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by adding handlers that implement the necessary behavior.</p><p>Example usage:</p><pre><code>tools:[{
id:'refresh',
qtip: 'Refresh form Data',
// hidden:true,
handler: function(event, toolEl, panel){
// refresh logic
}
},
{
id:'help',
qtip: 'Get Help',
handler: function(event, toolEl, panel){
// whatever
}
}]
</code></pre><p>For the custom id of <code>'help'</code> define two relevant css classes with a link to a 15x15 image:</p><pre><code>.x-tool-help {background-image: url(images/help.png);}
.x-tool-help-over {background-image: url(images/help_over.png);}
// if using an image sprite:
.x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
.x-tool-help-over {background-position:-15px 0;}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='toolTemplate' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A Template used to create {@link #tools} in the {@link #header} Element. Defaults to:</p><pre><code>new Ext.Template('&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;')</code></pre><p>This may may be overridden to provide a custom DOM structure for tools based upon a more complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in {@link #tools}. In the following example an &lt;a&gt; tag is used to provide a visual indication when hovering over the tool:</p><pre><code>var win = new Ext.Window({
tools: [{
id: 'download',
href: '/MyPdfDoc.pdf'
}],
toolTemplate: new Ext.XTemplate(
'&lt;tpl if="id==\'download\'"&gt;',
'&lt;a class="x-tool x-tool-pdf" href="{href}"&gt;&lt;/a&gt;',
'&lt;/tpl&gt;',
'&lt;tpl if="id!=\'download\'"&gt;',
'&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;',
'&lt;/tpl&gt;'
),
width:500,
height:300,
closeAction:'hide'
});</code></pre><p>Note that the CSS class 'x-tool-pdf' should have an associated style rule which provides an appropriate background image, something like:</p><pre><code>a.x-tool-pdf {background-image: url(../shared/extjs/images/pdf.gif)!important;}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='floating' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>This property is used to configure the underlying {@link Ext.Layer}. Acceptable values for this configuration property are:</p><div class="mdetail-params"><ul><li><b><code>false</code></b> : <b>Default.</b><div class="sub-desc">Display the panel inline where it is rendered.</div></li><li><b><code>true</code></b> : <div class="sub-desc">Float the panel (absolute position it with automatic shimming and shadow).<div style="margin-left: 2em"><div class="sub-desc">Setting floating to true will create an Ext.Layer for this panel and display the panel at negative offsets so that it is hidden.</div><div class="sub-desc">Since the panel will be absolute positioned, the position must be set explicitly <i>after</i> render (e.g., <code>myPanel.setPosition(100,100);</code>).</div><div class="sub-desc"><b>Note</b>: when floating a panel you should always assign a fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport.</div></div></div></li><li><b><code>{@link Ext.Layer object}</code></b> : <div class="sub-desc">The specified object will be used as the configuration object for the {@link Ext.Layer} that will be created.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='html' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An HTML fragment, or a {@link Ext.DomHelper DomHelper} specification to use as the panel's body content (defaults to ''). The HTML content is added by the Panel's {@link #afterRender} method, and so the document will not contain this HTML at the time the {@link #render} event is fired. This content is inserted into the body <i>before</i> any configured {@link #contentEl} is appended.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='keys' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A {@link Ext.KeyMap} config object (in the format expected by {@link Ext.KeyMap#addBinding} used to assign custom key handling to this panel (defaults to <code>null</code>).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='draggable' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p><code>true</code> to enable dragging of this Panel (defaults to <code>false</code>).</p><p>For custom drag/drop implementations, an <b>Ext.Panel.DD</b> config could also be passed in this config instead of <code>true</code>. Ext.Panel.DD is an internal, undocumented class which moves a proxy Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a subclass of {@link Ext.dd.DragSource}, so behaviour may be added by implementing the interface methods of {@link Ext.dd.DragDrop} e.g.:</p><pre><code>new Ext.Panel({
title: 'Drag me',
x: 100,
y: 100,
renderTo: Ext.getBody(),
floating: true,
frame: true,
width: 400,
height: 200,
draggable: {
//      Config option of Ext.Panel.DD class.
//      It's a floating Panel, so do not show a placeholder proxy in the original position.
insertProxy: false,

//      Called for each mousemove event while dragging the DD object.
onDrag : function(e){
//          Record the x,y position of the drag proxy so that we can
//          position the Panel at end of drag.
var pel = this.proxy.getEl();
this.x = pel.getLeft(true);
this.y = pel.getTop(true);

//          Keep the Shadow aligned if there is one.
var s = this.panel.getEl().shadow;
if (s) {
s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
}
},

//      Called on the mouseup event.
endDrag : function(e){
this.panel.setPosition(this.x, this.y);
}
}
}).show();
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='bodyCfg'>
          <xs:annotation>
            <xs:documentation>
The Panel's body {@link Ext.Element Element} which may be used to contain HTML content. The content may be specified in the {@link #html} config, or it may be loaded using the {@link autoLoad} config, or through the Panel's {@link #getUpdater Updater}. Read-only. <p>If this is used to load visible HTML elements in either way, then the Panel may not be used as a Layout for hosting nested Panels.</p><p>If this Panel is intended to be used as the host of a Layout (See {@link #layout} then the body Element must not be loaded or changed - it is under the control of the Panel's Layout.<br/></p><p><b>Note</b>: see the Note for <code>{@link Ext.Component#el el}</code> also.</p>@type Ext.Element @property body The Panel's bwrap {@link Ext.Element Element} used to contain other Panel elements (tbar, body, bbar, footer). See {@link #bodyCfg}. Read-only. @type Ext.Element @property bwrap True if this panel is collapsed. Read-only. @type Boolean @property collapsed <p>A {@link Ext.DomHelper DomHelper} element specification object may be specified for any Panel Element.</p><p>By default, the Default element in the table below will be used for the html markup to create a child element with the commensurate Default class name (<code>baseCls</code> will be replaced by <code>{@link #baseCls}</code>):</p><pre>Panel      Default  Default             Custom      Additional       Additional
Element    element  class               element     class            style
========   ==========================   =========   ==============   ===========
{@link #header}     div      {@link #baseCls}+'-header'   {@link #headerCfg}   headerCssClass   headerStyle
{@link #bwrap}      div      {@link #baseCls}+'-bwrap'     {@link #bwrapCfg}    bwrapCssClass    bwrapStyle
+ tbar     div      {@link #baseCls}+'-tbar'       {@link #tbarCfg}     tbarCssClass     tbarStyle
+ {@link #body}     div      {@link #baseCls}+'-body'       {@link #bodyCfg}     {@link #bodyCssClass}     {@link #bodyStyle}
+ bbar     div      {@link #baseCls}+'-bbar'       {@link #bbarCfg}     bbarCssClass     bbarStyle
+ {@link #footer}   div      {@link #baseCls}+'-footer'   {@link #footerCfg}   footerCssClass   footerStyle
</pre><p>Configuring a Custom element may be used, for example, to force the {@link #body} Element to use a different form of markup than is created by default. An example of this might be to {@link Ext.Element#createChild create a child} Panel containing a custom content, such as a header, or forcing centering of all Panel content by having the body be a &lt;center&gt; element:</p><pre><code>new Ext.Panel({
title: 'Message Title',
renderTo: Ext.getBody(),
width: 200, height: 130,
<b>bodyCfg</b>: {
tag: 'center',
cls: 'x-panel-body',  // Default class not applied if Custom element specified
html: 'Message'
},
footerCfg: {
tag: 'h2',
cls: 'x-panel-footer'        // same as the Default class
html: 'footer html'
},
footerCssClass: 'custom-footer', // additional css class, see {@link Ext.element#addClass addClass}
footerStyle:    'background-color:red' // see {@link #bodyStyle}
});
</code></pre><p>The example above also explicitly creates a <code>{@link #footer}</code> with custom markup and styling applied.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='headerCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #header} Element. See <code>{@link #bodyCfg}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bwrapCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bwrap} Element. See <code>{@link #bodyCfg}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tbarCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #tbar} Element. See <code>{@link #bodyCfg}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bbarCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #bbar} Element. See <code>{@link #bodyCfg}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='footerCfg'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element specification object specifying the element structure of this Panel's {@link #footer} Element. See <code>{@link #bodyCfg}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='closable'>
          <xs:annotation>
            <xs:documentation>
Panels themselves do not directly support being closed, but some Panel subclasses do (like {@link Ext.Window}) or a Panel Class within an {@link Ext.TabPanel}. Specify <code>true</code> to enable closing in such situations. Defaults to <code>false</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tbar'>
          <xs:annotation>
            <xs:documentation>
<p>The top toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button configs to be added to the toolbar. Note that this is not available as a property after render. To access the top toolbar after render, use {@link #getTopToolbar}.</p><p><b>Note:</b> Although a Toolbar may contain Field components, these will <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy, and so are not scanned to collect form items. However, the values <b>will</b> be submitted because form submission parameters are collected from the DOM tree.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bbar'>
          <xs:annotation>
            <xs:documentation>
<p>The bottom toolbar of the panel. This can be a {@link Ext.Toolbar} object, a toolbar config, or an array of buttons/button configs to be added to the toolbar. Note that this is not available as a property after render. To access the bottom toolbar after render, use {@link #getBottomToolbar}.</p><p><b>Note:</b> Although a Toolbar may contain Field components, these will <b>not</b> be updated by a load of an ancestor FormPanel. A Panel's toolbars are not part of the standard Container-&gt;Component hierarchy, and so are not scanned to collect form items. However, the values <b>will</b> be submitted because form submission parameters are collected from the DOM tree.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='fbar'>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='header'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to create the Panel's header element explicitly, <code>false</code> to skip creating it. If a <code>{@link #title}</code> is set the header will be created automatically, otherwise it will not. If a <code>{@link #title}</code> is set but <code>header</code> is explicitly set to <code>false</code>, the header will not be rendered.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='footer'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to create the footer element explicitly, false to skip creating it. The footer will be created automatically if <code>{@link #buttons}</code> or a <code>{@link #fbar}</code> have been configured. See <code>{@link #bodyCfg}</code> for an example.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='title'>
          <xs:annotation>
            <xs:documentation>
The title text to be used as innerHTML (html tags are accepted) to display in the panel <code>{@link #header}</code> (defaults to ''). When a <code>title</code> is specified the <code>{@link #header}</code> element will automatically be created and displayed unless {@link #header} is explicitly set to <code>false</code>. If you do not want to specify a <code>title</code> at config time, but you may want one later, you must either specify a non-empty <code>title</code> (a blank space ' ' will do) or <code>header:true</code> so that the container element will get created.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='buttons'>
          <xs:annotation>
            <xs:documentation>
<code>buttons</code> will be used as <code>{@link Ext.Container#items items}</code> for the toolbar in the footer (<code>{@link #fbar}</code>). Typically the value of this configuration property will be an array of {@link Ext.Button}s or {@link Ext.Button} configuration objects. If an item is configured with <code>minWidth</code> or the Panel is configured with <code>minButtonWidth</code>, that width will be applied to the item.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoLoad'>
          <xs:annotation>
            <xs:documentation>
A valid url spec according to the Updater {@link Ext.Updater#update} method. If autoLoad is not null, the panel will attempt to load its contents immediately upon render.<p>The URL will become the default URL for this panel's {@link #body} element, so it may be {@link Ext.Element#refresh refresh}ed at any time.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='frame'>
          <xs:annotation>
            <xs:documentation>
<code>false</code> by default to render with plain 1px square borders. <code>true</code> to render with 9 elements, complete with custom rounded corners (also see {@link Ext.Element#boxWrap}). <p>The template generated for each condition is depicted below:</p><pre><code>
// frame = false
&lt;div id="developer-specified-id-goes-here" class="x-panel"&gt;

&lt;div class="x-panel-header"&gt;&lt;span class="x-panel-header-text"&gt;Title: (frame:false)&lt;/span&gt;&lt;/div&gt;

&lt;div class="x-panel-bwrap"&gt;
&lt;div class="x-panel-body"&gt;&lt;p&gt;html value goes here&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;

// frame = true (create 9 elements)
&lt;div id="developer-specified-id-goes-here" class="x-panel"&gt;
&lt;div class="x-panel-tl"&gt;&lt;div class="x-panel-tr"&gt;&lt;div class="x-panel-tc"&gt;
&lt;div class="x-panel-header"&gt;&lt;span class="x-panel-header-text"&gt;Title: (frame:true)&lt;/span&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="x-panel-bwrap"&gt;
&lt;div class="x-panel-ml"&gt;&lt;div class="x-panel-mr"&gt;&lt;div class="x-panel-mc"&gt;
&lt;div class="x-panel-body"&gt;&lt;p&gt;html value goes here&lt;/p&gt;&lt;/div&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;

&lt;div class="x-panel-bl"&gt;&lt;div class="x-panel-br"&gt;&lt;div class="x-panel-bc"/&gt;
&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;/div&gt;
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='border'>
          <xs:annotation>
            <xs:documentation>
True to display the borders of the panel's body element, false to hide them (defaults to true). By default, the border is a 2px wide inset border, but this can be further altered by setting {@link #bodyBorder} to false.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='bodyBorder'>
          <xs:annotation>
            <xs:documentation>
True to display an interior border on the body element of the panel, false to hide it (defaults to true). This only applies when {@link #border} == true. If border == true and bodyBorder == false, the border will display as a 1px wide inset border, giving the entire body element an inset appearance.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bodyCssClass'>
          <xs:annotation>
            <xs:documentation>
Additional css class selector to be applied to the {@link #body} element in the format expected by {@link Ext.Element#addClass} (defaults to null). See {@link #bodyCfg}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='bodyStyle'>
          <xs:annotation>
            <xs:documentation>
Custom CSS styles to be applied to the {@link #body} element in the format expected by {@link Ext.Element#applyStyles} (defaults to null). See {@link #bodyCfg}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconCls'>
          <xs:annotation>
            <xs:documentation>
The CSS class selector that specifies a background image to be used as the header icon (defaults to ''). <p>An example of specifying a custom icon class would be something like:</p><pre><code>// specify the property in the config for the class:
...
iconCls: 'my-icon'

// css class that specifies background image to be used as the icon image:
.my-icon { background-image: url(../images/my-icon.gif) 0 6px no-repeat !important; }
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='collapsible'>
          <xs:annotation>
            <xs:documentation>
True to make the panel collapsible and have the expand/collapse toggle button automatically rendered into the header tool button area, false to keep the panel statically sized with no button (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tools'>
          <xs:annotation>
            <xs:documentation>
An array of tool button configs to be added to the header tool area. When rendered, each tool is stored as an {@link Ext.Element Element} referenced by a public property called <code>tools.<i>&lt;tool-type&gt;</i></code> <p>Each tool config may contain the following properties:</p><div class="mdetail-params"><ul><li><b>id</b> : String<div class="sub-desc"><b>Required.</b> The type of tool to create. By default, this assigns a CSS class of the form <code>x-tool-<i>&lt;tool-type&gt;</i></code> to the resulting tool Element. Ext provides CSS rules, and an icon sprite containing images for the tool types listed below. The developer may implement custom tools by supplying alternate CSS rules and background images: <div style="margin-left: 2em"><div><code>toggle</code> (Created by default when {@link #collapsible} is <code>true</code>)</div><div><code>close</code></div><div><code>minimize</code></div><div><code>maximize</code></div><div><code>restore</code></div><div><code>gear</code></div><div><code>pin</code></div><div><code>unpin</code></div><div><code>right</code></div><div><code>left</code></div><div><code>up</code></div><div><code>down</code></div><div><code>refresh</code></div><div><code>minus</code></div><div><code>plus</code></div><div><code>help</code></div><div><code>search</code></div><div><code>save</code></div><div><code>print</code></div></div></div></li><li><b>handler</b> : Function<div class="sub-desc"><b>Required.</b> The function to call when clicked. Arguments passed are:<ul><li><b>event</b> : Ext.EventObject<div class="sub-desc">The click event.</div></li><li><b>toolEl</b> : Ext.Element<div class="sub-desc">The tool Element.</div></li><li><b>panel</b> : Ext.Panel<div class="sub-desc">The host Panel</div></li><li><b>tc</b> : Ext.Panel<div class="sub-desc">The tool configuration object</div></li></ul></div></li><li><b>stopEvent</b> : Boolean<div class="sub-desc">Defaults to true. Specify as false to allow click event to propagate.</div></li><li><b>scope</b> : Object<div class="sub-desc">The scope in which to call the handler.</div></li><li><b>qtip</b> : String/Object<div class="sub-desc">A tip string, or a config argument to {@link Ext.QuickTip#register}</div></li><li><b>hidden</b> : Boolean<div class="sub-desc">True to initially render hidden.</div></li><li><b>on</b> : Object<div class="sub-desc">A listener config object specifiying event listeners in the format of an argument to {@link #addListener}</div></li></ul></div><p>Note that, apart from the toggle tool which is provided when a panel is collapsible, these tools only provide the visual button. Any required functionality must be provided by adding handlers that implement the necessary behavior.</p><p>Example usage:</p><pre><code>tools:[{
id:'refresh',
qtip: 'Refresh form Data',
// hidden:true,
handler: function(event, toolEl, panel){
// refresh logic
}
},
{
id:'help',
qtip: 'Get Help',
handler: function(event, toolEl, panel){
// whatever
}
}]
</code></pre><p>For the custom id of <code>'help'</code> define two relevant css classes with a link to a 15x15 image:</p><pre><code>.x-tool-help {background-image: url(images/help.png);}
.x-tool-help-over {background-image: url(images/help_over.png);}
// if using an image sprite:
.x-tool-help {background-image: url(images/help.png) no-repeat 0 0;}
.x-tool-help-over {background-position:-15px 0;}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='toolTemplate'>
          <xs:annotation>
            <xs:documentation>
<p>A Template used to create {@link #tools} in the {@link #header} Element. Defaults to:</p><pre><code>new Ext.Template('&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;')</code></pre><p>This may may be overridden to provide a custom DOM structure for tools based upon a more complex XTemplate. The template's data is a single tool configuration object (Not the entire Array) as specified in {@link #tools}. In the following example an &lt;a&gt; tag is used to provide a visual indication when hovering over the tool:</p><pre><code>var win = new Ext.Window({
tools: [{
id: 'download',
href: '/MyPdfDoc.pdf'
}],
toolTemplate: new Ext.XTemplate(
'&lt;tpl if="id==\'download\'"&gt;',
'&lt;a class="x-tool x-tool-pdf" href="{href}"&gt;&lt;/a&gt;',
'&lt;/tpl&gt;',
'&lt;tpl if="id!=\'download\'"&gt;',
'&lt;div class="x-tool x-tool-{id}"&gt;&amp;#160;&lt;/div&gt;',
'&lt;/tpl&gt;'
),
width:500,
height:300,
closeAction:'hide'
});</code></pre><p>Note that the CSS class 'x-tool-pdf' should have an associated style rule which provides an appropriate background image, something like:</p><pre><code>a.x-tool-pdf {background-image: url(../shared/extjs/images/pdf.gif)!important;}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideCollapseTool'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to hide the expand/collapse toggle button when <code>{@link #collapsible} == true</code>, <code>false</code> to display it (defaults to <code>false</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='titleCollapse'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to allow expanding and collapsing the panel (when <code>{@link #collapsible} = true</code>) by clicking anywhere in the header bar, <code>false</code>) to allow it only by clicking to tool button (defaults to <code>false</code>)). If this panel is a child item of a border layout also see the {@link Ext.layout.BorderLayout.Region BorderLayout.Region} <code>{@link Ext.layout.BorderLayout.Region#floatable floatable}</code> config option.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoScroll'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to use overflow:'auto' on the panel's body element and show scroll bars automatically when necessary, <code>false</code> to clip any overflowing content (defaults to <code>false</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='floating'>
          <xs:annotation>
            <xs:documentation>
<p>This property is used to configure the underlying {@link Ext.Layer}. Acceptable values for this configuration property are:</p><div class="mdetail-params"><ul><li><b><code>false</code></b> : <b>Default.</b><div class="sub-desc">Display the panel inline where it is rendered.</div></li><li><b><code>true</code></b> : <div class="sub-desc">Float the panel (absolute position it with automatic shimming and shadow).<div style="margin-left: 2em"><div class="sub-desc">Setting floating to true will create an Ext.Layer for this panel and display the panel at negative offsets so that it is hidden.</div><div class="sub-desc">Since the panel will be absolute positioned, the position must be set explicitly <i>after</i> render (e.g., <code>myPanel.setPosition(100,100);</code>).</div><div class="sub-desc"><b>Note</b>: when floating a panel you should always assign a fixed width, otherwise it will be auto width and will expand to fill to the right edge of the viewport.</div></div></div></li><li><b><code>{@link Ext.Layer object}</code></b> : <div class="sub-desc">The specified object will be used as the configuration object for the {@link Ext.Layer} that will be created.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> (or a valid Ext.Shadow {@link Ext.Shadow#mode} value) to display a shadow behind the panel, <code>false</code> to display no shadow (defaults to <code>'sides'</code>). Note that this option only applies when <code>{@link #floating} = true</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='shadowOffset'>
          <xs:annotation>
            <xs:documentation>
The number of pixels to offset the shadow if displayed (defaults to <code>4</code>). Note that this option only applies when <code>{@link #floating} = true</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='shim'>
          <xs:annotation>
            <xs:documentation>
<code>false</code> to disable the iframe shim in browsers which need one (defaults to <code>true</code>). Note that this option only applies when <code>{@link #floating} = true</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='html'>
          <xs:annotation>
            <xs:documentation>
An HTML fragment, or a {@link Ext.DomHelper DomHelper} specification to use as the panel's body content (defaults to ''). The HTML content is added by the Panel's {@link #afterRender} method, and so the document will not contain this HTML at the time the {@link #render} event is fired. This content is inserted into the body <i>before</i> any configured {@link #contentEl} is appended.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='contentEl'>
          <xs:annotation>
            <xs:documentation>
<p>Optional. Specify an existing HTML element, or the <code>id</code> of an existing HTML element to use as this Panel's <code><b>{@link #body}</b></code> content.</p><ul><li><b>Description</b> : <div class="sub-desc">This config option is used to take an existing HTML element and place it in the body of a new panel (it simply moves the specified DOM element into the body element of the Panel <i>after the Panel is rendered</i> to use as the content (it is not going to be the actual panel itself).</div></li><li><b>Notes</b> : <div class="sub-desc">The specified HTML element is appended to the Panel's {@link #body} Element by the Panel's <code>afterRender</code> method <i>after any configured {@link #html HTML} has been inserted</i>, and so the document will not contain this element at the time the {@link #render} event is fired.</div><div class="sub-desc">The specified HTML element used will not participate in any <code><b>{@link Ext.Container#layout layout}</b></code> scheme that the Panel may use. It is just HTML. Layouts operate on child <code><b>{@link Ext.Container#items items}</b></code>.</div><div class="sub-desc">Add either the <code>x-hidden</code> or the <code>x-hide-display</code> CSS class to prevent a brief flicker of the content before it is rendered to the panel.</div></li></ul>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='keys'>
          <xs:annotation>
            <xs:documentation>
A {@link Ext.KeyMap} config object (in the format expected by {@link Ext.KeyMap#addBinding} used to assign custom key handling to this panel (defaults to <code>null</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='draggable'>
          <xs:annotation>
            <xs:documentation>
<p><code>true</code> to enable dragging of this Panel (defaults to <code>false</code>).</p><p>For custom drag/drop implementations, an <b>Ext.Panel.DD</b> config could also be passed in this config instead of <code>true</code>. Ext.Panel.DD is an internal, undocumented class which moves a proxy Element around in place of the Panel's element, but provides no other behaviour during dragging or on drop. It is a subclass of {@link Ext.dd.DragSource}, so behaviour may be added by implementing the interface methods of {@link Ext.dd.DragDrop} e.g.:</p><pre><code>new Ext.Panel({
title: 'Drag me',
x: 100,
y: 100,
renderTo: Ext.getBody(),
floating: true,
frame: true,
width: 400,
height: 200,
draggable: {
//      Config option of Ext.Panel.DD class.
//      It's a floating Panel, so do not show a placeholder proxy in the original position.
insertProxy: false,

//      Called for each mousemove event while dragging the DD object.
onDrag : function(e){
//          Record the x,y position of the drag proxy so that we can
//          position the Panel at end of drag.
var pel = this.proxy.getEl();
this.x = pel.getLeft(true);
this.y = pel.getTop(true);

//          Keep the Shadow aligned if there is one.
var s = this.panel.getEl().shadow;
if (s) {
s.realign(this.x, this.y, pel.getWidth(), pel.getHeight());
}
},

//      Called on the mouseup event.
endDrag : function(e){
this.panel.setPosition(this.x, this.y);
}
}
}).show();
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseCls'>
          <xs:annotation>
            <xs:documentation>
The base CSS class to apply to this panel's element (defaults to <code>'x-panel'</code>). <p>Another option available by default is to specify <code>'x-plain'</code> which strips all styling except for required attributes for Ext layouts to function (e.g. overflow:hidden). See <code>{@link #unstyled}</code> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='collapsedCls'>
          <xs:annotation>
            <xs:documentation>
A CSS class to add to the panel's element after it has been collapsed (defaults to <code>'x-panel-collapsed'</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='maskDisabled'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to mask the panel when it is {@link #disabled}, <code>false</code> to not mask it (defaults to <code>true</code>). Either way, the panel will always tell its contained elements to disable themselves when it is disabled, but masking the panel can provide an additional visual cue that the panel is disabled.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animCollapse'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to animate the transition when the panel is collapsed, <code>false</code> to skip the animation (defaults to <code>true</code> if the {@link Ext.Fx} class is available, otherwise <code>false</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='headerAsText'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to display the panel <code>{@link #title}</code> in the <code>{@link #header}</code>, <code>false</code> to hide it (defaults to <code>true</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='buttonAlign'>
          <xs:annotation>
            <xs:documentation>
The alignment of any {@link #buttons} added to this panel. Valid values are <code>'right'</code>, <code>'left'</code> and <code>'center'</code> (defaults to <code>'right'</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='collapsed'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to render the panel collapsed, <code>false</code> to render it expanded (defaults to <code>false</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='collapseFirst'>
          <xs:annotation>
            <xs:documentation>
<code>true</code> to make sure the collapse/expand toggle button always renders first (to the left of) any other tools in the panel's title bar, <code>false</code> to render it last (defaults to <code>true</code>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minButtonWidth'>
          <xs:annotation>
            <xs:documentation>
Minimum width in pixels of all {@link #buttons} in this panel (defaults to <code>75</code>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='unstyled'>
          <xs:annotation>
            <xs:documentation>
Overrides the <code>{@link #baseCls}</code> setting to <code>{@link #baseCls} = 'x-plain'</code> which renders the panel unstyled except for required attributes for Ext layouts to function (e.g. overflow:hidden).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='elements'>
          <xs:annotation>
            <xs:documentation>
A comma-delimited list of panel elements to initialize when the panel is rendered. Normally, this list will be generated automatically based on the items added to the panel at config time, but sometimes it might be useful to make sure a structural element is rendered even if not specified at config time (for example, you may want to add a button or toolbar dynamically after the panel has been rendered). Adding those elements to this list will allocate the required placeholders in the panel when it is rendered. Valid values are<div class="mdetail-params"><ul><li><code>header</code></li><li><code>tbar</code> (top bar)</li><li><code>body</code></li><li><code>bbar</code> (bottom bar)</li><li><code>footer</code></li></ul></div>Defaults to '<code>body</code>'.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='preventBodyReset'>
          <xs:annotation>
            <xs:documentation>
Defaults to <code>false</code>. When set to <code>true</code>, an extra css class <code>'x-panel-normal'</code> will be added to the panel's element, effectively applying css styles suggested by the W3C (see http://www.w3.org/TR/CSS21/sample.html) to the Panel's <b>body</b> element (not the header, footer, etc.).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='panel' type='ext:ext.Panel' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>
The Panel's header {@link Ext.Element Element}. Read-only. <p>This Element is used to house the {@link #title} and {@link #tools}</p><br/><p><b>Note</b>: see the Note for <code>{@link Ext.Component#el el}</code> also.</p>@type Ext.Element @property header
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Editor'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:all>
            <xs:element name='field' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The Field object (or descendant) or config object for field
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='value' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The data value of the underlying field (defaults to "")
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='field'>
          <xs:annotation>
            <xs:documentation>
The Field object (or descendant) or config object for field
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowBlur'>
          <xs:annotation>
            <xs:documentation>
True to {@link #completeEdit complete the editing process} if in edit mode when the field is blurred. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoSize'>
          <xs:annotation>
            <xs:documentation>
True for the editor to automatically adopt the size of the underlying field, "width" to adopt the width only, or "height" to adopt the height only, "none" to always use the field dimensions. (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='revertInvalid'>
          <xs:annotation>
            <xs:documentation>
True to automatically revert the field value and cancel the edit when the user completes an edit and the field validation fails (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ignoreNoChange'>
          <xs:annotation>
            <xs:documentation>
True to skip the edit completion process (no save, no events fired) if the user completes an edit and the value has not changed (defaults to false). Applies only to string values - edits for other data types will never be ignored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideEl'>
          <xs:annotation>
            <xs:documentation>
False to keep the bound element visible while the editor is displayed (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='value'>
          <xs:annotation>
            <xs:documentation>
The data value of the underlying field (defaults to "")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='alignment'>
          <xs:annotation>
            <xs:documentation>
The position to align to (see {@link Ext.Element#alignTo} for more details, defaults to "c-c?").
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>
"sides" for sides/bottom only, "frame" for 4-way shadow, and "drop" for bottom-right shadow (defaults to "frame")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='constrain'>
          <xs:annotation>
            <xs:documentation>
True to constrain the editor to the viewport
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='swallowKeys'>
          <xs:annotation>
            <xs:documentation>
Handle the keydown/keypress events so they don't propagate (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='completeOnEnter'>
          <xs:annotation>
            <xs:documentation>
True to complete the edit when the enter key is pressed. Defaults to <tt>true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='cancelOnEsc'>
          <xs:annotation>
            <xs:documentation>
True to cancel the edit when the escape key is pressed. Defaults to <tt>true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='updateEl'>
          <xs:annotation>
            <xs:documentation>
True to update the innerHTML of the bound element when the update completes (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='editor' type='ext:ext.Editor' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
A base editor field that handles displaying/hiding on demand and has some built-in sizing and event handling logic.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ColorPalette'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:all>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>An array of 6-digit color hex code strings (without the # symbol). This array can contain any number of colors, and each hex code should be unique. The width of the palette is controlled via CSS by adjusting the width property of the 'x-color-palette' class (or assigning a custom class), so you can balance the number of colors with the width setting until the box is symmetrical.</p><p>You can override individual colors if needed:</p><pre><code>var cp = new Ext.ColorPalette();
cp.colors[0] = 'FF0000';  // change the first box to red
</code></pre>Or you can provide a custom array of your own for complete control: <pre><code>var cp = new Ext.ColorPalette();
cp.colors = ['000000', '993300', '333300'];
</code></pre>@type Array Optional. A function that will handle the select event of this palette. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>palette</code> : ColorPalette<div class="sub-desc">The {@link #palette Ext.ColorPalette}.</div></li><li><code>color</code> : String<div class="sub-desc">The 6-digit color hex code (without the # symbol).</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this ColorPalette instance.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='tpl'>
          <xs:annotation>
            <xs:documentation>
An existing XTemplate instance to be used in place of the default template for rendering the component.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='value'>
          <xs:annotation>
            <xs:documentation>
The initial color to highlight (should be a valid 6-digit color hex code without the # symbol). Note that the hex codes are case-sensitive.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowReselect'>
          <xs:annotation>
            <xs:documentation>
If set to true then reselecting a color that is already selected fires the {@link #select} event
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
<p>An array of 6-digit color hex code strings (without the # symbol). This array can contain any number of colors, and each hex code should be unique. The width of the palette is controlled via CSS by adjusting the width property of the 'x-color-palette' class (or assigning a custom class), so you can balance the number of colors with the width setting until the box is symmetrical.</p><p>You can override individual colors if needed:</p><pre><code>var cp = new Ext.ColorPalette();
cp.colors[0] = 'FF0000';  // change the first box to red
</code></pre>Or you can provide a custom array of your own for complete control: <pre><code>var cp = new Ext.ColorPalette();
cp.colors = ['000000', '993300', '333300'];
</code></pre>@type Array Optional. A function that will handle the select event of this palette. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>palette</code> : ColorPalette<div class="sub-desc">The {@link #palette Ext.ColorPalette}.</div></li><li><code>color</code> : String<div class="sub-desc">The 6-digit color hex code (without the # symbol).</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this ColorPalette instance.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='colorpalette' type='ext:ext.ColorPalette' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
@event beforestartedit Fires when editing is initiated, but before the value changes. Editing can be canceled by returning false from the handler of this event. @param {Editor} this @param {Ext.Element} boundEl The underlying element bound to this editor @param {Mixed} value The field value being set @event startedit Fires when this editor is displayed @param {Ext.Element} boundEl The underlying element bound to this editor @param {Mixed} value The starting field value @event beforecomplete Fires after a change has been made to the field, but before the change is reflected in the underlying field. Saving the change to the field can be canceled by returning false from the handler of this event. Note that if the value has not changed and ignoreNoChange = true, the editing will still end but this event will not fire since no edit actually occurred. @param {Editor} this @param {Mixed} value The current field value @param {Mixed} startValue The original field value @event complete Fires after editing is complete and any changed value has been written to the underlying field. @param {Editor} this @param {Mixed} value The current field value @param {Mixed} startValue The original field value @event canceledit Fires after editing has been canceled and the editor's value has been reset. @param {Editor} this @param {Mixed} value The user-entered field value that was discarded @param {Mixed} startValue The original field value that was set back into the editor after cancel @event specialkey Fires when any key related to navigation (arrows, tab, enter, esc, etc.) is pressed. You can check {@link Ext.EventObject#getKey} to determine which key was pressed. @param {Ext.form.Field} this @param {Ext.EventObject} e The event object Starts the editing process and shows the editor. @param {Mixed} el The element to edit @param {String} value (optional) A value to initialize the editor with. If a value is not provided, it defaults to the innerHTML of el. Sets the height and width of this editor. @param {Number} width The new width @param {Number} height The new height Realigns the editor to the bound field based on the current alignment config value. Ends the editing process, persists the changed value to the underlying field, and hides the editor. @param {Boolean} remainVisible Override the default behavior and keep the editor visible after edit (defaults to false) Cancels the editing process and hides the editor without persisting any changes. The field value will be reverted to the original starting value. @param {Boolean} remainVisible Override the default behavior and keep the editor visible after cancel (defaults to false) Sets the data value of the editor @param {Mixed} value Any valid value supported by the underlying field Gets the data value of the editor @return {Mixed} The data value @event select Fires when a color is selected @param {ColorPalette} this @param {String} color The 6-digit color hex code (without the # symbol)
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.DatePicker'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:all>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Optional. A function that will handle the select event of this picker. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>picker</code> : DatePicker<div class="sub-desc">The Ext.DatePicker.</div></li><li><code>date</code> : Date<div class="sub-desc">The selected date.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this DatePicker instance.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='monthNames' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of textual month names which can be overriden for localization support (defaults to Date.monthNames)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='dayNames' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of textual day names which can be overriden for localization support (defaults to Date.dayNames)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDays' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of days to disable, 0-based. For example, [0, 6] disables Sunday and Saturday (defaults to null).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDatesRE' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    JavaScript regular expression used to disable a pattern of dates (defaults to null). The {@link #disabledDates} config will generate this regex internally, but if you specify disabledDatesRE it will take precedence over the disabledDates value.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDates' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of 'dates' to disable, as strings. These strings will be used to build a dynamic regular expression so they are very powerful. Some examples: <ul><li>['03/08/2003', '09/16/2003'] would disable those exact dates</li><li>['03/08', '09/16'] would disable those days for every year</li><li>['^03/08'] would only match the beginning (useful if you are using short years)</li><li>['03/../2006'] would disable every day in March 2006</li><li>['^03'] would disable every day in every March</li></ul>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support regular expressions, if you are using a date format that has '.' in it, you will have to escape the dot when restricting dates. For example: ['03\\.08\\.03'].
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='todayText'>
          <xs:annotation>
            <xs:documentation>
The text to display on the button that selects the current date (defaults to <tt>'Today'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='okText'>
          <xs:annotation>
            <xs:documentation>
The text to display on the ok button (defaults to <tt>' OK '</tt> to give the user extra clicking room)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='cancelText'>
          <xs:annotation>
            <xs:documentation>
The text to display on the cancel button (defaults to <tt>'Cancel'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
Optional. A function that will handle the select event of this picker. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>picker</code> : DatePicker<div class="sub-desc">The Ext.DatePicker.</div></li><li><code>date</code> : Date<div class="sub-desc">The selected date.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this DatePicker instance.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='todayTip'>
          <xs:annotation>
            <xs:documentation>
The tooltip to display for the button that selects the current date (defaults to <tt>'{current date} (Spacebar)'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if the minDate validation fails (defaults to <tt>'This date is before the minimum date'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if the maxDate validation fails (defaults to <tt>'This date is after the maximum date'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
The default date format string which can be overriden for localization support. The format must be valid according to {@link Date#parseDate} (defaults to <tt>'m/d/y'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDaysText'>
          <xs:annotation>
            <xs:documentation>
The tooltip to display when the date falls on a disabled day (defaults to <tt>'Disabled'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDatesText'>
          <xs:annotation>
            <xs:documentation>
The tooltip text to display when the date falls on a disabled date (defaults to <tt>'Disabled'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='monthNames'>
          <xs:annotation>
            <xs:documentation>
An array of textual month names which can be overriden for localization support (defaults to Date.monthNames)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dayNames'>
          <xs:annotation>
            <xs:documentation>
An array of textual day names which can be overriden for localization support (defaults to Date.dayNames)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='nextText'>
          <xs:annotation>
            <xs:documentation>
The next month navigation button tooltip (defaults to <tt>'Next Month (Control+Right)'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='prevText'>
          <xs:annotation>
            <xs:documentation>
The previous month navigation button tooltip (defaults to <tt>'Previous Month (Control+Left)'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='monthYearText'>
          <xs:annotation>
            <xs:documentation>
The header month selector tooltip (defaults to <tt>'Choose a month (Control+Up/Down to move years)'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='startDay'>
          <xs:annotation>
            <xs:documentation>
Day index at which the week should begin, 0-based (defaults to 0, which is Sunday)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showToday'>
          <xs:annotation>
            <xs:documentation>
False to hide the footer area containing the Today button and disable the keyboard handler for spacebar that selects the current date (defaults to <tt>true</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:date' name='minDate'>
          <xs:annotation>
            <xs:documentation>
Minimum allowable date (JavaScript date object, defaults to null)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:date' name='maxDate'>
          <xs:annotation>
            <xs:documentation>
Maximum allowable date (JavaScript date object, defaults to null)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDays'>
          <xs:annotation>
            <xs:documentation>
An array of days to disable, 0-based. For example, [0, 6] disables Sunday and Saturday (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDatesRE'>
          <xs:annotation>
            <xs:documentation>
JavaScript regular expression used to disable a pattern of dates (defaults to null). The {@link #disabledDates} config will generate this regex internally, but if you specify disabledDatesRE it will take precedence over the disabledDates value.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDates'>
          <xs:annotation>
            <xs:documentation>
An array of 'dates' to disable, as strings. These strings will be used to build a dynamic regular expression so they are very powerful. Some examples: <ul><li>['03/08/2003', '09/16/2003'] would disable those exact dates</li><li>['03/08', '09/16'] would disable those days for every year</li><li>['^03/08'] would only match the beginning (useful if you are using short years)</li><li>['03/../2006'] would disable every day in March 2006</li><li>['^03'] would disable every day in every March</li></ul>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support regular expressions, if you are using a date format that has '.' in it, you will have to escape the dot when restricting dates. For example: ['03\\.08\\.03'].
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='datepicker' type='ext:ext.DatePicker' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
Simple date picker class.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Slider'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:int' name='value'>
          <xs:annotation>
            <xs:documentation>
The value to initialize the slider with. Defaults to minValue.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='vertical'>
          <xs:annotation>
            <xs:documentation>
Orient the Slider vertically rather than horizontally, defaults to false.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum value for the Slider. Defaults to 0.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum value for the Slider. Defaults to 100.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='decimalPrecision'>
          <xs:annotation>
            <xs:documentation>
. <p>The number of decimal places to which to round the Slider's value. Defaults to 0.</p><p>To disable rounding, configure as <tt><b>false</b></tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='keyIncrement'>
          <xs:annotation>
            <xs:documentation>
How many units to change the Slider when adjusting with keyboard navigation. Defaults to 1. If the increment config is larger, it will be used instead.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='increment'>
          <xs:annotation>
            <xs:documentation>
How many units to change the slider when adjusting by drag and drop. Use this option to enable 'snapping'.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='clickToChange'>
          <xs:annotation>
            <xs:documentation>
Determines whether or not clicking on the Slider axis will change the slider. Defaults to true
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animate'>
          <xs:annotation>
            <xs:documentation>
Turn on or off animation. Defaults to true
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='slider' type='ext:ext.Slider' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Read-only. True if the mask is currently disabled so that it will not be displayed (defaults to false) @type Boolean Disables the mask to prevent it from being displayed Enables the mask so that it can be displayed Show this LoadMask over the configured Element. Hide this LoadMask.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ProgressBar'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:all>
            <xs:element name='textEl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The element to render the progress text to (defaults to the progress
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:float' name='value'>
          <xs:annotation>
            <xs:documentation>
A floating point value between 0 and 1 (e.g., .5, defaults to 0)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The progress bar text (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='textEl'>
          <xs:annotation>
            <xs:documentation>
The element to render the progress text to (defaults to the progress
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseCls'>
          <xs:annotation>
            <xs:documentation>
The base CSS class to apply to the progress bar's wrapper element (defaults to 'x-progress')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animate'>
          <xs:annotation>
            <xs:documentation>
True to animate the progress bar during transitions (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='progress' type='ext:ext.ProgressBar' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
True while the thumb is in a drag operation @type boolean @event beforechange Fires before the slider value is changed. By returning false from an event handler, you can cancel the event and prevent the slider from changing. @param {Ext.Slider} slider The slider @param {Number} newValue The new value which the slider is being changed to. @param {Number} oldValue The old value which the slider was previously. @event change Fires when the slider value is changed. @param {Ext.Slider} slider The slider @param {Number} newValue The new value which the slider has been changed to. @event changecomplete Fires when the slider value is changed by the user and any drag operations have completed. @param {Ext.Slider} slider The slider @param {Number} newValue The new value which the slider has been changed to. @event dragstart Fires after a drag operation has started. @param {Ext.Slider} slider The slider @param {Ext.EventObject} e The event fired from Ext.dd.DragTracker @event drag Fires continuously during the drag operation while the mouse is moving. @param {Ext.Slider} slider The slider @param {Ext.EventObject} e The event fired from Ext.dd.DragTracker @event dragend Fires after the drag operation has completed. @param {Ext.Slider} slider The slider @param {Ext.EventObject} e The event fired from Ext.dd.DragTracker Programmatically sets the value of the Slider. Ensures that the value is constrained within the minValue and maxValue. @param {Number} value The value to set the slider to. (This will be constrained within minValue and maxValue) @param {Boolean} animate Turn on or off animation, defaults to true Synchronizes the thumb position to the proper proportion of the total component width based on the current slider {@link #value}. This will be called automatically when the Slider is resized by a layout, but if it is rendered auto width, this method can be called from another resize handler to sync the Slider if necessary. Returns the current value of the slider @return {Number} The current value of the slider
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.data.Store'>
        <xs:all>
            <xs:element name='autoLoad' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    If <tt>{@link #data}</tt> is not specified, and if <tt>autoLoad</tt> is <tt>true</tt> or an <tt>Object</tt>, this store's {@link #load} method is automatically called after creation. If the value of <tt>autoLoad</tt> is an <tt>Object</tt>, this <tt>Object</tt> will be passed to the store's {@link #load} method.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='proxy' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.DataProxy DataProxy} object which provides access to a data object. See <code>{@link #url}</code>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='data' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An inline data object readable by the <code>{@link #reader}</code>. Typically this option, or the <code>{@link #url}</code> option will be specified.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='reader' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.DataReader Reader} object which processes the data object and returns an Array of {@link Ext.data.Record} objects which are cached keyed by their <b><tt>{@link Ext.data.Record#id id}</tt></b> property.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='writer' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>The {@link Ext.data.DataWriter Writer} object which processes a record object for being written to the server-side database.</p><br/><p>When a writer is installed into a Store the {@link #add}, {@link #remove}, and {@link #update} events on the store are monitored in order to remotely {@link #createRecords create records}, {@link #destroyRecord destroy records}, or {@link #updateRecord update records}.</p><br/><p>The proxy for this store will relay any {@link #writexception} events to this store.</p><br/><p>Sample implementation:</p><pre><code>var writer = new {@link Ext.data.JsonWriter}({
encode: true,
writeAllFields: true // write all fields, not just those that changed
});

// Typical Store collecting the Proxy, Reader and Writer together.
var store = new Ext.data.Store({
storeId: 'user',
root: 'records',
proxy: proxy,
reader: reader,
writer: writer,     // &lt;-- plug a DataWriter into the store just as you would a Reader
paramsAsHash: true,
autoSave: false    // &lt;-- false to delay executing create, update, destroy requests
//     until specifically told to do so.
});
</code></pre><br/><br/>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='baseParams' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>An object containing properties which are to be sent as parameters for <i>every</i> HTTP request.</p><p>Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.</p><p><b>Note</b>: <code>baseParams</code> may be superseded by any <code>params</code> specified in a <code>{@link #load}</code> request, see <code>{@link #load}</code> for more details.</p>This property may be modified after creation using the <code>{@link #setBaseParam}</code> method. @property
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='sortInfo' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A config object to specify the sort order in the request of a Store's {@link #load} operation. Note that for local sorting, the <tt>direction</tt> property is case-sensitive. See also {@link #remoteSort} and {@link #paramNames}. For example:<pre><code>sortInfo: {
field: 'fieldName',
direction: 'ASC' // or 'DESC' (case sensitive for local sorting)
}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='remoteSort' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <tt>true</tt> if sorting is to be handled by requesting the <tt>{@link #proxy Proxy}</tt> to provide a refreshed version of the data object in sorted order, as opposed to sorting the Record cache in place (defaults to <tt>false</tt>). <p>If <tt>remoteSort</tt> is <tt>true</tt>, then clicking on a {@link Ext.grid.Column Grid Column}'s {@link Ext.grid.Column#header header} causes the current page to be requested from the server appending the following two parameters to the <b><tt>{@link #load params}</tt></b>:</p><div class="mdetail-params"><ul><li><b><tt>sort</tt></b> : String<p class="sub-desc">The <tt>name</tt> (as specified in the Record's {@link Ext.data.Field Field definition}) of the field to sort on.</p></li><li><b><tt>dir</tt></b> : String<p class="sub-desc">The direction of the sort, 'ASC' or 'DESC' (case-sensitive).</p></li></ul></div><br/><br/>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='paramNames' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>An object containing properties which specify the names of the paging and sorting parameters passed to remote servers when loading blocks of data. By default, this object takes the following form:</p><pre><code>{
start : 'start',  // The parameter name which specifies the start row
limit : 'limit',  // The parameter name which specifies number of rows to return
sort : 'sort',    // The parameter name which specifies the column to sort on
dir : 'dir'       // The parameter name which specifies the sort direction
}
</code></pre><p>The server must produce the requested data block upon receipt of these parameter names. If different parameter names are required, this property can be overriden using a configuration property.</p><p>A {@link Ext.PagingToolbar PagingToolbar} bound to this Store uses this property to determine the parameter names to use in its {@link #load requests}.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='defaultParamNames' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Provides the default values for the {@link #paramNames} property. To globally modify the parameters for all stores, this object should be changed on the store prototype.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='defined' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Destroys the store. Add Records to the Store and fires the {@link #add} event. To add Records to the store from a remote source use <code>{@link #load}({add:true})</code>. See also <code>{@link #recordType}</code> and <code>{@link #insert}</code>. @param {Ext.data.Record[]} records An Array of Ext.data.Record objects to add to the cache. See {@link #recordType}. (Local sort only) Inserts the passed Record into the Store at the index where it should go based on the current sort information. @param {Ext.data.Record} record Remove a Record from the Store and fires the {@link #remove} event. @param {Ext.data.Record} record The Ext.data.Record object to remove from the cache. Remove a Record from the Store at the specified index. Fires the {@link #remove} event. @param {Number} index The index of the record to remove. Remove all Records from the Store and fires the {@link #clear} event. Inserts Records into the Store at the given index and fires the {@link #add} event. See also <code>{@link #add}</code> and <code>{@link #addSorted}</code>. @param {Number} index The start index at which to insert the passed Records. @param {Ext.data.Record[]} records An Array of Ext.data.Record objects to add to the cache. Get the index within the cache of the passed Record. @param {Ext.data.Record} record The Ext.data.Record object to find. @return {Number} The index of the passed Record. Returns -1 if not found. Get the index within the cache of the Record with the passed id. @param {String} id The id of the Record to find. @return {Number} The index of the Record. Returns -1 if not found. Get the Record with the specified id. @param {String} id The id of the Record to find. @return {Ext.data.Record} The Record with the passed id. Returns undefined if not found. Get the Record at the specified index. @param {Number} index The index of the Record to find. @return {Ext.data.Record} The Record at the passed index. Returns undefined if not found. Returns a range of Records between specified indices. @param {Number} startIndex (optional) The starting index (defaults to 0) @param {Number} endIndex (optional) The ending index (defaults to the last Record in the Store) @return {Ext.data.Record[]} An array of Records <p>Loads the Record cache from the configured <tt>{@link #proxy}</tt> using the configured <tt>{@link #reader}</tt>.</p><br/><p>Notes:</p><div class="mdetail-params"><ul><li><b><u>Important</u></b>: loading is asynchronous! This call will return before the new data has been loaded. To perform any post-processing where information from the load call is required, specify the <tt>callback</tt> function to be called, or use a {@link Ext.util.Observable#listeners a 'load' event handler}.</li><li>If using {@link Ext.PagingToolbar remote paging}, the first load call must specify the <tt>start</tt> and <tt>limit</tt> properties in the <code>options.params</code> property to establish the initial position within the dataset, and the number of Records to cache on each read from the Proxy.</li><li>If using {@link #remoteSort remote sorting}, the configured <code>{@link #sortInfo}</code> will be automatically included with the posted parameters according to the specified <code>{@link #paramNames}</code>.</li></ul></div>@param {Object} options An object containing properties which control loading options:<ul><li><b><tt>params</tt></b> :Object<div class="sub-desc"><p>An object containing properties to pass as HTTP parameters to a remote data source. <b>Note</b>: <code>params</code> will override any <code>{@link #baseParams}</code> of the same name.</p><p>Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.</p></div></li><li><b><tt>callback</tt></b> : Function<div class="sub-desc"><p>A function to be called after the Records have been loaded. The <tt>callback</tt> is called after the load event and is passed the following arguments:</p><ul><li><tt>r</tt> : Ext.data.Record[]</li><li><tt>options</tt>: Options object from the load call</li><li><tt>success</tt>: Boolean success indicator</li></ul><br/><br/></div></li><li><b><tt>scope</tt></b> : Object<div class="sub-desc"><p>Scope with which to call the callback (defaults to the Store object)</p></div></li><li><b><tt>add</tt></b> : Boolean<div class="sub-desc"><p>Indicator to append loaded records rather than replace the current cache. <b>Note</b>: see note for <tt>{@link #loadData}</tt></p></div></li></ul>@return {Boolean} If the <i>developer</i> provided <tt>{@link #beforeload}</tt> event handler returns <tt>false</tt>, the load call will abort and will return <tt>false</tt>; otherwise will return <tt>true</tt>. updateRecord Should not be used directly. This method will be called automatically if a Writer is set. Listens to 'update' event. @param {Object} store @param {Object} record @param {Object} action @private Should not be used directly. Store#add will call this automatically if a Writer is set @param {Object} store @param {Object} rs @param {Object} index @private Destroys a record or records. Should not be used directly. It's called by Store#remove if a Writer is set. @param {Store} this @param {Ext.data.Record/Ext.data.Record[]} @param {Number} index @private This method should generally not be used directly. This method is called internally by {@link #load}, or if a Writer is set will be called automatically when {@link #add}, {@link #remove}, or {@link #update} events fire. @param {String} action Action name ('read', 'create', 'update', or 'destroy') @param {Record/Record[]} rs @param {Object} options @throws Error @private . Should be easy now. Saves all pending changes to the store. If the commensurate Ext.data.Api.actions action is not configured, then the configured <code>{@link #url}</code> will be used. <pre>change            url
---------------   --------------------
removed records   Ext.data.Api.actions.destroy
phantom records   Ext.data.Api.actions.create
{@link #getModifiedRecords modified records}  Ext.data.Api.actions.update
</pre>@TODO: Create extensions of Error class and send associated Record with thrown exceptions. e.g.: Ext.data.DataReader.Error or Ext.data.Error or Ext.data.DataProxy.Error, etc.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='storeId'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.Record Record} constructor as supplied to (or created by) the {@link Ext.data.DataReader Reader}. Read-only. <p>If the Reader was constructed by passing in an Array of {@link Ext.data.Field} definition objects, instead of a Record constructor, it will implicitly create a Record constructor from that Array (see {@link Ext.data.Record}.{@link Ext.data.Record#create create} for additional details).</p><p>This property may be used to create new Records of the type held in this Store, for example:</p><pre><code>// create the data store
var store = new Ext.data.ArrayStore({
autoDestroy: true,
fields: [
{name: 'company'},
{name: 'price', type: 'float'},
{name: 'change', type: 'float'},
{name: 'pctChange', type: 'float'},
{name: 'lastChange', type: 'date', dateFormat: 'n/j h:ia'}
]
});
store.loadData(myData);

// create the Grid
var grid = new Ext.grid.EditorGridPanel({
store: store,
colModel: new Ext.grid.ColumnModel({
columns: [
{id:'company', header: 'Company', width: 160, dataIndex: 'company'},
{header: 'Price', renderer: 'usMoney', dataIndex: 'price'},
{header: 'Change', renderer: change, dataIndex: 'change'},
{header: '% Change', renderer: pctChange, dataIndex: 'pctChange'},
{header: 'Last Updated', width: 85,
renderer: Ext.util.Format.dateRenderer('m/d/Y'),
dataIndex: 'lastChange'}
],
defaults: {
sortable: true,
width: 75
}
}),
autoExpandColumn: 'company', // match the id specified in the column model
height:350,
width:600,
title:'Array Grid',
tbar: [{
text: 'Add Record',
handler : function(){
var defaultData = {
change: 0,
company: 'New Company',
lastChange: (new Date()).clearTime(),
pctChange: 0,
price: 10
};
var recId = 3; // provide unique id
var p = new store.recordType(defaultData, recId); // create new record
grid.stopEditing();
store.{@link #insert}(0, p); // insert a new record into the store (also see {@link #add})
grid.startEditing(0, 0);
}
}]
});
</code></pre>@property recordType @type Function A {@link Ext.util.MixedCollection MixedCollection} containing the defined {@link Ext.data.Field Field}s for the {@link Ext.data.Record Records} stored in this Store. Read-only. @property fields @type Ext.util.MixedCollection @event datachanged Fires when the data cache has changed in a bulk manner (e.g., it has been sorted, filtered, etc.) and a widget that is using this Store as a Record cache should refresh its view. @param {Store} this @event metachange Fires when this store's reader provides new metadata (fields). This is currently only supported for JsonReaders. @param {Store} this @param {Object} meta The JSON metadata @event add Fires when Records have been {@link #add}ed to the Store @param {Store} this @param {Ext.data.Record[]} records The array of Records added @param {Number} index The index at which the record(s) were added @event remove Fires when a Record has been {@link #remove}d from the Store @param {Store} this @param {Ext.data.Record} record The Record that was removed @param {Number} index The index at which the record was removed @event update Fires when a Record has been updated @param {Store} this @param {Ext.data.Record} record The Record that was updated @param {String} operation The update operation being performed. Value may be one of: <pre><code>Ext.data.Record.EDIT
Ext.data.Record.REJECT
Ext.data.Record.COMMIT
</code></pre>@event clear Fires when the data cache has been cleared. @param {Store} this @param {Record[]} The records that were cleared. @event exception <p>Fires if an exception occurs in the Proxy during a remote request. This event is relayed through the corresponding {@link Ext.data.DataProxy}. See {@link Ext.data.DataProxy}.{@link Ext.data.DataProxy#exception exception} for additional details. @param {misc} misc See {@link Ext.data.DataProxy}.{@link Ext.data.DataProxy#exception exception} for description. @event beforeload Fires before a request is made for a new data object. If the beforeload handler returns <tt>false</tt> the {@link #load} action will be canceled. @param {Store} this @param {Object} options The loading options that were specified (see {@link #load} for details) @event load Fires after a new set of Records has been loaded. @param {Store} this @param {Ext.data.Record[]} records The Records that were loaded @param {Object} options The loading options that were specified (see {@link #load} for details) @event loadexception</p><p>This event is <b>deprecated</b> in favor of the catch-all <b><code>{@link #exception}</code></b> event instead.</p><p>This event is relayed through the corresponding {@link Ext.data.DataProxy}. See {@link Ext.data.DataProxy}.{@link Ext.data.DataProxy#loadexception loadexception} for additional details. @param {misc} misc See {@link Ext.data.DataProxy}.{@link Ext.data.DataProxy#loadexception loadexception} for description. @event beforewrite @param {Ext.data.Store} store @param {String} action [Ext.data.Api.actions.create|update|destroy] @param {Record/Array[Record]} rs @param {Object} options The loading options that were specified. Edit <code>options.params</code> to add Http parameters to the request. (see {@link #save} for details) @param {Object} arg The callback's arg object passed to the {@link #request} function @event write Fires if the server returns 200 after an Ext.data.Api.actions CRUD action. Success of the action is determined in the <code>result['successProperty']</code>property (<b>NOTE</b> for RESTful stores, a simple 20x response is sufficient for the actions "destroy" and "update". The "create" action should should return 200 along with a database pk). @param {Ext.data.Store} store @param {String} action [Ext.data.Api.actions.create|update|destroy] @param {Object} result The 'data' picked-out out of the response for convenience. @param {Ext.Direct.Transaction} res @param {Record/Record[]} rs Store's records, the subject(s) of the write-action If passed, the id to use to register with the <b>{@link Ext.StoreMgr StoreMgr}</b>.</p><p><b>Note</b>: if a (deprecated) <tt>{@link #id}</tt> is specified it will supersede the <tt>storeId</tt> assignment.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='url'>
          <xs:annotation>
            <xs:documentation>
If a <tt>{@link #proxy}</tt> is not specified the <tt>url</tt> will be used to implicitly configure a {@link Ext.data.HttpProxy HttpProxy} if an <tt>url</tt> is specified. Typically this option, or the <code>{@link #data}</code> option will be specified.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoLoad'>
          <xs:annotation>
            <xs:documentation>
If <tt>{@link #data}</tt> is not specified, and if <tt>autoLoad</tt> is <tt>true</tt> or an <tt>Object</tt>, this store's {@link #load} method is automatically called after creation. If the value of <tt>autoLoad</tt> is an <tt>Object</tt>, this <tt>Object</tt> will be passed to the store's {@link #load} method.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='proxy'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.DataProxy DataProxy} object which provides access to a data object. See <code>{@link #url}</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='data'>
          <xs:annotation>
            <xs:documentation>
An inline data object readable by the <code>{@link #reader}</code>. Typically this option, or the <code>{@link #url}</code> option will be specified.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='reader'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.DataReader Reader} object which processes the data object and returns an Array of {@link Ext.data.Record} objects which are cached keyed by their <b><tt>{@link Ext.data.Record#id id}</tt></b> property.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='writer'>
          <xs:annotation>
            <xs:documentation>
<p>The {@link Ext.data.DataWriter Writer} object which processes a record object for being written to the server-side database.</p><br/><p>When a writer is installed into a Store the {@link #add}, {@link #remove}, and {@link #update} events on the store are monitored in order to remotely {@link #createRecords create records}, {@link #destroyRecord destroy records}, or {@link #updateRecord update records}.</p><br/><p>The proxy for this store will relay any {@link #writexception} events to this store.</p><br/><p>Sample implementation:</p><pre><code>var writer = new {@link Ext.data.JsonWriter}({
encode: true,
writeAllFields: true // write all fields, not just those that changed
});

// Typical Store collecting the Proxy, Reader and Writer together.
var store = new Ext.data.Store({
storeId: 'user',
root: 'records',
proxy: proxy,
reader: reader,
writer: writer,     // &lt;-- plug a DataWriter into the store just as you would a Reader
paramsAsHash: true,
autoSave: false    // &lt;-- false to delay executing create, update, destroy requests
//     until specifically told to do so.
});
</code></pre><br/><br/>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseParams'>
          <xs:annotation>
            <xs:documentation>
<p>An object containing properties which are to be sent as parameters for <i>every</i> HTTP request.</p><p>Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.</p><p><b>Note</b>: <code>baseParams</code> may be superseded by any <code>params</code> specified in a <code>{@link #load}</code> request, see <code>{@link #load}</code> for more details.</p>This property may be modified after creation using the <code>{@link #setBaseParam}</code> method. @property
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='sortInfo'>
          <xs:annotation>
            <xs:documentation>
A config object to specify the sort order in the request of a Store's {@link #load} operation. Note that for local sorting, the <tt>direction</tt> property is case-sensitive. See also {@link #remoteSort} and {@link #paramNames}. For example:<pre><code>sortInfo: {
field: 'fieldName',
direction: 'ASC' // or 'DESC' (case sensitive for local sorting)
}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='remoteSort'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> if sorting is to be handled by requesting the <tt>{@link #proxy Proxy}</tt> to provide a refreshed version of the data object in sorted order, as opposed to sorting the Record cache in place (defaults to <tt>false</tt>). <p>If <tt>remoteSort</tt> is <tt>true</tt>, then clicking on a {@link Ext.grid.Column Grid Column}'s {@link Ext.grid.Column#header header} causes the current page to be requested from the server appending the following two parameters to the <b><tt>{@link #load params}</tt></b>:</p><div class="mdetail-params"><ul><li><b><tt>sort</tt></b> : String<p class="sub-desc">The <tt>name</tt> (as specified in the Record's {@link Ext.data.Field Field definition}) of the field to sort on.</p></li><li><b><tt>dir</tt></b> : String<p class="sub-desc">The direction of the sort, 'ASC' or 'DESC' (case-sensitive).</p></li></ul></div><br/><br/>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoDestroy'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to destroy the store when the component the store is bound to is destroyed (defaults to <tt>false</tt>). <p><b>Note</b>: this should be set to true when using stores that are bound to only 1 component.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='pruneModifiedRecords'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to clear all modified record information each time the store is loaded or when a record is removed (defaults to <tt>false</tt>). See {@link #getModifiedRecords} for the accessor method to retrieve the modified records.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoSave'>
          <xs:annotation>
            <xs:documentation>
Contains the last options object used as the parameter to the {@link #load} method. See {@link #load} for the details of what this may contain. This may be useful for accessing any params which were used to load the current Record cache. @property <p>Defaults to <tt>true</tt> causing the store to automatically {@link #save} records to the server when a record is modified (ie: becomes 'dirty'). Specify <tt>false</tt> to manually call {@link #save} to send all modifiedRecords to the server.</p><br/><p><b>Note</b>: each CRUD action will be sent as a separate request.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='batch'>
          <xs:annotation>
            <xs:documentation>
<p>Defaults to <tt>true</tt> (unless <code>{@link #restful}:true</code>). Multiple requests for each CRUD action (CREATE, READ, UPDATE and DESTROY) will be combined and sent as one transaction. Only applies when <code>{@link #autoSave}</code> is set to <tt>false</tt>.</p><br/><p>If Store is RESTful, the DataProxy is also RESTful, and a unique transaction is generated for each record.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='restful'>
          <xs:annotation>
            <xs:documentation>
Defaults to <tt>false</tt>. Set to <tt>true</tt> to have the Store and the set Proxy operate in a RESTful manner. The store will automatically generate GET, POST, PUT and DELETE requests to the server. The HTTP method used for any given CRUD action is described in {@link Ext.data.Api#restActions}. For additional information see {@link Ext.data.DataProxy#restful}. <p><b>Note</b>: if <code>{@link #restful}:true</code> <code>batch</code> will internally be set to <tt>false</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='paramNames'>
          <xs:annotation>
            <xs:documentation>
<p>An object containing properties which specify the names of the paging and sorting parameters passed to remote servers when loading blocks of data. By default, this object takes the following form:</p><pre><code>{
start : 'start',  // The parameter name which specifies the start row
limit : 'limit',  // The parameter name which specifies number of rows to return
sort : 'sort',    // The parameter name which specifies the column to sort on
dir : 'dir'       // The parameter name which specifies the sort direction
}
</code></pre><p>The server must produce the requested data block upon receipt of these parameter names. If different parameter names are required, this property can be overriden using a configuration property.</p><p>A {@link Ext.PagingToolbar PagingToolbar} bound to this Store uses this property to determine the parameter names to use in its {@link #load requests}.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultParamNames'>
          <xs:annotation>
            <xs:documentation>
Provides the default values for the {@link #paramNames} property. To globally modify the parameters for all stores, this object should be changed on the store prototype.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defined'>
          <xs:annotation>
            <xs:documentation>
Destroys the store. Add Records to the Store and fires the {@link #add} event. To add Records to the store from a remote source use <code>{@link #load}({add:true})</code>. See also <code>{@link #recordType}</code> and <code>{@link #insert}</code>. @param {Ext.data.Record[]} records An Array of Ext.data.Record objects to add to the cache. See {@link #recordType}. (Local sort only) Inserts the passed Record into the Store at the index where it should go based on the current sort information. @param {Ext.data.Record} record Remove a Record from the Store and fires the {@link #remove} event. @param {Ext.data.Record} record The Ext.data.Record object to remove from the cache. Remove a Record from the Store at the specified index. Fires the {@link #remove} event. @param {Number} index The index of the record to remove. Remove all Records from the Store and fires the {@link #clear} event. Inserts Records into the Store at the given index and fires the {@link #add} event. See also <code>{@link #add}</code> and <code>{@link #addSorted}</code>. @param {Number} index The start index at which to insert the passed Records. @param {Ext.data.Record[]} records An Array of Ext.data.Record objects to add to the cache. Get the index within the cache of the passed Record. @param {Ext.data.Record} record The Ext.data.Record object to find. @return {Number} The index of the passed Record. Returns -1 if not found. Get the index within the cache of the Record with the passed id. @param {String} id The id of the Record to find. @return {Number} The index of the Record. Returns -1 if not found. Get the Record with the specified id. @param {String} id The id of the Record to find. @return {Ext.data.Record} The Record with the passed id. Returns undefined if not found. Get the Record at the specified index. @param {Number} index The index of the Record to find. @return {Ext.data.Record} The Record at the passed index. Returns undefined if not found. Returns a range of Records between specified indices. @param {Number} startIndex (optional) The starting index (defaults to 0) @param {Number} endIndex (optional) The ending index (defaults to the last Record in the Store) @return {Ext.data.Record[]} An array of Records <p>Loads the Record cache from the configured <tt>{@link #proxy}</tt> using the configured <tt>{@link #reader}</tt>.</p><br/><p>Notes:</p><div class="mdetail-params"><ul><li><b><u>Important</u></b>: loading is asynchronous! This call will return before the new data has been loaded. To perform any post-processing where information from the load call is required, specify the <tt>callback</tt> function to be called, or use a {@link Ext.util.Observable#listeners a 'load' event handler}.</li><li>If using {@link Ext.PagingToolbar remote paging}, the first load call must specify the <tt>start</tt> and <tt>limit</tt> properties in the <code>options.params</code> property to establish the initial position within the dataset, and the number of Records to cache on each read from the Proxy.</li><li>If using {@link #remoteSort remote sorting}, the configured <code>{@link #sortInfo}</code> will be automatically included with the posted parameters according to the specified <code>{@link #paramNames}</code>.</li></ul></div>@param {Object} options An object containing properties which control loading options:<ul><li><b><tt>params</tt></b> :Object<div class="sub-desc"><p>An object containing properties to pass as HTTP parameters to a remote data source. <b>Note</b>: <code>params</code> will override any <code>{@link #baseParams}</code> of the same name.</p><p>Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.</p></div></li><li><b><tt>callback</tt></b> : Function<div class="sub-desc"><p>A function to be called after the Records have been loaded. The <tt>callback</tt> is called after the load event and is passed the following arguments:</p><ul><li><tt>r</tt> : Ext.data.Record[]</li><li><tt>options</tt>: Options object from the load call</li><li><tt>success</tt>: Boolean success indicator</li></ul><br/><br/></div></li><li><b><tt>scope</tt></b> : Object<div class="sub-desc"><p>Scope with which to call the callback (defaults to the Store object)</p></div></li><li><b><tt>add</tt></b> : Boolean<div class="sub-desc"><p>Indicator to append loaded records rather than replace the current cache. <b>Note</b>: see note for <tt>{@link #loadData}</tt></p></div></li></ul>@return {Boolean} If the <i>developer</i> provided <tt>{@link #beforeload}</tt> event handler returns <tt>false</tt>, the load call will abort and will return <tt>false</tt>; otherwise will return <tt>true</tt>. updateRecord Should not be used directly. This method will be called automatically if a Writer is set. Listens to 'update' event. @param {Object} store @param {Object} record @param {Object} action @private Should not be used directly. Store#add will call this automatically if a Writer is set @param {Object} store @param {Object} rs @param {Object} index @private Destroys a record or records. Should not be used directly. It's called by Store#remove if a Writer is set. @param {Store} this @param {Ext.data.Record/Ext.data.Record[]} @param {Number} index @private This method should generally not be used directly. This method is called internally by {@link #load}, or if a Writer is set will be called automatically when {@link #add}, {@link #remove}, or {@link #update} events fire. @param {String} action Action name ('read', 'create', 'update', or 'destroy') @param {Record/Record[]} rs @param {Object} options @throws Error @private . Should be easy now. Saves all pending changes to the store. If the commensurate Ext.data.Api.actions action is not configured, then the configured <code>{@link #url}</code> will be used. <pre>change            url
---------------   --------------------
removed records   Ext.data.Api.actions.destroy
phantom records   Ext.data.Api.actions.create
{@link #getModifiedRecords modified records}  Ext.data.Api.actions.update
</pre>@TODO: Create extensions of Error class and send associated Record with thrown exceptions. e.g.: Ext.data.DataReader.Error or Ext.data.Error or Ext.data.DataProxy.Error, etc.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
  </xs:complexType>
  <xs:element name='store' type='ext:ext.data.Store'>
    <xs:annotation>
      <xs:documentation>
Registers one or more Stores with the StoreMgr. You do not normally need to register stores manually. Any store initialized with a {@link Ext.data.Store#storeId} will be auto-registered. @param {Ext.data.Store} store1 A Store instance @param {Ext.data.Store} store2 (optional) @param {Ext.data.Store} etc... (optional) Unregisters one or more Stores with the StoreMgr @param {String/Object} id1 The id of the Store, or a Store instance @param {String/Object} id2 (optional) @param {String/Object} etc... (optional) Gets a registered Store by id @param {String/Object} id The id of the Store, or a Store instance @return {Ext.data.Store} See the <code>{@link #baseParams corresponding configuration option}</code> for a description of this property. To modify this property see <code>{@link #setBaseParam}</code>. @property
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.data.ArrayStore'>
    <xs:complexContent>
      <xs:extension base='ext:ext.data.Store'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='arraystore' type='ext:ext.data.ArrayStore' substitutionGroup='ext:store'>
    <xs:annotation>
      <xs:documentation>
Create a data block containing Ext.data.Records from an Array. @param {Object} o An Array of row objects which represents the dataset. @return {Object} data A data block which is used by an Ext.data.Store object as a cache of Ext.data.Records.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.data.JsonStore'>
    <xs:complexContent>
      <xs:extension base='ext:ext.data.Store'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='jsonstore' type='ext:ext.data.JsonStore' substitutionGroup='ext:store'>
  </xs:element>
  <xs:complexType name='ext.data.XmlStore'>
    <xs:complexContent>
      <xs:extension base='ext:ext.data.Store'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='xmlstore' type='ext:ext.data.XmlStore' substitutionGroup='ext:store'>
    <xs:annotation>
      <xs:documentation>
This method is only used by a DataProxy which has retrieved data from a remote server. @param {Object} response The XHR object which contains the parsed XML document. The response is expected to contain a property called <tt>responseXML</tt> which refers to an XML document object. @return {Object} records A data block which is used by an {@link Ext.data.Store} as a cache of Ext.data.Records. Create a data block containing Ext.data.Records from an XML document. @param {Object} doc A parsed XML document. @return {Object} records A data block which is used by an {@link Ext.data.Store} as a cache of Ext.data.Records. After any data loads/reads, the raw XML Document is available for further custom processing. @type XMLDocument Decode a json response from server. @param {String} action [{@link Ext.data.Api#actions} create|read|update|destroy] @param {Ext.data.Response} response Returns an instance of {@link Ext.data.Response} build response-data extractor functions. @private @ignore Creates a function to return some particular key of data from a response. @param {String} key @return {Function} @private @ignore Extracts rows of record-data from server. iterates and calls #extractValues TODO I don't care much for method-names of #extractData, #extractValues. @param {Array} root @param {Boolean} returnRecords When true, will return instances of Ext.data.Record; otherwise just hashes. @private @ignore extracts values and type-casts a row of data from server, extracted by #extractData @param {Hash} data @param {Ext.data.Field[]} items @param {Number} len @private @ignore
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.data.GroupingStore'>
    <xs:complexContent>
      <xs:extension base='ext:ext.data.Store'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:string' name='groupField'>
          <xs:annotation>
            <xs:documentation>
The field name by which to sort the store's data (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='remoteGroup'>
          <xs:annotation>
            <xs:documentation>
True if the grouping should apply on the server side, false if it is local only (defaults to false). If the grouping is local, it can be applied immediately to the data. If it is remote, then it will simply act as a helper, automatically sending the grouping field name as the 'groupBy' param with each XHR call.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='groupOnSort'>
          <xs:annotation>
            <xs:documentation>
True to sort the data on the grouping field when a grouping operation occurs, false to sort based on the existing sort info (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='groupingstore' type='ext:ext.data.GroupingStore' substitutionGroup='ext:store'>
  </xs:element>
  <xs:complexType name='ext.data.DirectStore'>
    <xs:complexContent>
      <xs:extension base='ext:ext.data.Store'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='directstore' type='ext:ext.data.DirectStore' substitutionGroup='ext:store'>
    <xs:annotation>
      <xs:documentation>
Callback for read actions @param {String} action [Ext.data.Api.actions.create|read|update|destroy] @param {Object} trans The request transaction object @param {Object} res The server response @private Callback for write actions @param {String} action [Ext.data.Api.actions.create|read|update|destroy] @param {Object} trans The request transaction object @param {Object} res The server response @private <p>Small helper class to create an {@link Ext.data.Store} configured with an {@link Ext.data.DirectProxy} and {@link Ext.data.JsonReader} to make interacting with an {@link Ext.Direct} Server-side {@link Ext.direct.Provider Provider} easier. To create a different proxy/reader combination create a basic {@link Ext.data.Store} configured as needed.</p><p><b>*Note:</b> Although they are not listed, this class inherits all of the config options of:</p><div><ul class="mdetail-params"><li><b>{@link Ext.data.Store Store}</b></li><li><b>{@link Ext.data.JsonReader JsonReader}</b></li><li style="list-style: none"><div class="sub-desc"><ul class="mdetail-params"><li><tt><b>{@link Ext.data.JsonReader#root root}</b></tt></li><li><tt><b>{@link Ext.data.JsonReader#idProperty idProperty}</b></tt></li><li><tt><b>{@link Ext.data.JsonReader#totalProperty totalProperty}</b></tt></li></ul></div></li><li><b>{@link Ext.data.DirectProxy DirectProxy}</b></li><li style="list-style: none"><div class="sub-desc"><ul class="mdetail-params"><li><tt><b>{@link Ext.data.DirectProxy#directFn directFn}</b></tt></li><li><tt><b>{@link Ext.data.DirectProxy#paramOrder paramOrder}</b></tt></li><li><tt><b>{@link Ext.data.DirectProxy#paramsAsHash paramsAsHash}</b></tt></li></ul></div></li></ul></div>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Window'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:all>
            <xs:element name='animateTarget' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Id or element from which the window should animate while opening (defaults to null with no animation).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='manager' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A reference to the WindowGroup that should manage this window (defaults to {@link Ext.WindowMgr}).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='defaultButton' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The id / index of a button or a button instance to focus when this window received the focus.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='onEsc' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Allows override of the built-in processing for the escape key. Default action is to close the Window (performing whatever action is specified in {@link #closeAction}. To prevent the Window closing when the escape key is pressed, specify this as Ext.emptyFn (See {@link Ext#emptyFn}).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:boolean' name='modal'>
          <xs:annotation>
            <xs:documentation>
True to make the window modal and mask everything behind it when displayed, false to display it without restricting access to other UI elements (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='animateTarget'>
          <xs:annotation>
            <xs:documentation>
Id or element from which the window should animate while opening (defaults to null with no animation).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='resizeHandles'>
          <xs:annotation>
            <xs:documentation>
A valid {@link Ext.Resizable} handles config string (defaults to 'all'). Only applies when resizable = true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='manager'>
          <xs:annotation>
            <xs:documentation>
A reference to the WindowGroup that should manage this window (defaults to {@link Ext.WindowMgr}).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultButton'>
          <xs:annotation>
            <xs:documentation>
The id / index of a button or a button instance to focus when this window received the focus.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='onEsc'>
          <xs:annotation>
            <xs:documentation>
Allows override of the built-in processing for the escape key. Default action is to close the Window (performing whatever action is specified in {@link #closeAction}. To prevent the Window closing when the escape key is pressed, specify this as Ext.emptyFn (See {@link Ext#emptyFn}).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='maximized'>
          <xs:annotation>
            <xs:documentation>
True to initially display the window in a maximized state. (Defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='resizable'>
          <xs:annotation>
            <xs:documentation>
True to allow user resizing at each edge and corner of the window, false to disable resizing (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='closeAction'>
          <xs:annotation>
            <xs:documentation>
<p>The action to take when the close header tool is clicked:</p><div class="mdetail-params"><ul><li><b><code>'{@link #close}'</code></b> : <b>Default</b><div class="sub-desc">{@link #close remove} the window from the DOM and {@link Ext.Component#destroy destroy} it and all descendant Components. The window will <b>not</b> be available to be redisplayed via the {@link #show} method.</div></li><li><b><code>'{@link #hide}'</code></b> : <div class="sub-desc">{@link #hide} the window by setting visibility to hidden and applying negative offsets. The window will be available to be redisplayed via the {@link #show} method.</div></li></ul></div><p><b>Note:</b> This setting does not affect the {@link #close} method which will always {@link Ext.Component#destroy destroy} the window. To programatically <i>hide</i> a window, call {@link #hide}.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='constrain'>
          <xs:annotation>
            <xs:documentation>
True to constrain the window within its containing element, false to allow it to fall outside of its containing element. By default the window will be rendered to document.body. To render and constrain the window within another element specify {@link #renderTo}. (defaults to false). Optionally the header only can be constrained using {@link #constrainHeader}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='constrainHeader'>
          <xs:annotation>
            <xs:documentation>
True to constrain the window header within its containing element (allowing the window body to fall outside of its containing element) or false to allow the header to fall outside its containing element (defaults to false). Optionally the entire window can be constrained using {@link #constrain}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='plain'>
          <xs:annotation>
            <xs:documentation>
True to render the window body with a transparent background so that it will blend into the framing elements, false to add a lighter background color to visually highlight the body element and separate it more distinctly from the surrounding frame (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='minimizable'>
          <xs:annotation>
            <xs:documentation>
True to display the 'minimize' tool button and allow the user to minimize the window, false to hide the button and disallow minimizing the window (defaults to false). Note that this button provides no implementation -- the behavior of minimizing a window is implementation-specific, so the minimize event must be handled and a custom minimize behavior implemented for this option to be useful.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='maximizable'>
          <xs:annotation>
            <xs:documentation>
True to display the 'maximize' tool button and allow the user to maximize the window, false to hide the button and disallow maximizing the window (defaults to false). Note that when a window is maximized, the tool button will automatically change to a 'restore' button with the appropriate behavior already built-in that will restore the window to its previous size.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minHeight'>
          <xs:annotation>
            <xs:documentation>
The minimum height in pixels allowed for this window (defaults to 100). Only applies when resizable = true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width in pixels allowed for this window (defaults to 200). Only applies when resizable = true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='expandOnShow'>
          <xs:annotation>
            <xs:documentation>
True to always expand the window when it is displayed, false to keep it in its current state (which may be {@link #collapsed}) when displayed (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='initHidden'>
          <xs:annotation>
            <xs:documentation>
True to hide the window until show() is explicitly called (defaults to true). @deprecated
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='window' type='ext:ext.Window' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
Perform a manual resize and fires the 'resize' event. @param {Number} width @param {Number} height <p>Performs resizing of the associated Element. This method is called internally by this class, and should not be called by user code.</p><p>If a Resizable is being used to resize an Element which encapsulates a more complex UI component such as a Panel, this method may be overridden by specifying an implementation as a config option to provide appropriate behaviour at the end of the resize operation on mouseup, for example resizing the Panel, and relaying the Panel's content.</p><p>The new area to be resized to is available by examining the state of the {@link #proxy} Element. Example:</p><pre><code>new Ext.Panel({
title: 'Resize me',
x: 100,
y: 100,
renderTo: Ext.getBody(),
floating: true,
frame: true,
width: 400,
height: 200,
listeners: {
render: function(p) {
new Ext.Resizable(p.getEl(), {
handles: 'all',
pinned: true,
transparent: true,
resizeElement: function() {
var box = this.proxy.getBox();
p.updateBox(box);
if (p.layout) {
p.doLayout();
}
return box;
}
});
}
}
}).show();
</code></pre>Returns the element this component is bound to. @return {Ext.Element} Returns the resizeChild element (or null). @return {Ext.Element} Destroys this resizable. If the element was wrapped and removeEl is not true then the element remains. @param {Boolean} removeEl (optional) true to remove the element from the DOM <p>A specialized panel intended for use as an application window. Windows are floated, {@link #resizable}, and {@link #draggable} by default. Windows can be {@link #maximizable maximized} to fill the viewport, restored to their prior size, and can be {@link #minimize}d.</p><p>Windows can also be linked to a {@link Ext.WindowGroup} or managed by the {@link Ext.WindowMgr} to provide grouping, activation, to front, to back and other application-specific behavior.</p><p>By default, Windows will be rendered to document.body. To {@link #constrain} a Window to another element specify {@link Ext.Component#renderTo renderTo}.</p><p><b>Note:</b> By default, the <code>{@link #closable close}</code> header tool <i>destroys</i> the Window resulting in destruction of any child Components. This makes the Window object, and all its descendants <b>unusable</b>. To enable re-use of a Window, use <b><code>{@link #closeAction closeAction: 'hide'}</code></b>.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.DataView'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:all>
            <xs:element name='tpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The HTML fragment or an array of fragments that will make up the template used by this DataView. This should be specified in the same format expected by the constructor of {@link Ext.XTemplate}.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.Store} to bind this DataView to.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='tpl'>
          <xs:annotation>
            <xs:documentation>
The HTML fragment or an array of fragments that will make up the template used by this DataView. This should be specified in the same format expected by the constructor of {@link Ext.XTemplate}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.Store} to bind this DataView to.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemSelector'>
          <xs:annotation>
            <xs:documentation>
<b>This is a required setting</b>. A simple CSS selector (e.g. <tt>div.some-class</tt> or <tt>span:first-child</tt>) that will be used to determine what nodes this DataView will be working with.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='multiSelect'>
          <xs:annotation>
            <xs:documentation>
True to allow selection of more than one item at a time, false to allow selection of only a single item at a time or no selection at all, depending on the value of {@link #singleSelect} (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='singleSelect'>
          <xs:annotation>
            <xs:documentation>
True to allow selection of exactly one item at a time, false to allow no selection at all (defaults to false). Note that if {@link #multiSelect} = true, this value will be ignored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='simpleSelect'>
          <xs:annotation>
            <xs:documentation>
True to enable multiselection by clicking on multiple items without requiring the user to hold Shift or Ctrl, false to force the user to hold Ctrl or Shift to select more than on item (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='overClass'>
          <xs:annotation>
            <xs:documentation>
A CSS class to apply to each item in the view on mouseover (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loadingText'>
          <xs:annotation>
            <xs:documentation>
A string to display during data load operations (defaults to undefined). If specified, this text will be displayed in a loading div and the view's contents will be cleared while loading, otherwise the view's contents will continue to display normally until the new data is loaded and the contents are replaced.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selectedClass'>
          <xs:annotation>
            <xs:documentation>
A CSS class to apply to each selected item in the view (defaults to 'x-view-selected').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyText'>
          <xs:annotation>
            <xs:documentation>
The text to display in the view when there is no data to display (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='deferEmptyText'>
          <xs:annotation>
            <xs:documentation>
True to defer emptyText being applied until the store's first load
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackOver'>
          <xs:annotation>
            <xs:documentation>
True to enable mouseenter and mouseleave events
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='dataview' type='ext:ext.DataView' substitutionGroup='ext:box'>
  </xs:element>
  <xs:complexType name='ext.ListView'>
    <xs:complexContent>
      <xs:extension base='ext:ext.DataView'>
        <xs:all>
            <xs:element name='columnResize' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Specify <tt>true</tt> or specify a configuration object for {@link Ext.ListView.ColumnResizer} to enable the columns to be resizable (defaults to <tt>true</tt>).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='columns' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of column configuration objects, for example: <pre><code>{
align: 'right',
dataIndex: 'size',
header: 'Size',
tpl: '{size:fileSize}',
width: .35
}
</code></pre>Acceptable properties for each column configuration object are: <div class="mdetail-params"><ul><li><b><tt>align</tt></b> : String<div class="sub-desc">Set the CSS text-align property of the column. Defaults to <tt>'left'</tt>.</div></li><li><b><tt>dataIndex</tt></b> : String<div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#dataIndex dataIndex} for details.</div></li><li><b><tt>header</tt></b> : String<div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#header header} for details.</div></li><li><b><tt>tpl</tt></b> : String<div class="sub-desc">Specify a string to pass as the configuration string for {@link Ext.XTemplate}. By default an {@link Ext.XTemplate} will be implicitly created using the <tt>dataIndex</tt>.</div></li><li><b><tt>width</tt></b> : Number<div class="sub-desc">Percentage of the container width this column should be allocated. Columns that have no width specified will be allocated with an equal percentage to fill 100% of the container width. To easily take advantage of the full container width, leave the width of at least one column undefined. Note that if you do not want to take up the full width of the container, the width of every column needs to be explicitly defined.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='columnSort' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Specify <tt>true</tt> or specify a configuration object for {@link Ext.ListView.Sorter} to enable the columns to be sortable (defaults to <tt>true</tt>).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='internalTpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The template to be used for the header row. See {@link #tpl} for more details.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:boolean' name='hideHeaders'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to hide the {@link #internalTpl header row} (defaults to <tt>false</tt> so the {@link #internalTpl header row} will be shown).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='reserveScrollOffset'>
          <xs:annotation>
            <xs:documentation>
By default will defer accounting for the configured <b><tt>{@link #scrollOffset}</tt></b> for 10 milliseconds. Specify <tt>true</tt> to account for the configured <b><tt>{@link #scrollOffset}</tt></b> immediately.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollOffset'>
          <xs:annotation>
            <xs:documentation>
The amount of space to reserve for the scrollbar (defaults to <tt>undefined</tt>). If an explicit value isn't specified, this will be automatically calculated.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columnResize'>
          <xs:annotation>
            <xs:documentation>
Specify <tt>true</tt> or specify a configuration object for {@link Ext.ListView.ColumnResizer} to enable the columns to be resizable (defaults to <tt>true</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columns'>
          <xs:annotation>
            <xs:documentation>
An array of column configuration objects, for example: <pre><code>{
align: 'right',
dataIndex: 'size',
header: 'Size',
tpl: '{size:fileSize}',
width: .35
}
</code></pre>Acceptable properties for each column configuration object are: <div class="mdetail-params"><ul><li><b><tt>align</tt></b> : String<div class="sub-desc">Set the CSS text-align property of the column. Defaults to <tt>'left'</tt>.</div></li><li><b><tt>dataIndex</tt></b> : String<div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#dataIndex dataIndex} for details.</div></li><li><b><tt>header</tt></b> : String<div class="sub-desc">See {@link Ext.grid.Column}. {@link Ext.grid.Column#header header} for details.</div></li><li><b><tt>tpl</tt></b> : String<div class="sub-desc">Specify a string to pass as the configuration string for {@link Ext.XTemplate}. By default an {@link Ext.XTemplate} will be implicitly created using the <tt>dataIndex</tt>.</div></li><li><b><tt>width</tt></b> : Number<div class="sub-desc">Percentage of the container width this column should be allocated. Columns that have no width specified will be allocated with an equal percentage to fill 100% of the container width. To easily take advantage of the full container width, leave the width of at least one column undefined. Note that if you do not want to take up the full width of the container, the width of every column needs to be explicitly defined.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columnSort'>
          <xs:annotation>
            <xs:documentation>
Specify <tt>true</tt> or specify a configuration object for {@link Ext.ListView.Sorter} to enable the columns to be sortable (defaults to <tt>true</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='internalTpl'>
          <xs:annotation>
            <xs:documentation>
The template to be used for the header row. See {@link #tpl} for more details.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='listview' type='ext:ext.ListView' substitutionGroup='ext:dataview'>
    <xs:annotation>
      <xs:documentation>
@event beforeclick Fires before a click is processed. Returns false to cancel the default action. @param {Ext.DataView} this @param {Number} index The index of the target node @param {HTMLElement} node The target node @param {Ext.EventObject} e The raw event object @event click Fires when a template node is clicked. @param {Ext.DataView} this @param {Number} index The index of the target node @param {HTMLElement} node The target node @param {Ext.EventObject} e The raw event object @event mouseenter Fires when the mouse enters a template node. trackOver:true or an overCls must be set to enable this event. @param {Ext.DataView} this @param {Number} index The index of the target node @param {HTMLElement} node The target node @param {Ext.EventObject} e The raw event object @event mouseleave Fires when the mouse leaves a template node. trackOver:true or an overCls must be set to enable this event. @param {Ext.DataView} this @param {Number} index The index of the target node @param {HTMLElement} node The target node @param {Ext.EventObject} e The raw event object @event containerclick Fires when a click occurs and it is not on a template node. @param {Ext.DataView} this @param {Ext.EventObject} e The raw event object @event dblclick Fires when a template node is double clicked. @param {Ext.DataView} this @param {Number} index The index of the target node @param {HTMLElement} node The target node @param {Ext.EventObject} e The raw event object @event contextmenu Fires when a template node is right clicked. @param {Ext.DataView} this @param {Number} index The index of the target node @param {HTMLElement} node The target node @param {Ext.EventObject} e The raw event object @event containercontextmenu Fires when a right click occurs that is not on a template node. @param {Ext.DataView} this @param {Ext.EventObject} e The raw event object @event selectionchange Fires when the selected nodes change. @param {Ext.DataView} this @param {Array} selections Array of the selected nodes @event beforeselect Fires before a selection is made. If any handlers return false, the selection is cancelled. @param {Ext.DataView} this @param {HTMLElement} node The node to be selected @param {Array} selections Array of currently selected nodes Refreshes the view by reloading the data from the store and re-rendering the template. Function which can be overridden to provide custom formatting for each Record that is used by this DataView's {@link #tpl template} to render each node. @param {Array/Object} data The raw data object that was used to create the Record. @param {Number} recordIndex the index number of the Record being prepared for rendering. @param {Record} record The Record being prepared for rendering. @return {Array/Object} The formatted data in a format expected by the internal {@link #tpl template}'s overwrite() method. (either an array if your params are numeric (i.e. {0}) or an object (i.e. {foo: 'bar'})) <p>Function which can be overridden which returns the data object passed to this DataView's {@link #tpl template} to render the whole DataView.</p><p>This is usually an Array of data objects, each element of which is processed by an {@link Ext.XTemplate XTemplate} which uses <tt>'&lt;tpl for="."&gt;'</tt> to iterate over its supplied data object as an Array. However, <i>named</i> properties may be placed into the data object to provide non-repeating data such as headings, totals etc.</p>@param {Array} records An Array of {@link Ext.data.Record}s to be rendered into the DataView. @param {Number} startIndex the index number of the Record being prepared for rendering. @return {Array} An Array of data objects to be processed by a repeating XTemplate. May also contain <i>named</i> properties. Refreshes an individual node's data from the store. @param {Number} index The item's data index in the store Returns the store associated with this DataView. @return {Ext.data.Store} The store Changes the data store bound to this view and refreshes it. @param {Store} store The store to bind to this view Returns the template node the passed child belongs to, or null if it doesn't belong to one. @param {HTMLElement} node @return {HTMLElement} The template node Gets the number of selected nodes. @return {Number} The node count Gets the currently selected nodes. @return {Array} An array of HTMLElements Gets the indexes of the selected nodes. @return {Array} An array of numeric indexes Gets an array of the selected records @return {Array} An array of {@link Ext.data.Record} objects Gets an array of the records from an array of nodes @param {Array} nodes The nodes to evaluate @return {Array} records The {@link Ext.data.Record} objects Gets a record from a node @param {HTMLElement} node The node to evaluate @return {Record} record The {@link Ext.data.Record} object Clears all selections. @param {Boolean} suppressEvent (optional) True to skip firing of the selectionchange event Returns true if the passed node is selected, else false. @param {HTMLElement/Number} node The node or node index to check @return {Boolean} True if selected, else false Deselects a node. @param {HTMLElement/Number} node The node to deselect Selects a set of nodes. @param {Array/HTMLElement/String/Number} nodeInfo An HTMLElement template node, index of a template node, id of a template node or an array of any of those to select @param {Boolean} keepExisting (optional) true to keep existing selections @param {Boolean} suppressEvent (optional) true to skip firing of the selectionchange vent Selects a range of nodes. All nodes between start and end are selected. @param {Number} start The index of the first node in the range @param {Number} end The index of the last node in the range @param {Boolean} keepExisting (optional) True to retain existing selections Gets a template node. @param {HTMLElement/String/Number} nodeInfo An HTMLElement template node, index of a template node or the id of a template node @return {HTMLElement} The node or null if it wasn't found Gets a range nodes. @param {Number} start (optional) The index of the first node in the range @param {Number} end (optional) The index of the last node in the range @return {Array} An array of nodes Finds the index of the passed node. @param {HTMLElement/String/Number} nodeInfo An HTMLElement template node, index of a template node or the id of a template node @return {Number} The index of the node or -1 Changes the data store bound to this view and refreshes it. (deprecated in favor of bindStore) @param {Store} store The store to bind to this view Set this property to <tt>true</tt> to disable the header click handler disabling sort (defaults to <tt>false</tt>). @type Boolean @property disableHeaders
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.TabPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:all>
            <xs:element name='itemTpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>(Optional) A {@link Ext.Template Template} or {@link Ext.XTemplate XTemplate} which may be provided to process the data object returned from <tt>{@link #getTemplateArgs}</tt> to produce a clickable selector element in the tab strip.</p><p>The main element created should be a <tt>&lt;li&gt;</tt> element. In order for a click event on a selector element to be connected to its item, it must take its <i>id</i> from the TabPanel's native <tt>{@link #getTemplateArgs}</tt>.</p><p>The child element which contains the title text must be marked by the CSS class <tt>x-tab-strip-inner</tt>.</p><p>To enable closability, the created element should contain an element marked by the CSS class <tt>x-tab-strip-close</tt>.</p><p>If a custom <tt>itemTpl</tt> is supplied, it is the developer's responsibility to create CSS style rules to create the desired appearance.</p>Below is an example of how to create customized tab selector items:<pre><code>new Ext.TabPanel({
renderTo: document.body,
minTabWidth: 115,
tabWidth: 135,
enableTabScroll: true,
width: 600,
height: 250,
defaults: {autoScroll:true},
itemTpl: new Ext.XTemplate(
'&lt;li class="{cls}" id="{id}" style="overflow:hidden"&gt;',
'&lt;tpl if="closable"&gt;',
'&lt;a class="x-tab-strip-close" onclick="return false;"&gt;&lt;/a&gt;',
'&lt;/tpl&gt;',
'&lt;a class="x-tab-right" href="#" onclick="return false;" style="padding-left:6px"&gt;',
'&lt;em class="x-tab-left"&gt;',
'&lt;span class="x-tab-strip-inner"&gt;',
'&lt;img src="{src}" style="float:left;margin:3px 3px 0 0"&gt;',
'&lt;span style="margin-left:20px" class="x-tab-strip-text {iconCls}"&gt;{text} {extra}&lt;/span&gt;',
'&lt;/span&gt;',
'&lt;/em&gt;',
'&lt;/a&gt;',
'&lt;/li&gt;'
),
getTemplateArgs: function(item) {
//      Call the native method to collect the base data. Like the ID!
var result = Ext.TabPanel.prototype.getTemplateArgs.call(this, item);

//      Add stuff used in our template
return Ext.apply(result, {
closable: item.closable,
src: item.iconSrc,
extra: item.extraText || ''
});
},
items: [{
title: 'New Tab 1',
iconSrc: '../shared/icons/fam/grid.png',
html: 'Tab Body 1',
closable: true
}, {
title: 'New Tab 2',
iconSrc: '../shared/icons/fam/grid.png',
html: 'Tab Body 2',
extraText: 'Extra stuff in the tab button'
}]
});
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:boolean' name='layoutOnTabChange'>
          <xs:annotation>
            <xs:documentation>
Set to true to force a layout of the active tab when the tab is changed. Defaults to false. See {@link Ext.layout.CardLayout}.<code>{@link Ext.layout.CardLayout#layoutOnCardChange layoutOnCardChange}</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tabCls'>
          <xs:annotation>
            <xs:documentation>
<b>This config option is used on <u>child Components</u> of ths TabPanel.</b> A CSS class name applied to the tab strip item representing the child Component, allowing special styling to be applied.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='deferredRender'>
          <xs:annotation>
            <xs:documentation>
<p><tt>true</tt> by default to defer the rendering of child <tt>{@link Ext.Container#items items}</tt> to the browsers DOM until a tab is activated. <tt>false</tt> will render all contained <tt>{@link Ext.Container#items items}</tt> as soon as the {@link Ext.layout.CardLayout layout} is rendered. If there is a significant amount of content or a lot of heavy controls being rendered into panels that are not displayed by default, setting this to <tt>true</tt> might improve performance.</p><br/><p>The <tt>deferredRender</tt> property is internally passed to the layout manager for TabPanels ({@link Ext.layout.CardLayout}) as its {@link Ext.layout.CardLayout#deferredRender} configuration value.</p><br/><p><b>Note</b>: leaving <tt>deferredRender</tt> as <tt>true</tt> means that the content within an unactivated tab will not be available. For example, this means that if the TabPanel is within a {@link Ext.form.FormPanel form}, then until a tab is activated, any Fields within unactivated tabs will not be rendered, and will therefore not be submitted and will not be available to either {@link Ext.form.BasicForm#getValues getValues} or {@link Ext.form.BasicForm#setValues setValues}.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabWidth'>
          <xs:annotation>
            <xs:documentation>
The initial width in pixels of each new tab (defaults to 120).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minTabWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width in pixels for each tab when {@link #resizeTabs} = true (defaults to 30).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='resizeTabs'>
          <xs:annotation>
            <xs:documentation>
True to automatically resize each tab so that the tabs will completely fill the tab strip (defaults to false). Setting this to true may cause specific widths that might be set per tab to be overridden in order to fit them all into view (although {@link #minTabWidth} will always be honored).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableTabScroll'>
          <xs:annotation>
            <xs:documentation>
True to enable scrolling to tabs that may be invisible due to overflowing the overall TabPanel width. Only available with tabPosition:'top' (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollIncrement'>
          <xs:annotation>
            <xs:documentation>
The number of pixels to scroll each time a tab scroll button is pressed (defaults to <tt>100</tt>, or if <tt>{@link #resizeTabs} = true</tt>, the calculated tab width). Only applies when <tt>{@link #enableTabScroll} = true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollRepeatInterval'>
          <xs:annotation>
            <xs:documentation>
Number of milliseconds between each scroll while a tab scroll button is continuously pressed (defaults to <tt>400</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:float' name='scrollDuration'>
          <xs:annotation>
            <xs:documentation>
The number of milliseconds that each scroll animation should last (defaults to <tt>.35</tt>). Only applies when <tt>{@link #animScroll} = true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animScroll'>
          <xs:annotation>
            <xs:documentation>
True to animate tab scrolling so that hidden tabs slide smoothly into view (defaults to <tt>true</tt>). Only applies when <tt>{@link #enableTabScroll} = true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tabPosition'>
          <xs:annotation>
            <xs:documentation>
The position where the tab strip should be rendered (defaults to <tt>'top'</tt>). The only other supported value is <tt>'bottom'</tt>. <b>Note</b>: tab scrolling is only supported for <tt>tabPosition: 'top'</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoTabs'>
          <xs:annotation>
            <xs:documentation>
<p><tt>true</tt> to query the DOM for any divs with a class of 'x-tab' to be automatically converted to tabs and added to this panel (defaults to <tt>false</tt>). Note that the query will be executed within the scope of the container element only (so that multiple tab panels from markup can be supported via this method).</p><p>This method is only possible when the markup is structured correctly as a container with nested divs containing the class <tt>'x-tab'</tt>. To create TabPanels without these limitations, or to pull tab content from other elements on the page, see the example at the top of the class for generating tabs from markup.</p><p>There are a couple of things to note when using this method:</p><ul><li>When using the <tt>autoTabs</tt> config (as opposed to passing individual tab configs in the TabPanel's {@link #items} collection), you must use <tt>{@link #applyTo}</tt> to correctly use the specified <tt>id</tt> as the tab container. The <tt>autoTabs</tt> method <em>replaces</em> existing content with the TabPanel components.</li><li>Make sure that you set <tt>{@link #deferredRender}: false</tt> so that the content elements for each tab will be rendered into the TabPanel immediately upon page load, otherwise they will not be transformed until each tab is activated and will be visible outside the TabPanel.</li></ul>Example usage:<br/><br/> <pre><code>var tabs = new Ext.TabPanel({
applyTo: 'my-tabs',
activeTab: 0,
deferredRender: false,
autoTabs: true
});

// This markup will be converted to a TabPanel from the code above
&lt;div id="my-tabs"&gt;
&lt;div class="x-tab" title="Tab 1"&gt;A simple tab&lt;/div&gt;
&lt;div class="x-tab" title="Tab 2"&gt;Another one&lt;/div&gt;
&lt;/div&gt;
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoTabSelector'>
          <xs:annotation>
            <xs:documentation>
The CSS selector used to search for tabs in existing markup when <tt>{@link #autoTabs} = true</tt> (defaults to <tt>'div.x-tab'</tt>). This can be any valid selector supported by {@link Ext.DomQuery#select}. Note that the query will be executed within the scope of this tab panel only (so that multiple tab panels from markup can be supported on a page).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='activeTab'>
          <xs:annotation>
            <xs:documentation>
A string id or the numeric index of the tab that should be initially activated on render (defaults to none).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabMargin'>
          <xs:annotation>
            <xs:documentation>
The number of pixels of space to calculate into the sizing and scrolling of tabs. If you change the margin in CSS, you will need to update this value so calculations are correct with either <tt>{@link #resizeTabs}</tt> or scrolling tabs. (defaults to <tt>2</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='plain'>
          <xs:annotation>
            <xs:documentation>
true to render the tab strip without a background container image (defaults to <tt>false</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='wheelIncrement'>
          <xs:annotation>
            <xs:documentation>
For scrolling tabs, the number of pixels to increment on mouse wheel scrolling (defaults to <tt>20</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemTpl'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) A {@link Ext.Template Template} or {@link Ext.XTemplate XTemplate} which may be provided to process the data object returned from <tt>{@link #getTemplateArgs}</tt> to produce a clickable selector element in the tab strip.</p><p>The main element created should be a <tt>&lt;li&gt;</tt> element. In order for a click event on a selector element to be connected to its item, it must take its <i>id</i> from the TabPanel's native <tt>{@link #getTemplateArgs}</tt>.</p><p>The child element which contains the title text must be marked by the CSS class <tt>x-tab-strip-inner</tt>.</p><p>To enable closability, the created element should contain an element marked by the CSS class <tt>x-tab-strip-close</tt>.</p><p>If a custom <tt>itemTpl</tt> is supplied, it is the developer's responsibility to create CSS style rules to create the desired appearance.</p>Below is an example of how to create customized tab selector items:<pre><code>new Ext.TabPanel({
renderTo: document.body,
minTabWidth: 115,
tabWidth: 135,
enableTabScroll: true,
width: 600,
height: 250,
defaults: {autoScroll:true},
itemTpl: new Ext.XTemplate(
'&lt;li class="{cls}" id="{id}" style="overflow:hidden"&gt;',
'&lt;tpl if="closable"&gt;',
'&lt;a class="x-tab-strip-close" onclick="return false;"&gt;&lt;/a&gt;',
'&lt;/tpl&gt;',
'&lt;a class="x-tab-right" href="#" onclick="return false;" style="padding-left:6px"&gt;',
'&lt;em class="x-tab-left"&gt;',
'&lt;span class="x-tab-strip-inner"&gt;',
'&lt;img src="{src}" style="float:left;margin:3px 3px 0 0"&gt;',
'&lt;span style="margin-left:20px" class="x-tab-strip-text {iconCls}"&gt;{text} {extra}&lt;/span&gt;',
'&lt;/span&gt;',
'&lt;/em&gt;',
'&lt;/a&gt;',
'&lt;/li&gt;'
),
getTemplateArgs: function(item) {
//      Call the native method to collect the base data. Like the ID!
var result = Ext.TabPanel.prototype.getTemplateArgs.call(this, item);

//      Add stuff used in our template
return Ext.apply(result, {
closable: item.closable,
src: item.iconSrc,
extra: item.extraText || ''
});
},
items: [{
title: 'New Tab 1',
iconSrc: '../shared/icons/fam/grid.png',
html: 'Tab Body 1',
closable: true
}, {
title: 'New Tab 2',
iconSrc: '../shared/icons/fam/grid.png',
html: 'Tab Body 2',
extraText: 'Extra stuff in the tab button'
}]
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tabpanel' type='ext:ext.TabPanel' substitutionGroup='ext:panel'>
  </xs:element>
  <xs:complexType name='ext.Button'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:all>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function called when the button is clicked (can be used instead of click event). The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>b</code> : Button<div class="sub-desc">This Button.</div></li><li><code>e</code> : EventObject<div class="sub-desc">The click event.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='tooltip' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config object
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='repeat' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    True to repeat fire the click event while the mouse is down. This can also be a {@link Ext.util.ClickRepeater ClickRepeater} config object (defaults to false).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='toggleHandler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Function called when a Button with {@link #enableToggle} set to true is clicked. Two arguments are passed:<ul class="mdetail-params"><li><b>button</b> : Ext.Button<div class="sub-desc">this Button object</div></li><li><b>state</b> : Boolean<div class="sub-desc">The next state if the Button, true means pressed.</div></li></ul>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='menu' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to undefined).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> and <code>{@link #toggleHandler}</code> is executed. Defaults to this Button.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='template' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    (Optional) <p>A {@link Ext.Template Template} used to create the Button's DOM structure.</p>Instances, or subclasses which need a different DOM structure may provide a different template layout in conjunction with an implementation of {@link #getTemplateArgs}. @type Ext.Template @property template
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The button text to be used as innerHTML (html tags are accepted)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='icon'>
          <xs:annotation>
            <xs:documentation>
The path to an image to display in the button (the image will be set as the background-image CSS property of the button by default, so if you want a mixed icon/text button, set cls:'x-btn-text-icon')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
A function called when the button is clicked (can be used instead of click event). The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>b</code> : Button<div class="sub-desc">This Button.</div></li><li><code>e</code> : EventObject<div class="sub-desc">The click event.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width for this button (used to give a set of buttons a common width). See also {@link Ext.Panel}.<tt>{@link Ext.Panel#minButtonWidth minButtonWidth}</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tooltip'>
          <xs:annotation>
            <xs:documentation>
The tooltip for the button - can be a string to be used as innerHTML (html tags are accepted) or QuickTips config object
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='pressed'>
          <xs:annotation>
            <xs:documentation>
True to start pressed (only if enableToggle = true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='toggleGroup'>
          <xs:annotation>
            <xs:documentation>
The group this toggle button is a member of (only 1 per group can be pressed)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='repeat'>
          <xs:annotation>
            <xs:documentation>
True to repeat fire the click event while the mouse is down. This can also be a {@link Ext.util.ClickRepeater ClickRepeater} config object (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabIndex'>
          <xs:annotation>
            <xs:documentation>
Read-only. True if this button is hidden @type Boolean Read-only. True if this button is disabled @type Boolean Read-only. True if this button is pressed (only if enableToggle = true) @type Boolean Set a DOM tabIndex for this button (defaults to undefined)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowDepress'>
          <xs:annotation>
            <xs:documentation>
False to not allow a pressed Button to be depressed (defaults to undefined). Only valid when {@link #enableToggle} is true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableToggle'>
          <xs:annotation>
            <xs:documentation>
True to enable pressed/not pressed toggling (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='toggleHandler'>
          <xs:annotation>
            <xs:documentation>
Function called when a Button with {@link #enableToggle} set to true is clicked. Two arguments are passed:<ul class="mdetail-params"><li><b>button</b> : Ext.Button<div class="sub-desc">this Button object</div></li><li><b>state</b> : Boolean<div class="sub-desc">The next state if the Button, true means pressed.</div></li></ul>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='menu'>
          <xs:annotation>
            <xs:documentation>
Standard menu attribute consisting of a reference to a menu object, a menu id or a menu config blob (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='menuAlign'>
          <xs:annotation>
            <xs:documentation>
The position to align the menu to (see {@link Ext.Element#alignTo} for more details, defaults to 'tl-bl?').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='overflowText'>
          <xs:annotation>
            <xs:documentation>
If used in a {@link Ext.Toolbar Toolbar}, the text to be used if this item is shown in the overflow menu. See also {@link Ext.Toolbar.Item}.<code>{@link Ext.Toolbar.Item#overflowText overflowText}</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconCls'>
          <xs:annotation>
            <xs:documentation>
A css class which sets a background image to be used as the icon for this button
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='type'>
          <xs:annotation>
            <xs:documentation>
submit, reset or button - defaults to 'button'
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='clickEvent'>
          <xs:annotation>
            <xs:documentation>
The DOM event that will fire the handler of the button. This can be any valid event name (dblclick, contextmenu). Defaults to <tt>'click'</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='handleMouseEvents'>
          <xs:annotation>
            <xs:documentation>
False to disable visual cues on mouseover, mouseout and mousedown (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tooltipType'>
          <xs:annotation>
            <xs:documentation>
The type of tooltip to use. Either 'qtip' (default) for QuickTips or 'title' for title attribute.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='buttonSelector'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) A {@link Ext.DomQuery DomQuery} selector which is used to extract the active, clickable element from the DOM structure created.</p><p>When a custom {@link #template} is used, you must ensure that this selector results in the selection of a focussable element.</p><p>Defaults to <b><tt>'button:first-child'</tt></b>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scale'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) The size of the Button. Three values are allowed:</p><ul class="mdetail-params"><li>'small'<div class="sub-desc">Results in the button element being 16px high.</div></li><li>'medium'<div class="sub-desc">Results in the button element being 24px high.</div></li><li>'large'<div class="sub-desc">Results in the button element being 32px high.</div></li></ul><p>Defaults to <b><tt>'small'</tt></b>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> and <code>{@link #toggleHandler}</code> is executed. Defaults to this Button.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconAlign'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) The side of the Button box to render the icon. Four values are allowed:</p><ul class="mdetail-params"><li>'top'</li><li>'right'</li><li>'bottom'</li><li>'left'</li></ul><p>Defaults to <b><tt>'left'</tt></b>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='arrowAlign'>
          <xs:annotation>
            <xs:documentation>
<p>(Optional) The side of the Button box to render the arrow if the button has an associated {@link #menu}. Two values are allowed:</p><ul class="mdetail-params"><li>'right'</li><li>'bottom'</li></ul><p>Defaults to <b><tt>'right'</tt></b>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='template'>
          <xs:annotation>
            <xs:documentation>
(Optional) <p>A {@link Ext.Template Template} used to create the Button's DOM structure.</p>Instances, or subclasses which need a different DOM structure may provide a different template layout in conjunction with an implementation of {@link #getTemplateArgs}. @type Ext.Template @property template
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='button' type='ext:ext.Button' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
See {@link #setActiveTab}. Sets the specified tab as the active tab. This method fires the {@link #beforetabchange} event which can <tt>return false</tt> to cancel the tab change. @param {String/Panel} tab The id or tab Panel to activate @method activate Simple Button class
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.SplitButton'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Button'>
        <xs:all>
            <xs:element name='arrowHandler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function called when the arrow button is clicked (can be used instead of click event)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='arrowHandler'>
          <xs:annotation>
            <xs:documentation>
A function called when the arrow button is clicked (can be used instead of click event)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='arrowTooltip'>
          <xs:annotation>
            <xs:documentation>
The title attribute of the arrow @event arrowclick Fires when this button's arrow is clicked @param {MenuButton} this @param {EventObject} e The click event
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='splitbutton' type='ext:ext.SplitButton' substitutionGroup='ext:button'>
    <xs:annotation>
      <xs:documentation>
Gets the pressed button in the passed group or null @param {String} group @return Button
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.CycleButton'>
    <xs:complexContent>
      <xs:extension base='ext:ext.SplitButton'>
        <xs:all>
            <xs:element name='items' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of {@link Ext.menu.CheckItem} <b>config</b> objects to be used when creating the button's menu items (e.g., {text:'Foo', iconCls:'foo-icon'})
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='changeHandler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A callback function that will be invoked each time the active menu item in the button's menu has changed. If this callback is not supplied, the SplitButton will instead fire the {@link #change} event on active item change. The changeHandler function will be called with the following argument list: (SplitButton this, Ext.menu.CheckItem item)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='items'>
          <xs:annotation>
            <xs:documentation>
An array of {@link Ext.menu.CheckItem} <b>config</b> objects to be used when creating the button's menu items (e.g., {text:'Foo', iconCls:'foo-icon'})
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showText'>
          <xs:annotation>
            <xs:documentation>
True to display the active item's text as the button text (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='prependText'>
          <xs:annotation>
            <xs:documentation>
A static string to prepend before the active item's text when displayed as the button's text (only applies when showText = true, defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='changeHandler'>
          <xs:annotation>
            <xs:documentation>
A callback function that will be invoked each time the active menu item in the button's menu has changed. If this callback is not supplied, the SplitButton will instead fire the {@link #change} event on active item change. The changeHandler function will be called with the following argument list: (SplitButton this, Ext.menu.CheckItem item)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='forceIcon'>
          <xs:annotation>
            <xs:documentation>
A css class which sets an image to be used as the static icon for this button. This icon will always be displayed regardless of which item is selected in the dropdown list. This overrides the default behavior of changing the button's icon to match the selected item's icon on change.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='cycle' type='ext:ext.CycleButton' substitutionGroup='ext:splitbutton'>
    <xs:annotation>
      <xs:documentation>
Sets this button's arrow click handler. @param {Function} handler The function to call when the arrow is clicked @param {Object} scope (optional) Scope for the function passed above
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Toolbar'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='toolbar' type='ext:ext.Toolbar' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>
<p>Basic Toolbar class. Although the <tt>{@link Ext.Container#defaultType defaultType}</tt> for Toolbar is <tt>{@link Ext.Button button}</tt>, Toolbar elements (child items for the Toolbar container) may be virtually any type of Component. Toolbar elements can be created explicitly via their constructors, or implicitly via their xtypes, and can be <tt>{@link #add}</tt>ed dynamically.</p><p>Some items have shortcut strings for creation:</p><pre><u>Shortcut</u>  <u>xtype</u>          <u>Class</u>                  <u>Description</u>
'-&gt;'      'tbfill'       {@link Ext.Toolbar.Fill}       begin using the right-justified button container
'-'       'tbseparator'  {@link Ext.Toolbar.Separator}  add a vertical separator bar between toolbar items
' '       'tbspacer'     {@link Ext.Toolbar.Spacer}     add horiztonal space between elements
</pre>Example usage of various elements: <pre><code>var tb = new Ext.Toolbar({
renderTo: document.body,
width: 600,
height: 100,
items: [
{
// xtype: 'button', // default for Toolbars, same as 'tbbutton'
text: 'Button'
},
{
xtype: 'splitbutton', // same as 'tbsplitbutton'
text: 'Split Button'
},
// begin using the right-justified button container
'-&gt;', // same as {xtype: 'tbfill'}, // Ext.Toolbar.Fill
{
xtype: 'textfield',
name: 'field1',
emptyText: 'enter search term'
},
// add a vertical separator bar between toolbar items
'-', // same as {xtype: 'tbseparator'} to create Ext.Toolbar.Separator
'text 1', // same as {xtype: 'tbtext', text: 'text1'} to create Ext.Toolbar.TextItem
{xtype: 'tbspacer'},// same as ' ' to create Ext.Toolbar.Spacer
'text 2',
{xtype: 'tbspacer', width: 50}, // add a 50px space
'text 3'
]
});
</code></pre>Example adding a ComboBox within a menu of a button: <pre><code>// ComboBox creation
var combo = new Ext.form.ComboBox({
store: new Ext.data.ArrayStore({
autoDestroy: true,
fields: ['initials', 'fullname'],
data : [
['FF', 'Fred Flintstone'],
['BR', 'Barney Rubble']
]
}),
displayField: 'fullname',
typeAhead: true,
mode: 'local',
forceSelection: true,
triggerAction: 'all',
emptyText: 'Select a name...',
selectOnFocus: true,
width: 135,
getListParent: function() {
return this.el.up('.x-menu');
},
iconCls: 'no-icon' //use iconCls if placing within menu to shift to right side of menu
});

// put ComboBox in a Menu
var menu = new Ext.menu.Menu({
id: 'mainMenu',
items: [
combo // A Field in a Menu
]
});

// add a Button with the menu
tb.add({
text:'Button w/ Menu',
menu: menu  // assign menu by instance
});
tb.doLayout();
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Item'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:string' name='overflowText'>
          <xs:annotation>
            <xs:documentation>
Text to be used for the menu if the item is overflowed.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tbitem' type='ext:ext.toolbar.Item' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
@event overflowchange Fires after the overflow state has changed. @param {Object} c The Container @param {Boolean} lastOverflow overflow state <p>Adds element(s) to the toolbar -- this function takes a variable number of arguments of mixed type and adds them to the toolbar.</p><br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>@param {Mixed} arg1 The following types of arguments are all valid:<br/><ul><li>{@link Ext.Button} config: A valid button config object (equivalent to {@link #addButton})</li><li>HtmlElement: Any standard HTML element (equivalent to {@link #addElement})</li><li>Field: Any form field (equivalent to {@link #addField})</li><li>Item: Any subclass of {@link Ext.Toolbar.Item} (equivalent to {@link #addItem})</li><li>String: Any generic string (gets wrapped in a {@link Ext.Toolbar.TextItem}, equivalent to {@link #addText}). Note that there are a few special strings that are treated differently as explained next.</li><li>'-': Creates a separator element (equivalent to {@link #addSeparator})</li><li>' ': Creates a spacer element (equivalent to {@link #addSpacer})</li><li>'-&gt;': Creates a fill element (equivalent to {@link #addFill})</li></ul>@param {Mixed} arg2 @param {Mixed} etc. @method add Adds a separator <br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>@return {Ext.Toolbar.Item} The separator {@link Ext.Toolbar.Item item} Adds a spacer element <br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>@return {Ext.Toolbar.Spacer} The spacer item Forces subsequent additions into the float:right toolbar <br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>Adds any standard HTML element to the toolbar <br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>@param {Mixed} el The element or id of the element to add @return {Ext.Toolbar.Item} The element's item Adds any Toolbar.Item or subclass <br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>@param {Ext.Toolbar.Item} item @return {Ext.Toolbar.Item} The item Adds a button (or buttons). See {@link Ext.Button} for more info on the config. <br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>@param {Object/Array} config A button config or array of configs @return {Ext.Button/Array} Adds text to the toolbar <br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>@param {String} text The text to add @return {Ext.Toolbar.Item} The element's item Adds a new element to the toolbar from the passed {@link Ext.DomHelper} config <br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>@param {Object} config @return {Ext.Toolbar.Item} The element's item Adds a dynamically rendered Ext.form field (TextField, ComboBox, etc). Note: the field should not have been rendered yet. For a field that has already been rendered, use {@link #addElement}. <br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>@param {Ext.form.Field} field @return {Ext.Toolbar.Item} Inserts any {@link Ext.Toolbar.Item}/{@link Ext.Button} at the specified index. <br/><p><b>Note</b>: See the notes within {@link Ext.Container#add}.</p>@param {Number} index The index where the item is to be inserted @param {Object/Ext.Toolbar.Item/Ext.Button/Array} item The button, or button config object to be inserted, or an array of buttons/configs. @return {Ext.Button/Item} The base class that other non-interacting Toolbar Item classes should extend in order to get some basic common toolbar item functionality.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Separator'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Item'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tbseparator' type='ext:ext.toolbar.Separator' substitutionGroup='ext:tbitem'>
    <xs:annotation>
      <xs:documentation>
A simple class that adds a vertical separator bar between toolbar items (css class:<tt>'xtb-sep'</tt>). Example usage: <pre><code>new Ext.Panel({
tbar : [
'Item 1',
{xtype: 'tbseparator'}, // or '-'
'Item 2'
]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Spacer'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Item'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tbspacer' type='ext:ext.toolbar.Spacer' substitutionGroup='ext:tbitem'>
    <xs:annotation>
      <xs:documentation>
A simple element that adds extra horizontal space between items in a toolbar. By default a 2px wide space is added via css specification:<pre><code>.x-toolbar .xtb-spacer {
width:2px;
}
</code></pre><p>Example usage:</p><pre><code>new Ext.Panel({
tbar : [
'Item 1',
{xtype: 'tbspacer'}, // or ' '
'Item 2',
// space width is also configurable via javascript
{xtype: 'tbspacer', width: 50}, // add a 50px space
'Item 3'
]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.Fill'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Spacer'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tbfill' type='ext:ext.toolbar.Fill' substitutionGroup='ext:tbspacer'>
    <xs:annotation>
      <xs:documentation>
A non-rendering placeholder item which instructs the Toolbar's Layout to begin using the right-justified button container. <pre><code>new Ext.Panel({
tbar : [
'Item 1',
{xtype: 'tbfill'}, // or '-&gt;'
'Item 2'
]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.toolbar.TextItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.toolbar.Item'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The text to be used as innerHTML (html tags are accepted)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tbtext' type='ext:ext.toolbar.TextItem' substitutionGroup='ext:tbitem'>
    <xs:annotation>
      <xs:documentation>
A simple class that renders text directly into a toolbar (with css class:<tt>'xtb-text'</tt>). Example usage: <pre><code>new Ext.Panel({
tbar : [
{xtype: 'tbtext', text: 'Item 1'} // or simply 'Item 1'
]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ButtonGroup'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:int' name='columns'>
          <xs:annotation>
            <xs:documentation>
The <tt>columns</tt> configuration property passed to the {@link #layout configured layout manager}. See {@link Ext.layout.TableLayout#columns}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='buttongroup' type='ext:ext.ButtonGroup' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
Updates this item's text, setting the text to be used as innerHTML. @param {String} t The text to display (html accepted). Container for a group of buttons. Example usage: <pre><code>var p = new Ext.Panel({
title: 'Panel with Button Group',
width: 300,
height:200,
renderTo: document.body,
html: 'whatever',
tbar: [{
xtype: 'buttongroup',
{@link #columns}: 3,
title: 'Clipboard',
items: [{
text: 'Paste',
scale: 'large',
rowspan: 3, iconCls: 'add',
iconAlign: 'top',
cls: 'x-btn-as-arrow'
},{
xtype:'splitbutton',
text: 'Menu Button',
scale: 'large',
rowspan: 3,
iconCls: 'add',
iconAlign: 'top',
arrowAlign:'bottom',
menu: [{text: 'Menu Item 1'}]
},{
xtype:'splitbutton', text: 'Cut', iconCls: 'add16', menu: [{text: 'Cut Menu Item'}]
},{
text: 'Copy', iconCls: 'add16'
},{
text: 'Format', iconCls: 'add16'
}]
}]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.PagingToolbar'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Toolbar'>
        <xs:all>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.Store} the paging toolbar should use as its data source (required).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.Store} the paging toolbar should use as its data source (required).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='displayInfo'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to display the displayMsg (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageSize'>
          <xs:annotation>
            <xs:documentation>
The number of records to display per page (defaults to <tt>20</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='prependButtons'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to insert any configured <tt>items</tt> <i>before</i> the paging buttons. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='displayMsg'>
          <xs:annotation>
            <xs:documentation>
The paging status message to display (defaults to <tt>'Displaying {0} - {1} of {2}'</tt>). Note that this string is formatted using the braced numbers <tt>{0}-{2}</tt> as tokens that are replaced by the values for start, end and total respectively. These tokens should be preserved when overriding this string if showing those values is desired.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyMsg'>
          <xs:annotation>
            <xs:documentation>
The message to display when no records are found (defaults to 'No data to display')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='beforePageText'>
          <xs:annotation>
            <xs:documentation>
The text displayed before the input item (defaults to <tt>'Page'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='afterPageText'>
          <xs:annotation>
            <xs:documentation>
Customizable piece of the default paging text (defaults to <tt>'of {0}'</tt>). Note that this string is formatted using <tt>{0}</tt> as a token that is replaced by the number of total pages. This token should be preserved when overriding this string if showing the total page count is desired.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='firstText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the first page button (defaults to <tt>'First Page'</tt>). <b>Note</b>: quick tips must be initialized for the quicktip to show.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='prevText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the previous page button (defaults to <tt>'Previous Page'</tt>). <b>Note</b>: quick tips must be initialized for the quicktip to show.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='nextText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the next page button (defaults to <tt>'Next Page'</tt>). <b>Note</b>: quick tips must be initialized for the quicktip to show.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='lastText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the last page button (defaults to <tt>'Last Page'</tt>). <b>Note</b>: quick tips must be initialized for the quicktip to show.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='refreshText'>
          <xs:annotation>
            <xs:documentation>
The quicktip text displayed for the Refresh button (defaults to <tt>'Refresh'</tt>). <b>Note</b>: quick tips must be initialized for the quicktip to show.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='paging' type='ext:ext.PagingToolbar' substitutionGroup='ext:toolbar'>
    <xs:annotation>
      <xs:documentation>
<p>As the amount of records increases, the time required for the browser to render them increases. Paging is used to reduce the amount of data exchanged with the client. Note: if there are more records/rows than can be viewed in the available screen area, vertical scrollbars will be added.</p><p>Paging is typically handled on the server side (see exception below). The client sends parameters to the server side, which the server needs to interpret and then respond with the approprate data.</p><p><b>Ext.PagingToolbar</b> is a specialized toolbar that is bound to a {@link Ext.data.Store} and provides automatic paging control. This Component {@link Ext.data.Store#load load}s blocks of data into the <tt>{@link #store}</tt> by passing {@link Ext.data.Store#paramNames paramNames} used for paging criteria.</p><p>PagingToolbar is typically used as one of the Grid's toolbars:</p><pre><code>Ext.QuickTips.init(); // to display button quicktips

var myStore = new Ext.data.Store({
reader: new Ext.data.JsonReader({
{@link Ext.data.JsonReader#totalProperty totalProperty}: 'results', 
...
}),
...
});

var myPageSize = 25;  // server script should only send back 25 items at a time

var grid = new Ext.grid.GridPanel({
...
store: myStore,
bbar: new Ext.PagingToolbar({
{@link #store}: myStore,       // grid and PagingToolbar using same store
{@link #displayInfo}: true,
{@link #pageSize}: myPageSize,
{@link #prependButtons}: true,
items: [
'text 1'
]
})
});
</code></pre><p>To use paging, pass the paging requirements to the server when the store is first loaded.</p><pre><code>store.load({
params: {
// specify params for the first page load if using paging
start: 0,          
limit: myPageSize,
// other params
foo:   'bar'
}
});
</code></pre><p>If using {@link Ext.data.Store#autoLoad store's autoLoad} configuration:</p><pre><code>var myStore = new Ext.data.Store({
{@link Ext.data.Store#autoLoad autoLoad}: {params:{start: 0, limit: 25}},
...
});
</code></pre><p>The packet sent back from the server would have this form:</p><pre><code>{
"success": true,
"results": 2000, 
"rows": [ // <b>*Note:</b> this must be an Array 
{ "id":  1, "name": "Bill", "occupation": "Gardener" },
{ "id":  2, "name":  "Ben", "occupation": "Horticulturalist" },
...
{ "id": 25, "name":  "Sue", "occupation": "Botanist" }
]
}
</code></pre><p><u>Paging with Local Data</u></p><p>Paging can also be accomplished with local data using extensions:</p><div class="mdetail-params"><ul><li><a href="http://extjs.com/forum/showthread.php?t=71532">Ext.ux.data.PagingStore</a></li><li>Paging Memory Proxy (examples/ux/PagingMemoryProxy.js)</li></ul></div>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.Tip'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width of the tip in pixels (defaults to 40).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxWidth'>
          <xs:annotation>
            <xs:documentation>
The maximum width of the tip in pixels (defaults to 300). The maximum supported value is 500.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultAlign'>
          <xs:annotation>
            <xs:documentation>
<b>Experimental</b>. The default {@link Ext.Element#alignTo} anchor position value for this tip relative to its element of origin (defaults to "tl-bl?").
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tip' type='ext:ext.Tip' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
The id of the iframe required by IE to manage the history stack. @type String @property Initialize the global History instance. @param {Boolean} onReady (optional) A callback function that will be called once the history component is fully initialized. @param {Object} scope (optional) The callback scope Add a new token to the history stack. This can be any arbitrary value, although it would commonly be the concatenation of a component id and another id marking the specifc history state of that component. Example usage: <pre><code>// Handle tab changes on a TabPanel
tabPanel.on('tabchange', function(tabPanel, tab){
Ext.History.add(tabPanel.id + ':' + tab.id);
});
</code></pre>@param {String} token The value that defines a particular application-specific history state @param {Boolean} preventDuplicates When true, if the passed token matches the current token it will not save a new history step. Set to false if the same state can be saved more than once at the same history stack location (defaults to true). Programmatically steps back one step in browser history (equivalent to the user pressing the Back button). Programmatically steps forward one step in browser history (equivalent to the user pressing the Forward button). Retrieves the currently-active history token. @return {String} The token
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.ToolTip'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Tip'>
        <xs:all>
            <xs:element name='target' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The target HTMLElement, Ext.Element or id to monitor for mouseover events to trigger showing this ToolTip.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='mouseOffset' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An XY offset from the mouse position where the tooltip should be shown (defaults to [15,18]).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='target'>
          <xs:annotation>
            <xs:documentation>
The target HTMLElement, Ext.Element or id to monitor for mouseover events to trigger showing this ToolTip.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoHide'>
          <xs:annotation>
            <xs:documentation>
True to automatically hide the tooltip after the mouse exits the target element or after the <code>{@link #dismissDelay}</code> has expired if set (defaults to true). If <code>{@link closable} = true</code> a close tool button will be rendered into the tooltip header.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='showDelay'>
          <xs:annotation>
            <xs:documentation>
Delay in milliseconds before the tooltip displays after the mouse enters the target element (defaults to 500)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='hideDelay'>
          <xs:annotation>
            <xs:documentation>
Delay in milliseconds after the mouse exits the target element but before the tooltip actually hides (defaults to 200). Set to 0 for the tooltip to hide immediately.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='dismissDelay'>
          <xs:annotation>
            <xs:documentation>
Delay in milliseconds before the tooltip automatically hides (defaults to 5000). To disable automatic hiding, set dismissDelay = 0.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='mouseOffset'>
          <xs:annotation>
            <xs:documentation>
An XY offset from the mouse position where the tooltip should be shown (defaults to [15,18]).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackMouse'>
          <xs:annotation>
            <xs:documentation>
True to have the tooltip follow the mouse as it moves over the target element (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='anchorToTarget'>
          <xs:annotation>
            <xs:documentation>
True to anchor the tooltip to the target element, false to anchor it relative to the mouse coordinates (defaults to true). When <code>anchorToTarget</code> is true, use <code>{@link #defaultAlign}</code> to control tooltip alignment to the target element. When <code>anchorToTarget</code> is false, use <code>{@link #anchorPosition}</code> instead to control alignment.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='anchorOffset'>
          <xs:annotation>
            <xs:documentation>
A numeric pixel value used to offset the default position of the anchor arrow (defaults to 0). When the anchor position is on the top or bottom of the tooltip, <code>anchorOffset</code> will be used as a horizontal offset. Likewise, when the anchor position is on the left or right side, <code>anchorOffset</code> will be used as a vertical offset.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='delegate'>
          <xs:annotation>
            <xs:documentation>
<p>Optional. A {@link Ext.DomQuery DomQuery} selector which allows selection of individual elements within the <code>{@link #target}</code> element to trigger showing and hiding the ToolTip as the mouse moves within the target.</p><p>When specified, the child element of the target which caused a show event is placed into the <code>{@link #triggerElement}</code> property before the ToolTip is shown.</p><p>This may be useful when a Component has regular, repeating elements in it, each of which need a Tooltip which contains information specific to that element. For example:</p><pre><code>var myGrid = new Ext.grid.gridPanel(gridConfig);
myGrid.on('render', function(grid) {
var store = grid.getStore();  // Capture the Store.
var view = grid.getView();    // Capture the GridView.
myGrid.tip = new Ext.ToolTip({
target: view.mainBody,    // The overall target element.
delegate: '.x-grid3-row', // Each grid row causes its own seperate show and hide.
trackMouse: true,         // Moving within the row should not hide the tip.
renderTo: document.body,  // Render immediately so that tip.body can be
//  referenced prior to the first show.
listeners: {              // Change content dynamically depending on which element
//  triggered the show.
beforeshow: function updateTipBody(tip) {
var rowIndex = view.findRowIndex(tip.triggerElement);
tip.body.dom.innerHTML = 'Over Record ID ' + store.getAt(rowIndex).id;
}
}
});
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='tooltip' type='ext:ext.ToolTip' substitutionGroup='ext:tip'>
    <xs:annotation>
      <xs:documentation>
Shows this tip at the specified XY position. Example usage: <pre><code>// Show the tip at x:50 and y:100
tip.showAt([50,100]);
</code></pre>@param {Array} xy An array containing the x and y coordinates <b>Experimental</b>. Shows this tip at a position relative to another element using a standard {@link Ext.Element#alignTo} anchor position value. Example usage: <pre><code>// Show the tip at the default position ('tl-br?')
tip.showBy('my-el');

// Show the tip's top-left corner anchored to the element's top-right corner
tip.showBy('my-el', 'tl-tr');
</code></pre>@param {Mixed} el An HTMLElement, Ext.Element or string id of the target element to align to @param {String} position (optional) A valid {@link Ext.Element#alignTo} anchor position (defaults to 'tl-br?' or {@link #defaultAlign} if specified). When a Tooltip is configured with the <code>{@link #delegate}</code> option to cause selected child elements of the <code>{@link #target}</code> Element to each trigger a seperate show event, this property is set to the DOM element which triggered the show. @type DOMElement @property triggerElement
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.QuickTip'>
    <xs:complexContent>
      <xs:extension base='ext:ext.ToolTip'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:boolean' name='interceptTitles'>
          <xs:annotation>
            <xs:documentation>
True to automatically use the element's DOM title value if available (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='quicktip' type='ext:ext.QuickTip' substitutionGroup='ext:tooltip'>
    <xs:annotation>
      <xs:documentation>
Binds this ToolTip to the specified element. The tooltip will be displayed when the mouse moves over the element. @param {Mixed} t The Element, HtmlElement, or ID of an element to bind to Hides this tooltip if visible. Shows this tooltip at the current event target XY position.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.tree.TreePanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:all>
            <xs:element name='root' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The root node for the tree.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='dragConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Custom config to pass to the {@link Ext.tree.TreeDragZone} instance
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='dropConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Custom config to pass to the {@link Ext.tree.TreeDropZone} instance
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='selModel' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A tree selection model to use with this TreePanel (defaults to an {@link Ext.tree.DefaultSelectionModel})
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='loader' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A {@link Ext.tree.TreeLoader} for use with this TreePanel
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='root'>
          <xs:annotation>
            <xs:documentation>
The root node for the tree.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='rootVisible'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to hide the root node (defaults to <tt>true</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='lines'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to disable tree lines (defaults to <tt>true</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDD'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable drag and drop
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDrag'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable just drag
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDrop'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable just drop
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dragConfig'>
          <xs:annotation>
            <xs:documentation>
Custom config to pass to the {@link Ext.tree.TreeDragZone} instance
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='dropConfig'>
          <xs:annotation>
            <xs:documentation>
Custom config to pass to the {@link Ext.tree.TreeDropZone} instance
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ddGroup'>
          <xs:annotation>
            <xs:documentation>
The DD group this TreePanel belongs to
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ddAppendOnly'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> if the tree should only allow append drops (use for trees which are sorted)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ddScroll'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable body scrolling
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='containerScroll'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to register this container with ScrollManager
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hlDrop'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to disable node highlight on drop (defaults to the value of {@link Ext#enableFx})
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hlColor'>
          <xs:annotation>
            <xs:documentation>
The color of the node highlight (defaults to <tt>'C3DAF9'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='animate'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable animated expand/collapse (defaults to the value of {@link Ext#enableFx})
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='singleExpand'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> if only 1 node per branch may be expanded
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selModel'>
          <xs:annotation>
            <xs:documentation>
A tree selection model to use with this TreePanel (defaults to an {@link Ext.tree.DefaultSelectionModel})
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackMouseOver'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to disable mouse over highlighting
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loader'>
          <xs:annotation>
            <xs:documentation>
A {@link Ext.tree.TreeLoader} for use with this TreePanel
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='pathSeparator'>
          <xs:annotation>
            <xs:documentation>
The token used to separate sub-paths in path strings (defaults to <tt>'/'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='useArrows'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to use Vista-style arrows in the tree (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='requestMethod'>
          <xs:annotation>
            <xs:documentation>
The HTTP request method for loading data (defaults to the value of {@link Ext.Ajax#method}).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='treepanel' type='ext:ext.tree.TreePanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
Enable quick tips globally. Disable quick tips globally. Returns true if quick tips are enabled, else false. @return {Boolean} Gets the global QuickTips instance. Configures a new quick tip instance and assigns it to a target element. See {@link Ext.QuickTip#register} for details. @param {Object} config The config object Removes any registered quick tip from the target element and destroys it. @param {String/HTMLElement/Element} el The element from which the quick tip is to be removed. Alias of {@link #register}. @param {Object} config The config object
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.FlashComponent'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:all>
            <xs:element name='flashVars' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A set of key value pairs to be passed to the flash object as flash variables. Defaults to <tt>undefined</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='flashParams' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A set of key value pairs to be passed to the flash object as parameters. Possible parameters can be found here: http://kb2.adobe.com/cps/127/tn_12701.html Defaults to <tt>undefined</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='flashVersion'>
          <xs:annotation>
            <xs:documentation>
Indicates the version the flash content was published for. Defaults to <tt>'9.0.45'</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='backgroundColor'>
          <xs:annotation>
            <xs:documentation>
The background color of the chart. Defaults to <tt>'#ffffff'</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='wmode'>
          <xs:annotation>
            <xs:documentation>
The wmode of the flash object. This can be used to control layering. Defaults to <tt>'opaque'</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='flashVars'>
          <xs:annotation>
            <xs:documentation>
A set of key value pairs to be passed to the flash object as flash variables. Defaults to <tt>undefined</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='flashParams'>
          <xs:annotation>
            <xs:documentation>
A set of key value pairs to be passed to the flash object as parameters. Possible parameters can be found here: http://kb2.adobe.com/cps/127/tn_12701.html Defaults to <tt>undefined</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='url'>
          <xs:annotation>
            <xs:documentation>
The URL of the chart to include. Defaults to <tt>undefined</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='expressInstall'>
          <xs:annotation>
            <xs:documentation>
True to prompt the user to install flash if not installed. Note that this uses Ext.FlashComponent.EXPRESS_INSTALL_URL, which should be set to the local resource. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='flash' type='ext:ext.FlashComponent' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
Edit the text of the passed {@link Ext.tree.TreeNode TreeNode}. @param node {Ext.tree.TreeNode} The TreeNode to edit. The TreeNode must be {@link Ext.tree.TreeNode#editable editable}. The {@link Ext.tree.TreeNode TreeNode} this editor is bound to. Read-only. @type Ext.tree.TreeNode @property editNode
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.Chart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.FlashComponent'>
        <xs:all>
            <xs:element name='chartStyle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Sets styles for this chart. Contains a number of default values. Modifying this property will override the base styles on the chart.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='extraStyle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Contains extra styles that will be added or overwritten to the default chartStyle. Defaults to <tt>null</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='chartStyle'>
          <xs:annotation>
            <xs:documentation>
Sets styles for this chart. Contains a number of default values. Modifying this property will override the base styles on the chart.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='extraStyle'>
          <xs:annotation>
            <xs:documentation>
Contains extra styles that will be added or overwritten to the default chartStyle. Defaults to <tt>null</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disableCaching'>
          <xs:annotation>
            <xs:documentation>
True to add a "cache buster" to the end of the chart url. Defaults to true for Opera and IE.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='chart' type='ext:ext.chart.Chart' substitutionGroup='ext:flash'>
  </xs:element>
  <xs:complexType name='ext.chart.PieChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.Chart'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='piechart' type='ext:ext.chart.PieChart' substitutionGroup='ext:chart'>
    <xs:annotation>
      <xs:documentation>
Sets a single style value on the Chart instance. @param name {String} Name of the Chart style value to change. @param value {Object} New value to pass to the Chart style. Resets all styles on the Chart instance. @param styles {Object} Initializer for all Chart styles. Sets the styles on all series in the Chart. @param styles {Array} Initializer for all Chart series styles. Changes the data store bound to this chart and refreshes it. @param {Store} store The store to bind to this chart Sets the url to load the chart from. This should be set to a local resource. @static @type String
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.chart.CartesianChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.Chart'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='cartesianchart' type='ext:ext.chart.CartesianChart' substitutionGroup='ext:chart'>
  </xs:element>
  <xs:complexType name='ext.chart.LineChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='linechart' type='ext:ext.chart.LineChart' substitutionGroup='ext:cartesianchart'>
  </xs:element>
  <xs:complexType name='ext.chart.ColumnChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='columnchart' type='ext:ext.chart.ColumnChart' substitutionGroup='ext:cartesianchart'>
  </xs:element>
  <xs:complexType name='ext.chart.StackedColumnChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='stackedcolumnchart' type='ext:ext.chart.StackedColumnChart' substitutionGroup='ext:cartesianchart'>
  </xs:element>
  <xs:complexType name='ext.chart.BarChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='barchart' type='ext:ext.chart.BarChart' substitutionGroup='ext:cartesianchart'>
  </xs:element>
  <xs:complexType name='ext.chart.StackedBarChart'>
    <xs:complexContent>
      <xs:extension base='ext:ext.chart.CartesianChart'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='stackedbarchart' type='ext:ext.chart.StackedBarChart' substitutionGroup='ext:cartesianchart'>
  </xs:element>
  <xs:complexType name='ext.menu.Menu'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Container'>
        <xs:all>
            <xs:element name='defaultOffsets' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array specifying the [x, y] offset in pixels by which to change the default Menu popup position after aligning according to the {@link #defaultAlign} configuration. Defaults to <tt>[0, 0]</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:int' name='minWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width of the menu in pixels (defaults to 120)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>
True or 'sides' for the default effect, 'frame' for 4-way shadow, and 'drop' for bottom-right shadow (defaults to 'sides')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='subMenuAlign'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.Element#alignTo} anchor position value to use for submenus of this menu (defaults to 'tl-tr?')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultAlign'>
          <xs:annotation>
            <xs:documentation>
The default {@link Ext.Element#alignTo} anchor position value for this menu relative to its element of origin (defaults to 'tl-bl?')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowOtherMenus'>
          <xs:annotation>
            <xs:documentation>
True to allow multiple menus to be displayed at the same time (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='ignoreParentClicks'>
          <xs:annotation>
            <xs:documentation>
True to ignore clicks on any item in this menu that is a parent item (displays a submenu) so that the submenu is not dismissed when clicking the parent item (defaults to false).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableScrolling'>
          <xs:annotation>
            <xs:documentation>
True to allow the menu container to have scroller controls if the menu is too long (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxHeight'>
          <xs:annotation>
            <xs:documentation>
The maximum height of the menu. Only applies when enableScrolling is set to True (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='scrollIncrement'>
          <xs:annotation>
            <xs:documentation>
The amount to scroll the menu. Only applies when enableScrolling is set to True (defaults to 24).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showSeparator'>
          <xs:annotation>
            <xs:documentation>
True to show the icon separator. (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultOffsets'>
          <xs:annotation>
            <xs:documentation>
An array specifying the [x, y] offset in pixels by which to change the default Menu popup position after aligning according to the {@link #defaultAlign} configuration. Defaults to <tt>[0, 0]</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='plain'>
          <xs:annotation>
            <xs:documentation>
True to remove the incised line down the left side of the menu. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='floating'>
          <xs:annotation>
            <xs:documentation>
<p>By default, a Menu configured as <b><code>floating:true</code></b> will be rendered as an {@link Ext.Layer} (an absolutely positioned, floating Component with zindex=15000). If configured as <b><code>floating:false</code></b>, the Menu may be used as child item of another Container instead of a free-floating {@link Ext.Layer Layer}.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menu' type='ext:ext.menu.Menu' substitutionGroup='ext:container'>
    <xs:annotation>
      <xs:documentation>
<p>A menu object. This is the container to which you may add menu items. Menu can also serve as a base class when you want a specialized menu based off of another component (like {@link Ext.menu.DateMenu} for example).</p><p>Menus may contain either {@link Ext.menu.Item menu items}, or general {@link Ext.Component Component}s.</p><p>To make a contained general {@link Ext.Component Component} line up with other {@link Ext.menu.Item menu items} specify <tt>iconCls: 'no-icon'</tt>. This reserves a space for an icon, and indents the Component in line with the other menu items. See {@link Ext.form.ComboBox}.{@link Ext.form.ComboBox#getListParent getListParent} for an example.</p><p>By default, Menus are absolutely positioned, floating Components. By configuring a Menu with <b><tt>{@link #floating}:false</tt></b>, a Menu may be used as child of a Container.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.BaseItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Component'>
        <xs:all>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    @event click Fires when this item is clicked @param {Ext.menu.BaseItem} this @param {Ext.EventObject} e @event activate Fires when this item is activated @param {Ext.menu.BaseItem} this @event deactivate Fires when this item is deactivated @param {Ext.menu.BaseItem} this @property parentMenu @type Ext.menu.Menu The parent Menu of this Item. A function that will handle the click event of this menu item (optional). The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>b</code> : Item<div class="sub-desc">This menu Item.</div></li><li><code>e</code> : EventObject<div class="sub-desc">The click event.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the handler function will be called.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
@event click Fires when this item is clicked @param {Ext.menu.BaseItem} this @param {Ext.EventObject} e @event activate Fires when this item is activated @param {Ext.menu.BaseItem} this @event deactivate Fires when this item is deactivated @param {Ext.menu.BaseItem} this @property parentMenu @type Ext.menu.Menu The parent Menu of this Item. A function that will handle the click event of this menu item (optional). The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>b</code> : Item<div class="sub-desc">This menu Item.</div></li><li><code>e</code> : EventObject<div class="sub-desc">The click event.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the handler function will be called.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='canActivate'>
          <xs:annotation>
            <xs:documentation>
True if this item can be visually activated (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='activeClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to use when the item becomes activated (defaults to "x-menu-item-active")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideOnClick'>
          <xs:annotation>
            <xs:documentation>
True to hide the containing menu after this item is clicked (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='clickHideDelay'>
          <xs:annotation>
            <xs:documentation>
Length of time in milliseconds to wait before hiding after a click (defaults to 100)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menubaseitem' type='ext:ext.menu.BaseItem' substitutionGroup='ext:component'>
    <xs:annotation>
      <xs:documentation>
Hides all menus that are currently visible Returns a {@link Ext.menu.Menu} object @param {String/Object} menu The string menu id, an existing menu object reference, or a Menu config that will be used to generate and return a new Menu instance. @return {Ext.menu.Menu} The specified menu, or null if none are found The base class for all items that render into menus. BaseItem provides default rendering, activated state management and base configuration options shared by all menu components.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.TextItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.BaseItem'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The text to display for this item (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menutextitem' type='ext:ext.menu.TextItem' substitutionGroup='ext:menubaseitem'>
    <xs:annotation>
      <xs:documentation>
Sets the function that will handle click events for this item (equivalent to passing in the {@link #handler} config property). If an existing handler is already registered, it will be unregistered for you. @param {Function} handler The function that should be called on click @param {Object} scope The scope that should be passed to the handler
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.Separator'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.BaseItem'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menuseparator' type='ext:ext.menu.Separator' substitutionGroup='ext:menubaseitem'>
  </xs:element>
  <xs:complexType name='ext.menu.Item'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.BaseItem'>
        <xs:all>
            <xs:element name='menu' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    (optional) Either an instance of {@link Ext.menu.Menu} or the config object for an {@link Ext.menu.Menu} which acts as the submenu when this item is activated.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='menu'>
          <xs:annotation>
            <xs:documentation>
(optional) Either an instance of {@link Ext.menu.Menu} or the config object for an {@link Ext.menu.Menu} which acts as the submenu when this item is activated.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='icon'>
          <xs:annotation>
            <xs:documentation>
The path to an icon to display in this item (defaults to Ext.BLANK_IMAGE_URL). If icon is specified {@link #iconCls} should not be.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='iconCls'>
          <xs:annotation>
            <xs:documentation>
A CSS class that specifies a background image that will be used as the icon for this item (defaults to ''). If iconCls is specified {@link #icon} should not be.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The text to display in this item (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='href'>
          <xs:annotation>
            <xs:documentation>
The href attribute to use for the underlying anchor link (defaults to '#').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hrefTarget'>
          <xs:annotation>
            <xs:documentation>
The target attribute to use for the underlying anchor link (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='showDelay'>
          <xs:annotation>
            <xs:documentation>
Length of time in milliseconds to wait before showing this item (defaults to 200)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menuitem' type='ext:ext.menu.Item' substitutionGroup='ext:menubaseitem'>
    <xs:annotation>
      <xs:documentation>
@property menu @type Ext.menu.Menu The submenu associated with this Item if one was configured.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.CheckItem'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.Item'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:string' name='group'>
          <xs:annotation>
            <xs:documentation>
@event checkchange Fires after the checked value has been set @param {Ext.menu.CheckItem} this @param {Boolean} checked The checked value that was set A function that handles the checkchange event. The function is undefined by default, but if an implementation is provided, it will be called automatically when the checkchange event fires. @param {Ext.menu.CheckItem} this @param {Boolean} checked The checked value that was set @method checkHandler All check items with the same group name will automatically be grouped into a single-select radio button group (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='groupClass'>
          <xs:annotation>
            <xs:documentation>
The default CSS class to use for radio group check items (defaults to "x-menu-group-item")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='checked'>
          <xs:annotation>
            <xs:documentation>
True to initialize this checkbox as checked (defaults to false). Note that if this checkbox is part of a radio group (group = true) only the last item in the group that is initialized with checked = true will be rendered as checked.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='menucheckitem' type='ext:ext.menu.CheckItem' substitutionGroup='ext:menuitem'>
    <xs:annotation>
      <xs:documentation>
Sets the text to display in this menu item @param {String} text The text to display Sets the CSS class to apply to the item's icon element @param {String} cls The CSS class to apply @event beforecheckchange Fires before the checked value is set, providing an opportunity to cancel if needed @param {Ext.menu.CheckItem} this @param {Boolean} checked The new checked value that will be set
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.DateMenu'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.Menu'>
        <xs:all>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Optional. A function that will handle the select event of this menu. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>picker</code> : DatePicker<div class="sub-desc">The Ext.DatePicker.</div></li><li><code>date</code> : Date<div class="sub-desc">The selected date.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this DateMenu instance.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
Optional. A function that will handle the select event of this menu. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>picker</code> : DatePicker<div class="sub-desc">The Ext.DatePicker.</div></li><li><code>date</code> : Date<div class="sub-desc">The selected date.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this DateMenu instance.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideOnClick'>
          <xs:annotation>
            <xs:documentation>
False to continue showing the menu after a date is selected, defaults to true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='pickerId'>
          <xs:annotation>
            <xs:documentation>
An id to assign to the underlying date picker. Defaults to <tt>null</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='datemenu' type='ext:ext.menu.DateMenu' substitutionGroup='ext:menu'>
    <xs:annotation>
      <xs:documentation>
Set the checked state of this item @param {Boolean} checked The new checked value @param {Boolean} suppressEvent (optional) True to prevent the checkchange event from firing (defaults to false)
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.menu.ColorMenu'>
    <xs:complexContent>
      <xs:extension base='ext:ext.menu.Menu'>
        <xs:all>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Optional. A function that will handle the select event of this menu. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>palette</code> : ColorPalette<div class="sub-desc">The {@link #palette Ext.ColorPalette}.</div></li><li><code>color</code> : String<div class="sub-desc">The 6-digit color hex code (without the # symbol).</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this ColorMenu instance.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
Optional. A function that will handle the select event of this menu. The handler is passed the following parameters:<div class="mdetail-params"><ul><li><code>palette</code> : ColorPalette<div class="sub-desc">The {@link #palette Ext.ColorPalette}.</div></li><li><code>color</code> : String<div class="sub-desc">The 6-digit color hex code (without the # symbol).</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
The scope (<tt><b>this</b></tt> reference) in which the <code>{@link #handler}</code> function will be called. Defaults to this ColorMenu instance.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideOnClick'>
          <xs:annotation>
            <xs:documentation>
False to continue showing the menu after a color is selected, defaults to true.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='paletteId'>
          <xs:annotation>
            <xs:documentation>
An id to assign to the underlying color palette. Defaults to <tt>null</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='colormenu' type='ext:ext.menu.ColorMenu' substitutionGroup='ext:menu'>
    <xs:annotation>
      <xs:documentation>
The {@link Ext.DatePicker} instance for this DateMenu @property picker @type DatePicker @event click @hide @event itemclick @hide @event select Fires when a date is selected from the {@link #picker Ext.DatePicker} @param {DatePicker} picker The {@link #picker Ext.DatePicker} @param {Date} date The selected date <p>A menu containing a {@link Ext.ColorPalette} Component.</p><p>Notes:</p><div class="mdetail-params"><ul><li>Although not listed here, the <b>constructor</b> for this class accepts all of the configuration options of <b>{@link Ext.ColorPalette}</b>.</li><li>If subclassing ColorMenu, any configuration options for the ColorPalette must be applied to the <tt><b>initialConfig</b></tt> property of the ColorMenu. Applying {@link Ext.ColorPalette ColorPalette} configuration settings to <b><tt>this</tt></b> will <b>not</b> affect the ColorPalette's configuration.</li></ul></div>*
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Field'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:all>
            <xs:element name='value' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A value to initialize this field with (defaults to undefined).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='autoCreate' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} element spec, or true for a default element spec. Used to create the {@link Ext.Component#getEl Element} which will encapsulate this Component. See <tt>{@link Ext.Component#autoEl autoEl}</tt> for details. Defaults to:</p><pre><code>{tag: 'input', type: 'text', size: '20', autocomplete: 'off'}</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='inputType'>
          <xs:annotation>
            <xs:documentation>
The type attribute for input fields -- e.g. radio, text, password, file (defaults to 'text'). The types 'file' and 'password' must be used to render those field types currently -- there are no separate Ext components for those. Note that if you use <tt>inputType:'file'</tt>, {@link #emptyText} is not supported and should be avoided.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='tabIndex'>
          <xs:annotation>
            <xs:documentation>
The tabIndex for this field. Note this only applies to fields that are rendered, not those which are built via applyTo (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='value'>
          <xs:annotation>
            <xs:documentation>
A value to initialize this field with (defaults to undefined).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='name'>
          <xs:annotation>
            <xs:documentation>
The field's HTML name attribute (defaults to ''). <b>Note</b>: this property must be set if this field is to be automatically included with {@link Ext.form.BasicForm#submit form submit()}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='invalidClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to use when marking a field invalid (defaults to 'x-form-invalid')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='invalidText'>
          <xs:annotation>
            <xs:documentation>
The error text to use when marking a field invalid and no message is provided (defaults to 'The value in this field is invalid')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='focusClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to use when the field receives focus (defaults to 'x-form-focus')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='preventMark'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to disable {@link #markInvalid marking the field invalid}. Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='validationEvent'>
          <xs:annotation>
            <xs:documentation>
The event that should initiate field validation. Set to false to disable automatic validation (defaults to 'keyup').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='validateOnBlur'>
          <xs:annotation>
            <xs:documentation>
Whether the field should validate when it loses focus (defaults to true).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='validationDelay'>
          <xs:annotation>
            <xs:documentation>
The length of time in milliseconds after user input begins until validation is initiated (defaults to 250)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='autoCreate'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} element spec, or true for a default element spec. Used to create the {@link Ext.Component#getEl Element} which will encapsulate this Component. See <tt>{@link Ext.Component#autoEl autoEl}</tt> for details. Defaults to:</p><pre><code>{tag: 'input', type: 'text', size: '20', autocomplete: 'off'}</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='fieldClass'>
          <xs:annotation>
            <xs:documentation>
The default CSS class for the field (defaults to 'x-form-field')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='msgTarget'>
          <xs:annotation>
            <xs:documentation>
The location where error text should display. Should be one of the following values (defaults to 'qtip'): <pre>Value         Description
-----------   ----------------------------------------------------------------------
qtip          Display a quick tip when the user hovers over the field
title         Display a default browser title attribute popup
under         Add a block div beneath the field containing the error text
side          Add an error icon to the right of the field with a popup on hover
[element id]  Add the error text directly to the innerHTML of the specified element
</pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='msgFx'>
          <xs:annotation>
            <xs:documentation>
<b>Experimental</b> The effect used when displaying a validation message under the field (defaults to 'normal').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='readOnly'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to mark the field as readOnly in HTML (defaults to <tt>false</tt>). <br/><p><b>Note</b>: this only sets the element's readOnly DOM attribute. Setting <code>readOnly=true</code>, for example, will not disable triggering a ComboBox or DateField; it gives you the option of forcing the user to choose via the trigger without typing in the text box. To hide the trigger use <code>{@link Ext.form.TriggerField#hideTrigger hideTrigger}</code>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='field' type='ext:ext.form.Field' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
@property palette @type ColorPalette The {@link Ext.ColorPalette} instance for this ColorMenu @event click @hide @event itemclick @hide @event select Fires when a color is selected from the {@link #palette Ext.ColorPalette} @param {Ext.ColorPalette} palette The {@link #palette Ext.ColorPalette} @param {String} color The 6-digit color hex code (without the # symbol) Base class for form fields that provides default event handling, sizing, value handling and other functionality.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TextField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:all>
            <xs:element name='stripCharsRe' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to <tt>null</tt>).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='maskRe' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An input mask regular expression that will be used to filter keystrokes that do not match (defaults to <tt>null</tt>)
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='validator' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A custom validation function to be called during field validation ({@link #validateValue}) (defaults to <tt>null</tt>). If specified, this function will be called first, allowing the developer to override the default validation process.</p><br/><p>This function will be passed the following Parameters:</p><div class="mdetail-params"><ul><li><code>value</code>: <i>Mixed</i> <div class="sub-desc">The current field value</div></li></ul></div><br/><p>This function is to Return:</p><div class="mdetail-params"><ul><li><code>true</code>: <i>Boolean</i> <div class="sub-desc"><code>true</code> if the value is valid</div></li><li><code>msg</code>: <i>String</i> <div class="sub-desc">An error message if the value is invalid</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='regex' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A JavaScript RegExp object to be tested against the field value during validation (defaults to <tt>null</tt>). If the test fails, the field will be marked invalid using <b><tt>{@link #regexText}</tt></b>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='vtypeText'>
          <xs:annotation>
            <xs:documentation>
A custom error message to display in place of the default message provided for the <b><code>{@link #vtype}</code></b> currently set for this field (defaults to <tt>''</tt>). <b>Note</b>: only applies if <b><code>{@link #vtype}</code></b> is set, else ignored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='stripCharsRe'>
          <xs:annotation>
            <xs:documentation>
A JavaScript RegExp object used to strip unwanted content from the value before validation (defaults to <tt>null</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='grow'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> if this field should automatically grow and shrink to its content (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='growMin'>
          <xs:annotation>
            <xs:documentation>
The minimum width to allow when <code><b>{@link #grow}</b> = true</code> (defaults to <tt>30</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='growMax'>
          <xs:annotation>
            <xs:documentation>
The maximum width to allow when <code><b>{@link #grow}</b> = true</code> (defaults to <tt>800</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='vtype'>
          <xs:annotation>
            <xs:documentation>
A validation type name as defined in {@link Ext.form.VTypes} (defaults to <tt>null</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maskRe'>
          <xs:annotation>
            <xs:documentation>
An input mask regular expression that will be used to filter keystrokes that do not match (defaults to <tt>null</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disableKeyFilter'>
          <xs:annotation>
            <xs:documentation>
Specify <tt>true</tt> to disable input keystroke filtering (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowBlank'>
          <xs:annotation>
            <xs:documentation>
Specify <tt>false</tt> to validate that the value's length is &gt; 0 (defaults to <tt>true</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minLength'>
          <xs:annotation>
            <xs:documentation>
Minimum input field length required (defaults to <tt>0</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxLength'>
          <xs:annotation>
            <xs:documentation>
Maximum input field length allowed by validation (defaults to Number.MAX_VALUE). This behavior is intended to provide instant feedback to the user by improving usability to allow pasting and editing or overtyping and back tracking. To restrict the maximum number of characters that can be entered into the field use <tt><b>{@link Ext.form.Field#autoCreate autoCreate}</b></tt> to add any attributes you want to a field, for example:<pre><code>var myField = new Ext.form.NumberField({
id: 'mobile',
anchor:'90%',
fieldLabel: 'Mobile',
maxLength: 16, // for validation
autoCreate: {tag: 'input', type: 'text', size: '20', autocomplete: 'off', maxlength: '10'}
});
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minLengthText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the <b><tt>{@link #minLength minimum length}</tt></b> validation fails (defaults to <tt>'The minimum length for this field is {minLength}'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxLengthText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the <b><tt>{@link #maxLength maximum length}</tt></b> validation fails (defaults to <tt>'The maximum length for this field is {maxLength}'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='selectOnFocus'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to automatically select any existing field text when the field receives input focus (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='blankText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if the <b><tt>{@link #allowBlank}</tt></b> validation fails (defaults to <tt>'This field is required'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='validator'>
          <xs:annotation>
            <xs:documentation>
<p>A custom validation function to be called during field validation ({@link #validateValue}) (defaults to <tt>null</tt>). If specified, this function will be called first, allowing the developer to override the default validation process.</p><br/><p>This function will be passed the following Parameters:</p><div class="mdetail-params"><ul><li><code>value</code>: <i>Mixed</i> <div class="sub-desc">The current field value</div></li></ul></div><br/><p>This function is to Return:</p><div class="mdetail-params"><ul><li><code>true</code>: <i>Boolean</i> <div class="sub-desc"><code>true</code> if the value is valid</div></li><li><code>msg</code>: <i>String</i> <div class="sub-desc">An error message if the value is invalid</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='regex'>
          <xs:annotation>
            <xs:documentation>
A JavaScript RegExp object to be tested against the field value during validation (defaults to <tt>null</tt>). If the test fails, the field will be marked invalid using <b><tt>{@link #regexText}</tt></b>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='regexText'>
          <xs:annotation>
            <xs:documentation>
The error text to display if <b><tt>{@link #regex}</tt></b> is used and the test fails during validation (defaults to <tt>''</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyText'>
          <xs:annotation>
            <xs:documentation>
The default text to place into an empty field (defaults to <tt>null</tt>). <b>Note</b>: that this value will be submitted to the server if this field is enabled and configured with a {@link #name}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='emptyClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to apply to an empty field to style the <b><tt>{@link #emptyText}</tt></b> (defaults to <tt>'x-form-empty-field'</tt>). This class is automatically added and removed as needed depending on the current field value.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableKeyEvents'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to enable the proxying of key events for the HTML input field (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='textfield' type='ext:ext.form.TextField' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
<p>Basic text field. Can be used as a direct replacement for traditional text inputs, or as the base class for more sophisticated input controls (like {@link Ext.form.TextArea} and {@link Ext.form.ComboBox}).</p><p style="font-weight: bold"><u>Validation</u></p><p>The validation procedure is described in the documentation for {@link #validateValue}.</p><p style="font-weight: bold"><u>Alter Validation Behavior</u></p><p>Validation behavior for each field can be configured:</p><div class="mdetail-params"><ul><li><code>{@link Ext.form.TextField#invalidText invalidText}</code> : the default validation message to show if any validation step above does not provide a message when invalid</li><li><code>{@link Ext.form.TextField#maskRe maskRe}</code> : filter out keystrokes before any validation occurs</li><li><code>{@link Ext.form.TextField#stripCharsRe stripCharsRe}</code> : filter characters after being typed in, but before being validated</li><li><code>{@link Ext.form.Field#invalidClass invalidClass}</code> : alternate style when invalid</li><li><code>{@link Ext.form.Field#validateOnBlur validateOnBlur}</code>, <code>{@link Ext.form.Field#validationDelay validationDelay}</code>, and <code>{@link Ext.form.Field#validationEvent validationEvent}</code> : modify how/when validation is triggered</li></ul></div>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TriggerField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TextField'>
        <xs:all>
            <xs:element name='triggerConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <p>A {@link Ext.DomHelper DomHelper} config object specifying the structure of the trigger element for this Field. (Optional).</p><p>Specify this when you need a customized element to act as the trigger button for a TriggerField.</p><p>Note that when using this option, it is the developer's responsibility to ensure correct sizing, positioning and appearance of the trigger. Defaults to:</p><pre><code>{tag: "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass}</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='triggerClass'>
          <xs:annotation>
            <xs:documentation>
An additional CSS class used to style the trigger button. The trigger will always get the class <tt>'x-form-trigger'</tt> by default and <tt>triggerClass</tt> will be <b>appended</b> if specified.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='triggerConfig'>
          <xs:annotation>
            <xs:documentation>
<p>A {@link Ext.DomHelper DomHelper} config object specifying the structure of the trigger element for this Field. (Optional).</p><p>Specify this when you need a customized element to act as the trigger button for a TriggerField.</p><p>Note that when using this option, it is the developer's responsibility to ensure correct sizing, positioning and appearance of the trigger. Defaults to:</p><pre><code>{tag: "img", src: Ext.BLANK_IMAGE_URL, cls: "x-form-trigger " + this.triggerClass}</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideTrigger'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to hide the trigger element and display only the base text field (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='editable'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to prevent the user from typing text directly into the field, the field will only respond to a click on the trigger to set the value. (defaults to <tt>true</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='wrapFocusClass'>
          <xs:annotation>
            <xs:documentation>
The class added to the to the wrap of the trigger element. Defaults to <tt>x-trigger-wrap-focus</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='trigger' type='ext:ext.form.TriggerField' substitutionGroup='ext:textfield'>
    <xs:annotation>
      <xs:documentation>
@event autosize Fires when the <tt><b>{@link #autoSize}</b></tt> function is triggered. The field may or may not have actually changed size according to the default logic, but this event provides a hook for the developer to apply additional logic at runtime to resize the field if needed. @param {Ext.form.Field} this This text field @param {Number} width The new field width @event keydown Keydown input field event. This event only fires if <tt><b>{@link #enableKeyEvents}</b></tt> is set to true. @param {Ext.form.TextField} this This text field @param {Ext.EventObject} e @event keyup Keyup input field event. This event only fires if <tt><b>{@link #enableKeyEvents}</b></tt> is set to true. @param {Ext.form.TextField} this This text field @param {Ext.EventObject} e @event keypress Keypress input field event. This event only fires if <tt><b>{@link #enableKeyEvents}</b></tt> is set to true. @param {Ext.form.TextField} this This text field @param {Ext.EventObject} e Resets the current field value to the originally-loaded value and clears any validation messages. Also adds <tt><b>{@link #emptyText}</b></tt> and <tt><b>{@link #emptyClass}</b></tt> if the original value was blank. <p>Validates a value according to the field's validation rules and marks the field as invalid if the validation fails. Validation rules are processed in the following order:</p><div class="mdetail-params"><ul><li><b>1. Field specific validator</b> <div class="sub-desc"><p>A validator offers a way to customize and reuse a validation specification. If a field is configured with a <code>{@link #validator}</code> function, it will be passed the current field value. The <code>{@link #validator}</code> function is expected to return either:</p><div class="mdetail-params"><ul><li>Boolean <tt>true</tt> if the value is valid (validation continues).</li><li>a String to represent the invalid message if invalid (validation halts).</li></ul></div></div></li><li><b>2. Basic Validation</b> <div class="sub-desc"><p>If the <code>{@link #validator}</code> has not halted validation, basic validation proceeds as follows:</p><div class="mdetail-params"><ul><li><code>{@link #allowBlank}</code> : (Invalid message = <code>{@link #emptyText}</code>)<div class="sub-desc">Depending on the configuration of <code>{@link #allowBlank}</code>, a blank field will cause validation to halt at this step and return Boolean true or false accordingly.</div></li><li><code>{@link #minLength}</code> : (Invalid message = <code>{@link #minLengthText}</code>)<div class="sub-desc">If the passed value does not satisfy the <code>{@link #minLength}</code> specified, validation halts.</div></li><li><code>{@link #maxLength}</code> : (Invalid message = <code>{@link #maxLengthText}</code>)<div class="sub-desc">If the passed value does not satisfy the <code>{@link #maxLength}</code> specified, validation halts.</div></li></ul></div></div></li><li><b>3. Preconfigured Validation Types (VTypes)</b> <div class="sub-desc"><p>If none of the prior validation steps halts validation, a field configured with a <code>{@link #vtype}</code> will utilize the corresponding {@link Ext.form.VTypes VTypes} validation function. If invalid, either the field's <code>{@link #vtypeText}</code> or the VTypes vtype Text property will be used for the invalid message. Keystrokes on the field will be filtered according to the VTypes vtype Mask property.</p></div></li><li><b>4. Field specific regex test</b> <div class="sub-desc"><p>If none of the prior validation steps halts validation, a field's configured <code>{@link #regex}</code> test will be processed. The invalid message for this test is configured with <code>{@link #regexText}</code>.</p></div></li><li style="list-style: none">@param {Mixed} value The value to validate @return {Boolean} True if the value is valid, else false Selects text in this field @param {Number} start (optional) The index where the selection should start (defaults to 0) @param {Number} end (optional) The index where the selection should end (defaults to the text length) Automatically grows the field to accomodate the width of the text up to the maximum field width allowed. This only takes effect if <tt><b>{@link #grow}</b> = true</tt>, and fires the {@link #autosize} event. Provides a convenient wrapper for TextFields that adds a clickable trigger button (looks like a combobox by default). The trigger has no default action, so you must assign a function to implement the trigger click handler by overriding {@link #onTriggerClick}. You can create a TriggerField directly, as it renders exactly like a combobox for which you can provide a custom implementation. For example: <pre><code>var trigger = new Ext.form.TriggerField();
trigger.onTriggerClick = myTriggerFn;
trigger.applyToMarkup('my-field');
</code></pre>However, in general you will most likely want to use TriggerField as the base class for a reusable component. {@link Ext.form.DateField} and {@link Ext.form.ComboBox} are perfect examples of this.</li></ul></div>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TextArea'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TextField'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:boolean' name='preventScrollbars'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to prevent scrollbars from appearing regardless of how much text is in the field. This option is only relevant when {@link #grow} is <tt>true</tt>. Equivalent to setting overflow: hidden, defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='textarea' type='ext:ext.form.TextArea' substitutionGroup='ext:textfield'>
    <xs:annotation>
      <xs:documentation>
The function that should handle the trigger's click event. This method does nothing by default until overridden by an implementing function. See {@link Ext.form.TriggerField#onTriggerClick} for additional information. @method @param {EventObject} e The function that should handle the trigger's click event. This method does nothing by default until overridden by an implementing function. See {@link Ext.form.TriggerField#onTriggerClick} for additional information. @method @param {EventObject} e
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.NumberField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TextField'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:boolean' name='allowDecimals'>
          <xs:annotation>
            <xs:documentation>
False to disallow decimal values (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='decimalSeparator'>
          <xs:annotation>
            <xs:documentation>
Character(s) to allow as the decimal separator (defaults to '.')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='decimalPrecision'>
          <xs:annotation>
            <xs:documentation>
The maximum precision to display after the decimal separator (defaults to 2)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowNegative'>
          <xs:annotation>
            <xs:documentation>
False to prevent entering a negative sign (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum allowed value (defaults to Number.NEGATIVE_INFINITY)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum allowed value (defaults to Number.MAX_VALUE)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the minimum value validation fails (defaults to "The minimum value for this field is {minValue}")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the maximum value validation fails (defaults to "The maximum value for this field is {maxValue}")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='nanText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the value is not a valid number. For example, this can happen if a valid character like '.' or '-' is left in the field with no number (defaults to "{value} is not a valid number")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='baseChars'>
          <xs:annotation>
            <xs:documentation>
The base set of characters to evaluate as valid numbers (defaults to '0123456789').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='numberfield' type='ext:ext.form.NumberField' substitutionGroup='ext:textfield'>
    <xs:annotation>
      <xs:documentation>
Automatically grows the field to accomodate the height of the text up to the maximum field height allowed. This only takes effect if grow = true, and fires the {@link #autosize} event if the height changes.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.DateField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TriggerField'>
        <xs:all>
            <xs:element name='disabledDays' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of days to disable, 0 based (defaults to null). Some examples:<pre><code>// disable Sunday and Saturday:
disabledDays:  [0, 6]
// disable weekdays:
disabledDays: [1,2,3,4,5]
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='disabledDates' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of "dates" to disable, as strings. These strings will be used to build a dynamic regular expression so they are very powerful. Some examples:<pre><code>// disable these exact dates:
disabledDates: ["03/08/2003", "09/16/2003"]
// disable these days for every year:
disabledDates: ["03/08", "09/16"]
// only match the beginning (useful if you are using short years):
disabledDates: ["^03/08"]
// disable every day in March 2006:
disabledDates: ["03/../2006"]
// disable every day in every March:
disabledDates: ["^03"]
</code></pre>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support regular expressions, if you are using a {@link #format date format} that has "." in it, you will have to escape the dot when restricting dates. For example: <tt>["03\\.08\\.03"]</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
The default date format string which can be overriden for localization support. The format must be valid according to {@link Date#parseDate} (defaults to <tt>'m/d/Y'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='altFormats'>
          <xs:annotation>
            <xs:documentation>
Multiple date formats separated by "<tt>|</tt>" to try when parsing a user input value and it does not match the defined format (defaults to <tt>'m/d/Y|n/j/Y|n/j/y|m/j/y|n/d/y|m/j/Y|n/d/Y|m-d-y|m-d-Y|m/d|m-d|md|mdy|mdY|d|Y-m-d'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDaysText'>
          <xs:annotation>
            <xs:documentation>
The tooltip to display when the date falls on a disabled day (defaults to <tt>'Disabled'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDatesText'>
          <xs:annotation>
            <xs:documentation>
The tooltip text to display when the date falls on a disabled date (defaults to <tt>'Disabled'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the date in the cell is before <tt>{@link #minValue}</tt> (defaults to <tt>'The date in this field must be after {minValue}'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the date in the cell is after <tt>{@link #maxValue}</tt> (defaults to <tt>'The date in this field must be before {maxValue}'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='showToday'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to hide the footer area of the DatePicker containing the Today button and disable the keyboard handler for spacebar that selects the current date (defaults to <tt>true</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum allowed date. Can be either a Javascript date object or a string date in a valid format (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum allowed date. Can be either a Javascript date object or a string date in a valid format (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDays'>
          <xs:annotation>
            <xs:documentation>
An array of days to disable, 0 based (defaults to null). Some examples:<pre><code>// disable Sunday and Saturday:
disabledDays:  [0, 6]
// disable weekdays:
disabledDays: [1,2,3,4,5]
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='disabledDates'>
          <xs:annotation>
            <xs:documentation>
An array of "dates" to disable, as strings. These strings will be used to build a dynamic regular expression so they are very powerful. Some examples:<pre><code>// disable these exact dates:
disabledDates: ["03/08/2003", "09/16/2003"]
// disable these days for every year:
disabledDates: ["03/08", "09/16"]
// only match the beginning (useful if you are using short years):
disabledDates: ["^03/08"]
// disable every day in March 2006:
disabledDates: ["03/../2006"]
// disable every day in every March:
disabledDates: ["^03"]
</code></pre>Note that the format of the dates included in the array should exactly match the {@link #format} config. In order to support regular expressions, if you are using a {@link #format date format} that has "." in it, you will have to escape the dot when restricting dates. For example: <tt>["03\\.08\\.03"]</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='datefield' type='ext:ext.form.DateField' substitutionGroup='ext:trigger'>
  </xs:element>
  <xs:complexType name='ext.form.DisplayField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:boolean' name='htmlEncode'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to skip HTML-encoding the text when rendering it (defaults to <tt>false</tt>). This might be useful if you want to include tags in the field's innerHTML rather than rendering them as string literals per the default logic.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='displayfield' type='ext:ext.form.DisplayField' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
@hide @method autoSize
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.ComboBox'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.TriggerField'>
        <xs:all>
            <xs:element name='transform' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The id, DOM node or element of an existing HTML SELECT to convert to a ComboBox. Note that if you specify this and the combo is going to be in an {@link Ext.form.BasicForm} or {@link Ext.form.FormPanel}, you must also set <tt>{@link #lazyRender} = true</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The data source to which this combo is bound (defaults to <tt>undefined</tt>). Acceptable values for this property are: <div class="mdetail-params"><ul><li><b>any {@link Ext.data.Store Store} subclass</b></li><li><b>an Array</b> : Arrays will be converted to a {@link Ext.data.ArrayStore} internally, automatically generating {@link Ext.data.Field#name field names} to work with all data components. <div class="mdetail-params"><ul><li><b>1-dimensional array</b> : (e.g., <tt>['Foo','Bar']</tt>)<div class="sub-desc">A 1-dimensional array will automatically be expanded (each array item will be used for both the combo {@link #valueField} and {@link #displayField})</div></li><li><b>2-dimensional array</b> : (e.g., <tt>[['f','Foo'],['b','Bar']]</tt>)<div class="sub-desc">For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo {@link #valueField}, while the value at index 1 is assumed to be the combo {@link #displayField}.</div></li></ul></div></li></ul></div><p>See also <tt>{@link #mode}</tt>.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
                <xs:anyAttribute processContents="skip"/>
              </xs:complexType>
            </xs:element>
            <xs:element name='tpl' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The value of the match string used to filter the store. Delete this property to force a requery. Example use: <pre><code>var combo = new Ext.form.ComboBox({
...
mode: 'remote',
...
listeners: {
// delete the previous query in the beforequery event or set
// combo.lastQuery = null (this will reload the store the next time it expands)
beforequery: function(qe){
delete qe.combo.lastQuery;
}
}
});
</code></pre>To make sure the filter in the store is not cleared the first time the ComboBox trigger is used configure the combo with <tt>lastQuery=''</tt>. Example use: <pre><code>var combo = new Ext.form.ComboBox({
...
mode: 'local',
triggerAction: 'all',
lastQuery: ''
});
</code></pre>@property lastQuery @type String @event expand Fires when the dropdown list is expanded @param {Ext.form.ComboBox} combo This combo box @event collapse Fires when the dropdown list is collapsed @param {Ext.form.ComboBox} combo This combo box @event beforeselect Fires before a list item is selected. Return false to cancel the selection. @param {Ext.form.ComboBox} combo This combo box @param {Ext.data.Record} record The data record returned from the underlying store @param {Number} index The index of the selected item in the dropdown list @event select Fires when a list item is selected @param {Ext.form.ComboBox} combo This combo box @param {Ext.data.Record} record The data record returned from the underlying store @param {Number} index The index of the selected item in the dropdown list @event beforequery Fires before all queries are processed. Return false to cancel the query or set the queryEvent's cancel property to true. @param {Object} queryEvent An object that has these properties:<ul><li><code>combo</code> : Ext.form.ComboBox <div class="sub-desc">This combo box</div></li><li><code>query</code> : String <div class="sub-desc">The query</div></li><li><code>forceAll</code> : Boolean <div class="sub-desc">True to force "all" query</div></li><li><code>cancel</code> : Boolean <div class="sub-desc">Set to true to cancel the query</div></li></ul><p>The template string, or {@link Ext.XTemplate} instance to use to display each item in the dropdown list. The dropdown list is displayed in a DataView. See {@link #view}.</p><p>The default template string is:</p><pre><code>'&lt;tpl for="."&gt;&lt;div class="x-combo-list-item"&gt;{' + this.displayField + '}&lt;/div&gt;&lt;/tpl&gt;'
</code></pre><p>Override the default value to create custom UI layouts for items in the list. For example:</p><pre><code>'&lt;tpl for="."&gt;&lt;div ext:qtip="{state}. {nick}" class="x-combo-list-item"&gt;{state}&lt;/div&gt;&lt;/tpl&gt;'
</code></pre><p>The template <b>must</b> contain one or more substitution parameters using field names from the Combo's {@link #store Store}. In the example above an</p><pre>ext:qtip</pre>attribute is added to display other fields from the Store.<br/><br/> <p>To preserve the default visual look of list items, add the CSS class name</p><pre>x-combo-list-item</pre>to the template's container element.<br/><br/> <p>Also see {@link #itemSelector} for additional details.</p>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='transform'>
          <xs:annotation>
            <xs:documentation>
The id, DOM node or element of an existing HTML SELECT to convert to a ComboBox. Note that if you specify this and the combo is going to be in an {@link Ext.form.BasicForm} or {@link Ext.form.FormPanel}, you must also set <tt>{@link #lazyRender} = true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='lazyRender'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to prevent the ComboBox from rendering until requested (should always be used when rendering into an {@link Ext.Editor} (e.g. {@link Ext.grid.EditorGridPanel Grids}), defaults to <tt>false</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The data source to which this combo is bound (defaults to <tt>undefined</tt>). Acceptable values for this property are: <div class="mdetail-params"><ul><li><b>any {@link Ext.data.Store Store} subclass</b></li><li><b>an Array</b> : Arrays will be converted to a {@link Ext.data.ArrayStore} internally, automatically generating {@link Ext.data.Field#name field names} to work with all data components. <div class="mdetail-params"><ul><li><b>1-dimensional array</b> : (e.g., <tt>['Foo','Bar']</tt>)<div class="sub-desc">A 1-dimensional array will automatically be expanded (each array item will be used for both the combo {@link #valueField} and {@link #displayField})</div></li><li><b>2-dimensional array</b> : (e.g., <tt>[['f','Foo'],['b','Bar']]</tt>)<div class="sub-desc">For a multi-dimensional array, the value in index 0 of each item will be assumed to be the combo {@link #valueField}, while the value at index 1 is assumed to be the combo {@link #displayField}.</div></li></ul></div></li></ul></div><p>See also <tt>{@link #mode}</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='title'>
          <xs:annotation>
            <xs:documentation>
If supplied, a header element is created containing this text and added into the top of the dropdown list (defaults to undefined, with no header element)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='listWidth'>
          <xs:annotation>
            <xs:documentation>
The width (used as a parameter to {@link Ext.Element#setWidth}) of the dropdown list (defaults to the width of the ComboBox field). See also <tt>{@link #minListWidth}</tt>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='displayField'>
          <xs:annotation>
            <xs:documentation>
The underlying {@link Ext.data.Field#name data field name} to bind to this ComboBox (defaults to undefined if <tt>{@link #mode} = 'remote'</tt> or <tt>'field1'</tt> if {@link #transform transforming a select} or if the {@link #store field name is autogenerated based on the store configuration}). <p>See also <tt>{@link #valueField}</tt>.</p><p><b>Note</b>: if using a ComboBox in an {@link Ext.grid.EditorGridPanel Editor Grid} a {@link Ext.grid.Column#renderer renderer} will be needed to show the displayField when the editor is not active.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='valueField'>
          <xs:annotation>
            <xs:documentation>
The underlying {@link Ext.data.Field#name data value name} to bind to this ComboBox (defaults to undefined if <tt>{@link #mode} = 'remote'</tt> or <tt>'field2'</tt> if {@link #transform transforming a select} or if the {@link #store field name is autogenerated based on the store configuration}). <p><b>Note</b>: use of a <tt>valueField</tt> requires the user to make a selection in order for a value to be mapped. See also <tt>{@link #hiddenName}</tt>, <tt>{@link #hiddenValue}</tt>, and <tt>{@link #displayField}</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hiddenName'>
          <xs:annotation>
            <xs:documentation>
If specified, a hidden form field with this name is dynamically generated to store the field's data value (defaults to the underlying DOM element's name). Required for the combo's value to automatically post during a form submission. See also {@link #valueField}. <p><b>Note</b>: the hidden field's id will also default to this name if {@link #hiddenId} is not specified. The ComboBox {@link Ext.Component#id id} and the <tt>{@link #hiddenId}</tt> <b>should be different</b>, since no two DOM nodes should share the same id. So, if the ComboBox <tt>{@link Ext.form.Field#name name}</tt> and <tt>hiddenName</tt> are the same, you should specify a unique <tt>{@link #hiddenId}</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hiddenId'>
          <xs:annotation>
            <xs:documentation>
If <tt>{@link #hiddenName}</tt> is specified, <tt>hiddenId</tt> can also be provided to give the hidden field a unique id (defaults to the <tt>{@link #hiddenName}</tt>). The <tt>hiddenId</tt> and combo {@link Ext.Component#id id} should be different, since no two DOM nodes should share the same id.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='hiddenValue'>
          <xs:annotation>
            <xs:documentation>
Sets the initial value of the hidden field if {@link #hiddenName} is specified to contain the selected {@link #valueField}, from the Store. Defaults to the configured <tt>{@link Ext.form.Field#value value}</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='listClass'>
          <xs:annotation>
            <xs:documentation>
The CSS class to add to the predefined <tt>'x-combo-list'</tt> class applied the dropdown list element (defaults to '').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selectedClass'>
          <xs:annotation>
            <xs:documentation>
CSS class to apply to the selected item in the dropdown list (defaults to <tt>'x-combo-selected'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='listEmptyText'>
          <xs:annotation>
            <xs:documentation>
The empty text to display in the data view if no items are found. (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='shadow'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> or <tt>"sides"</tt> for the default effect, <tt>"frame"</tt> for 4-way shadow, and <tt>"drop"</tt> for bottom-right
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='listAlign'>
          <xs:annotation>
            <xs:documentation>
A valid anchor position value. See <tt>{@link Ext.Element#alignTo}</tt> for details on supported anchor positions (defaults to <tt>'tl-bl?'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxHeight'>
          <xs:annotation>
            <xs:documentation>
The maximum height in pixels of the dropdown list before scrollbars are shown (defaults to <tt>300</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minHeight'>
          <xs:annotation>
            <xs:documentation>
The minimum height in pixels of the dropdown list when the list is constrained by its distance to the viewport edges (defaults to <tt>90</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='triggerAction'>
          <xs:annotation>
            <xs:documentation>
The action to execute when the trigger is clicked. <div class="mdetail-params"><ul><li><b><tt>'query'</tt></b> : <b>Default</b> <p class="sub-desc">{@link #doQuery run the query} using the {@link Ext.form.Field#getRawValue raw value}.</p></li><li><b><tt>'all'</tt></b> : <p class="sub-desc">{@link #doQuery run the query} specified by the <tt>{@link #allQuery}</tt> config option</p></li></ul></div><p>See also <code>{@link #queryParam}</code>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minChars'>
          <xs:annotation>
            <xs:documentation>
The minimum number of characters the user must type before autocomplete and {@link #typeAhead} activate (defaults to <tt>4</tt> if <tt>{@link #mode} = 'remote'</tt> or <tt>0</tt> if <tt>{@link #mode} = 'local'</tt>, does not apply if <tt>{@link Ext.form.TriggerField#editable editable} = false</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='typeAhead'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to populate and autoselect the remainder of the text being typed after a configurable delay ({@link #typeAheadDelay}) if it matches a known value (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='queryDelay'>
          <xs:annotation>
            <xs:documentation>
The length of time in milliseconds to delay between the start of typing and sending the query to filter the dropdown list (defaults to <tt>500</tt> if <tt>{@link #mode} = 'remote'</tt> or <tt>10</tt> if <tt>{@link #mode} = 'local'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='pageSize'>
          <xs:annotation>
            <xs:documentation>
If greater than <tt>0</tt>, a {@link Ext.PagingToolbar} is displayed in the footer of the dropdown list and the {@link #doQuery filter queries} will execute with page start and {@link Ext.PagingToolbar#pageSize limit} parameters. Only applies when <tt>{@link #mode} = 'remote'</tt> (defaults to <tt>0</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='queryParam'>
          <xs:annotation>
            <xs:documentation>
Name of the query ({@link Ext.data.Store#baseParam baseParam} name for the store) as it will be passed on the querystring (defaults to <tt>'query'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loadingText'>
          <xs:annotation>
            <xs:documentation>
The text to display in the dropdown list while data is loading. Only applies when <tt>{@link #mode} = 'remote'</tt> (defaults to <tt>'Loading...'</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='resizable'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to add a resize handle to the bottom of the dropdown list (creates an {@link Ext.Resizable} with 'se' {@link Ext.Resizable#pinned pinned} handles). Defaults to <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='handleHeight'>
          <xs:annotation>
            <xs:documentation>
The height in pixels of the dropdown list resize handle if <tt>{@link #resizable} = true</tt> (defaults to <tt>8</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='allQuery'>
          <xs:annotation>
            <xs:documentation>
The text query to send to the server to return all records for the list with no filtering (defaults to '')
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='mode'>
          <xs:annotation>
            <xs:documentation>
Acceptable values are: <div class="mdetail-params"><ul><li><b><tt>'remote'</tt></b> : <b>Default</b> <p class="sub-desc">Automatically loads the <tt>{@link #store}</tt> the <b>first</b> time the trigger is clicked. If you do not want the store to be automatically loaded the first time the trigger is clicked, set to <tt>'local'</tt> and manually load the store. To force a requery of the store <b>every</b> time the trigger is clicked see <tt>{@link #lastQuery}</tt>.</p></li><li><b><tt>'local'</tt></b> : <p class="sub-desc">ComboBox loads local data</p><pre><code>var combo = new Ext.form.ComboBox({
renderTo: document.body,
mode: 'local',
store: new Ext.data.ArrayStore({
id: 0,
fields: [
'myId',  // numeric value is the key
'displayText'
],
data: [[1, 'item1'], [2, 'item2']]  // data is local
}),
valueField: 'myId',
displayField: 'displayText',
triggerAction: 'all'
});
</code></pre></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minListWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width of the dropdown list in pixels (defaults to <tt>70</tt>, will be ignored if <tt>{@link #listWidth}</tt> has a higher value)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='forceSelection'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to restrict the selected value to one of the values in the list, <tt>false</tt> to allow the user to set arbitrary text into the field (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='typeAheadDelay'>
          <xs:annotation>
            <xs:documentation>
The length of time in milliseconds to wait until the typeahead text is displayed if <tt>{@link #typeAhead} = true</tt> (defaults to <tt>250</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='valueNotFoundText'>
          <xs:annotation>
            <xs:documentation>
When using a name/value combo, if the value passed to setValue is not found in the store, valueNotFoundText will be displayed as the field text if defined (defaults to undefined). If this default text is used, it means there is no value set and no validation will occur on this field.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='lazyInit'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to not initialize the list for this combo until the field is focused (defaults to <tt>true</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='tpl'>
          <xs:annotation>
            <xs:documentation>
The value of the match string used to filter the store. Delete this property to force a requery. Example use: <pre><code>var combo = new Ext.form.ComboBox({
...
mode: 'remote',
...
listeners: {
// delete the previous query in the beforequery event or set
// combo.lastQuery = null (this will reload the store the next time it expands)
beforequery: function(qe){
delete qe.combo.lastQuery;
}
}
});
</code></pre>To make sure the filter in the store is not cleared the first time the ComboBox trigger is used configure the combo with <tt>lastQuery=''</tt>. Example use: <pre><code>var combo = new Ext.form.ComboBox({
...
mode: 'local',
triggerAction: 'all',
lastQuery: ''
});
</code></pre>@property lastQuery @type String @event expand Fires when the dropdown list is expanded @param {Ext.form.ComboBox} combo This combo box @event collapse Fires when the dropdown list is collapsed @param {Ext.form.ComboBox} combo This combo box @event beforeselect Fires before a list item is selected. Return false to cancel the selection. @param {Ext.form.ComboBox} combo This combo box @param {Ext.data.Record} record The data record returned from the underlying store @param {Number} index The index of the selected item in the dropdown list @event select Fires when a list item is selected @param {Ext.form.ComboBox} combo This combo box @param {Ext.data.Record} record The data record returned from the underlying store @param {Number} index The index of the selected item in the dropdown list @event beforequery Fires before all queries are processed. Return false to cancel the query or set the queryEvent's cancel property to true. @param {Object} queryEvent An object that has these properties:<ul><li><code>combo</code> : Ext.form.ComboBox <div class="sub-desc">This combo box</div></li><li><code>query</code> : String <div class="sub-desc">The query</div></li><li><code>forceAll</code> : Boolean <div class="sub-desc">True to force "all" query</div></li><li><code>cancel</code> : Boolean <div class="sub-desc">Set to true to cancel the query</div></li></ul><p>The template string, or {@link Ext.XTemplate} instance to use to display each item in the dropdown list. The dropdown list is displayed in a DataView. See {@link #view}.</p><p>The default template string is:</p><pre><code>'&lt;tpl for="."&gt;&lt;div class="x-combo-list-item"&gt;{' + this.displayField + '}&lt;/div&gt;&lt;/tpl&gt;'
</code></pre><p>Override the default value to create custom UI layouts for items in the list. For example:</p><pre><code>'&lt;tpl for="."&gt;&lt;div ext:qtip="{state}. {nick}" class="x-combo-list-item"&gt;{state}&lt;/div&gt;&lt;/tpl&gt;'
</code></pre><p>The template <b>must</b> contain one or more substitution parameters using field names from the Combo's {@link #store Store}. In the example above an</p><pre>ext:qtip</pre>attribute is added to display other fields from the Store.<br/><br/> <p>To preserve the default visual look of list items, add the CSS class name</p><pre>x-combo-list-item</pre>to the template's container element.<br/><br/> <p>Also see {@link #itemSelector} for additional details.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='itemSelector'>
          <xs:annotation>
            <xs:documentation>
<p>A simple CSS selector (e.g. div.some-class or span:first-child) that will be used to determine what nodes the {@link #view Ext.DataView} which handles the dropdown display will be working with.</p><p><b>Note</b>: this setting is <b>required</b> if a custom XTemplate has been specified in {@link #tpl} which assigns a class other than</p><pre>'x-combo-list-item'</pre>to dropdown list items
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='combo' type='ext:ext.form.ComboBox' substitutionGroup='ext:trigger'>
    <xs:annotation>
      <xs:documentation>
<p>A combobox control with support for autocomplete, remote-loading, paging and many other features.</p><p>A ComboBox works in a similar manner to a traditional HTML &lt;select&gt; field. The difference is that to submit the {@link #valueField}, you must specify a {@link #hiddenName} to create a hidden input field to hold the value of the valueField. The <i>{@link #displayField}</i> is shown in the text field which is named according to the {@link #name}.</p><p style="font-weight: bold"><u>Events</u></p><p>To do something when something in ComboBox is selected, configure the select event:</p><pre><code>var cb = new Ext.form.ComboBox({
// all of your config options
listeners:{
scope: yourScope,
'select': yourFunction
}
});

// Alternatively, you can assign events after the object is created:
var cb = new Ext.form.ComboBox(yourOptions);
cb.on('select', yourFunction, yourScope);
</code></pre><br/><br/> <p style="font-weight: bold"><u>ComboBox in Grid</u></p><p>If using a ComboBox in an {@link Ext.grid.EditorGridPanel Editor Grid} a {@link Ext.grid.Column#renderer renderer} will be needed to show the displayField when the editor is not active. Set up the renderer manually, or implement a reusable render, for example:</p><pre><code>// create reusable renderer
Ext.util.Format.comboRenderer = function(combo){
return function(value){
var record = combo.findRecord(combo.{@link #valueField}, value);
return record ? record.get(combo.{@link #displayField}) : combo.{@link #valueNotFoundText};
}
}

// create the combo instance
var combo = new Ext.form.ComboBox({
{@link #typeAhead}: true,
{@link #triggerAction}: 'all',
{@link #lazyRender}:true,
{@link #mode}: 'local',
{@link #store}: new Ext.data.ArrayStore({
id: 0,
fields: [
'myId',
'displayText'
],
data: [[1, 'item1'], [2, 'item2']]
}),
{@link #valueField}: 'myId',
{@link #displayField}: 'displayText'
});

// snippet of column model used within grid
var cm = new Ext.grid.ColumnModel([{
...
},{
header: "Some Header",
dataIndex: 'whatever',
width: 130,
editor: combo, // specify reference to combo instance
renderer: Ext.util.Format.comboRenderer(combo) // pass combo instance to reusable renderer
},
...
]);
</code></pre><br/><br/> <p style="font-weight: bold"><u>Filtering</u></p><p>A ComboBox {@link #doQuery uses filtering itself}, for information about filtering the ComboBox store manually see <tt>{@link #lastQuery}</tt>.</p>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Checkbox'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:all>
            <xs:element name='handler' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A function called when the {@link #checked} value changes (can be used instead of handling the check event). The handler is passed the following parameters: <div class="mdetail-params"><ul><li><b>checkbox</b> : Ext.form.Checkbox<div class="sub-desc">The Checkbox being toggled.</div></li><li><b>checked</b> : Boolean<div class="sub-desc">The new checked state of the checkbox.</div></li></ul></div>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='scope' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An object to use as the scope ('this' reference) of the {@link #handler} function (defaults to this Checkbox).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:boolean' name='checked'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> if the checkbox should render initially checked (defaults to <tt>false</tt>)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='boxLabel'>
          <xs:annotation>
            <xs:documentation>
The text that appears beside the checkbox
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='inputValue'>
          <xs:annotation>
            <xs:documentation>
The value that should go into the generated input element's value attribute
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='handler'>
          <xs:annotation>
            <xs:documentation>
A function called when the {@link #checked} value changes (can be used instead of handling the check event). The handler is passed the following parameters: <div class="mdetail-params"><ul><li><b>checkbox</b> : Ext.form.Checkbox<div class="sub-desc">The Checkbox being toggled.</div></li><li><b>checked</b> : Boolean<div class="sub-desc">The new checked state of the checkbox.</div></li></ul></div>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='scope'>
          <xs:annotation>
            <xs:documentation>
An object to use as the scope ('this' reference) of the {@link #handler} function (defaults to this Checkbox).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='checkbox' type='ext:ext.form.Checkbox' substitutionGroup='ext:field'>
  </xs:element>
  <xs:complexType name='ext.form.CheckboxGroup'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:all>
            <xs:element name='items' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An Array of {@link Ext.form.Checkbox Checkbox}es or Checkbox config objects to arrange in the group.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='columns' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Specifies the number of columns to use when displaying grouped checkbox/radio controls using automatic layout. This config can take several types of values: <ul><li><b>'auto'</b> : <p class="sub-desc">The controls will be rendered one per column on one row and the width of each column will be evenly distributed based on the width of the overall field container. This is the default.</p></li><li><b>Number</b> : <p class="sub-desc">If you specific a number (e.g., 3) that number of columns will be created and the contained controls will be automatically distributed based on the value of {@link #vertical}.</p></li><li><b>Array</b> : Object<p class="sub-desc">You can also specify an array of column widths, mixing integer (fixed width) and float (percentage width) values as needed (e.g., [100, .25, .75]). Any integer values will be rendered first, then any float values will be calculated as a percentage of the remaining space. Float values do not have to add up to 1 (100%) although if you want the controls to take up the entire field container you should do so.</p></li></ul>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='items'>
          <xs:annotation>
            <xs:documentation>
An Array of {@link Ext.form.Checkbox Checkbox}es or Checkbox config objects to arrange in the group.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columns'>
          <xs:annotation>
            <xs:documentation>
Specifies the number of columns to use when displaying grouped checkbox/radio controls using automatic layout. This config can take several types of values: <ul><li><b>'auto'</b> : <p class="sub-desc">The controls will be rendered one per column on one row and the width of each column will be evenly distributed based on the width of the overall field container. This is the default.</p></li><li><b>Number</b> : <p class="sub-desc">If you specific a number (e.g., 3) that number of columns will be created and the contained controls will be automatically distributed based on the value of {@link #vertical}.</p></li><li><b>Array</b> : Object<p class="sub-desc">You can also specify an array of column widths, mixing integer (fixed width) and float (percentage width) values as needed (e.g., [100, .25, .75]). Any integer values will be rendered first, then any float values will be calculated as a percentage of the remaining space. Float values do not have to add up to 1 (100%) although if you want the controls to take up the entire field container you should do so.</p></li></ul>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='vertical'>
          <xs:annotation>
            <xs:documentation>
True to distribute contained controls across columns, completely filling each column top to bottom before starting on the next column. The number of controls in each column will be automatically calculated to keep columns as even as possible. The default value is false, so that controls will be added to columns one at a time, completely filling each row left to right before starting on the next row.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='allowBlank'>
          <xs:annotation>
            <xs:documentation>
False to validate that at least one item in the group is checked (defaults to true). If no items are selected at validation time, {@link @blankText} will be used as the error text.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='blankText'>
          <xs:annotation>
            <xs:documentation>
Error text to display if the {@link #allowBlank} validation fails (defaults to "You must select at least one item in this group")
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='checkboxgroup' type='ext:ext.form.CheckboxGroup' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
@event check Fires when the checkbox is checked or unchecked. @param {Ext.form.Checkbox} this This checkbox @param {Boolean} checked The new checked value @hide Overridden and disabled. The editor element does not support standard valid/invalid marking. @method @hide Overridden and disabled. The editor element does not support standard valid/invalid marking. @method Returns the checked state of the checkbox. @return {Boolean} True if checked, else false Sets the checked state of the checkbox, fires the 'check' event, and calls a <code>{@link #handler}</code> (if configured). @param {Boolean/String} checked The following values will check the checkbox: <code>true, 'true', '1', or 'on'</code>. Any other value will uncheck the checkbox. @return {Ext.form.Field} this <p>A grouping container for {@link Ext.form.Checkbox} controls.</p><p>Sample usage:</p><pre><code>var myCheckboxGroup = new Ext.form.CheckboxGroup({
id:'myGroup',
xtype: 'checkboxgroup',
fieldLabel: 'Single Column',
itemCls: 'x-check-group-alt',
// Put all controls in a single column with width 100%
columns: 1,
items: [
{boxLabel: 'Item 1', name: 'cb-col-1'},
{boxLabel: 'Item 2', name: 'cb-col-2', checked: true},
{boxLabel: 'Item 3', name: 'cb-col-3'}
]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Radio'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Checkbox'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='radio' type='ext:ext.form.Radio' substitutionGroup='ext:checkbox'>
    <xs:annotation>
      <xs:documentation>
@method getRawValue @hide @method setRawValue @hide Single radio field. Same as Checkbox, but provided as a convenience for automatically setting the input type. Radio grouping is handled automatically by the browser if you give each radio in a group the same name.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.RadioGroup'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.CheckboxGroup'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='radiogroup' type='ext:ext.form.RadioGroup' substitutionGroup='ext:checkboxgroup'>
    <xs:annotation>
      <xs:documentation>
Overridden and disabled. The editor element does not support standard valid/invalid marking. @hide @method Overridden and disabled. The editor element does not support standard valid/invalid marking. @hide @method If this radio is part of a group, it will return the selected value @return {String} Sets either the checked/unchecked status of this Radio, or, if a string value is passed, checks a sibling Radio of the same name whose value is the value specified. @param value {String/Boolean} Checked value, or the value of the sibling radio button to check. @return {Ext.form.Field} this A grouping container for {@link Ext.form.Radio} controls.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Hidden'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:all>
        </xs:all>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='hidden' type='ext:ext.form.Hidden' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
@event change Fires when the state of a child radio changes. @param {Ext.form.RadioGroup} this @param {Ext.form.Radio} checked The checked radio Gets the selected {@link Ext.form.Radio} in the group, if it exists. @return {Ext.form.Radio} The selected radio. Sets the checked radio in the group. @param {String/Ext.form.Radio} id The radio to check. @param {Boolean} value The value to set the radio. @return {Ext.form.RadioGroup} this A basic hidden field for storing hidden values in forms that need to be passed in the form submit.
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.FormPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:string' name='formId'>
          <xs:annotation>
            <xs:documentation>
(optional) The id of the FORM tag (defaults to an auto-generated id).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideLabels'>
          <xs:annotation>
            <xs:documentation>
<p><tt>true</tt> to hide field labels by default (sets <tt>display:none</tt>). Defaults to <tt>false</tt>.</p><p>Also see {@link Ext.Component}.<tt>{@link Ext.Component#hideLabel hideLabel}</tt>.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='labelPad'>
          <xs:annotation>
            <xs:documentation>
The default padding in pixels for field labels (defaults to <tt>5</tt>). <tt>labelPad</tt> only applies if <tt>{@link #labelWidth}</tt> is also specified, otherwise it will be ignored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='labelWidth'>
          <xs:annotation>
            <xs:documentation>
The width of labels in pixels. This property cascades to child containers and can be overridden on any child container (e.g., a fieldset can specify a different <tt>labelWidth</tt> for its fields) (defaults to <tt>100</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='labelAlign'>
          <xs:annotation>
            <xs:documentation>
The label alignment value used for the <tt>text-align</tt> specification for the <b>container</b>. Valid values are <tt>"left</tt>", <tt>"top"</tt> or <tt>"right"</tt> (defaults to <tt>"left"</tt>). This property cascades to child <b>containers</b> and can be overridden on any child <b>container</b> (e.g., a fieldset can specify a different <tt>labelAlign</tt> for its fields).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='monitorValid'>
          <xs:annotation>
            <xs:documentation>
If <tt>true</tt>, the form monitors its valid state <b>client-side</b> and regularly fires the {@link #clientvalidation} event passing that state.<br/><p>When monitoring valid state, the FormPanel enables/disables any of its configured {@link #buttons} which have been configured with <code>formBind: true</code> depending on whether the {@link Ext.form.BasicForm#isValid form is valid} or not. Defaults to <tt>false</tt></p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='monitorPoll'>
          <xs:annotation>
            <xs:documentation>
The milliseconds to poll valid state, ignored if monitorValid is not true (defaults to 200)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='form' type='ext:ext.form.FormPanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
By default wait messages are displayed with Ext.MessageBox.wait. You can target a specific element by passing it or its id or mask the form itself by passing in true. @type Mixed @property waitMsgTarget Get the HTML form Element @return Ext.Element Returns true if client-side validation on the form is successful. @return Boolean <p>Returns true if any fields in this form have changed from their original values.</p><p>Note that if this BasicForm was configured with {@link #trackResetOnLoad} then the Fields' <i>original values</i> are updated when the values are loaded by {@link #setValues} or {@link #loadRecord}.</p>@return Boolean Performs a predefined action ({@link Ext.form.Action.Submit} or {@link Ext.form.Action.Load}) or a custom extension of {@link Ext.form.Action} to perform application-specific processing. @param {String/Object} actionName The name of the predefined action type, or instance of {@link Ext.form.Action} to perform. @param {Object} options (optional) The options to pass to the {@link Ext.form.Action}. All of the config options listed below are supported by both the {@link Ext.form.Action.Submit submit} and {@link Ext.form.Action.Load load} actions unless otherwise noted (custom actions could also accept other config options):<ul><li><b>url</b> : String<div class="sub-desc">The url for the action (defaults to the form's {@link #url}.)</div></li><li><b>method</b> : String<div class="sub-desc">The form method to use (defaults to the form's method, or POST if not defined)</div></li><li><b>params</b> : String/Object<div class="sub-desc"><p>The params to pass (defaults to the form's baseParams, or none if not defined)</p><p>Parameters are encoded as standard HTTP parameters using {@link Ext#urlEncode}.</p></div></li><li><b>headers</b> : Object<div class="sub-desc">Request headers to set for the action (defaults to the form's default headers)</div></li><li><b>success</b> : Function<div class="sub-desc">The callback that will be invoked after a successful response (see top of {@link Ext.form.Action.Submit submit} and {@link Ext.form.Action.Load load} for a description of what constitutes a successful response). The function is passed the following parameters:<ul><li><tt>form</tt> : Ext.form.BasicForm<div class="sub-desc">The form that requested the action</div></li><li><tt>action</tt> : The {@link Ext.form.Action Action} object which performed the operation. <div class="sub-desc">The action object contains these properties of interest:<ul><li><tt>{@link Ext.form.Action#response response}</tt></li><li><tt>{@link Ext.form.Action#result result}</tt> : interrogate for custom postprocessing</li><li><tt>{@link Ext.form.Action#type type}</tt></li></ul></div></li></ul></div></li><li><b>failure</b> : Function<div class="sub-desc">The callback that will be invoked after a failed transaction attempt. The function is passed the following parameters:<ul><li><tt>form</tt> : The {@link Ext.form.BasicForm} that requested the action.</li><li><tt>action</tt> : The {@link Ext.form.Action Action} object which performed the operation. <div class="sub-desc">The action object contains these properties of interest:<ul><li><tt>{@link Ext.form.Action#failureType failureType}</tt></li><li><tt>{@link Ext.form.Action#response response}</tt></li><li><tt>{@link Ext.form.Action#result result}</tt> : interrogate for custom postprocessing</li><li><tt>{@link Ext.form.Action#type type}</tt></li></ul></div></li></ul></div></li><li><b>scope</b> : Object<div class="sub-desc">The scope in which to call the callback functions (The <tt>this</tt> reference for the callback functions).</div></li><li><b>clientValidation</b> : Boolean<div class="sub-desc">Submit Action only. Determines whether a Form's fields are validated in a final call to {@link Ext.form.BasicForm#isValid isValid} prior to submission. Set to <tt>false</tt> to prevent this. If undefined, pre-submission field validation is performed.</div></li></ul>@return {BasicForm} this Shortcut to {@link #doAction do} a {@link Ext.form.Action.Submit submit action}. @param {Object} options The options to pass to the action (see {@link #doAction} for details).<br/><p><b>Note:</b> this is ignored when using the {@link #standardSubmit} option.</p><p>The following code:</p><pre><code>myFormPanel.getForm().submit({
clientValidation: true,
url: 'updateConsignment.php',
params: {
newStatus: 'delivered'
},
success: function(form, action) {
Ext.Msg.alert('Success', action.result.msg);
},
failure: function(form, action) {
switch (action.failureType) {
case Ext.form.Action.CLIENT_INVALID:
Ext.Msg.alert('Failure', 'Form fields may not be submitted with invalid values');
break;
case Ext.form.Action.CONNECT_FAILURE:
Ext.Msg.alert('Failure', 'Ajax communication failed');
break;
case Ext.form.Action.SERVER_INVALID:
Ext.Msg.alert('Failure', action.result.msg);
}
}
});
</code></pre>would process the following server response for a successful submission:<pre><code>{
"success":true, // note this is Boolean, not string
"msg":"Consignment updated"
}
</code></pre>and the following server response for a failed submission:<pre><code>{
"success":false, // note this is Boolean, not string
"msg":"You do not have permission to perform this operation"
}
</code></pre>@return {BasicForm} this Shortcut to {@link #doAction do} a {@link Ext.form.Action.Load load action}. @param {Object} options The options to pass to the action (see {@link #doAction} for details) @return {BasicForm} this Persists the values in this form into the passed {@link Ext.data.Record} object in a beginEdit/endEdit block. @param {Record} record The record to edit @return {BasicForm} this Loads an {@link Ext.data.Record} into this form by calling {@link #setValues} with the {@link Ext.data.Record#data record data}. See also {@link #trackResetOnLoad}. @param {Record} record The record to load @return {BasicForm} this Find a {@link Ext.form.Field} in this form. @param {String} id The value to search for (specify either a {@link Ext.Component#id id}, {@link Ext.grid.Column#dataIndex dataIndex}, {@link Ext.form.Field#getName name or hiddenName}). @return Field Mark fields in this form invalid in bulk. @param {Array/Object} errors Either an array in the form [{id:'fieldId', msg:'The message'},...] or an object hash of {id: msg, id2: msg2} @return {BasicForm} this Set values for fields in this form in bulk. @param {Array/Object} values Either an array in the form:<pre><code>[{id:'clientName', value:'Fred. Olsen Lines'},
{id:'portOfLoading', value:'FXT'},
{id:'portOfDischarge', value:'OSL'} ]</code></pre>or an object hash of the form:<pre><code>{
clientName: 'Fred. Olsen Lines',
portOfLoading: 'FXT',
portOfDischarge: 'OSL'
}</code></pre>@return {BasicForm} this <p>Returns the fields in this form as an object with key/value pairs as they would be submitted using a standard form submit. If multiple fields exist with the same name they are returned as an array.</p><p><b>Note:</b> The values are collected from all enabled HTML input elements within the form, <u>not</u> from the Ext Field objects. This means that all returned values are Strings (or Arrays of Strings) and that the value can potentially be the emptyText of a field.</p>@param {Boolean} asString (optional) Pass true to return the values as a string. (defaults to false, returning an Object) @return {String/Object} Clears all invalid messages in this form. @return {BasicForm} this Resets this form. @return {BasicForm} this Add Ext.form Components to this form's Collection. This does not result in rendering of the passed Component, it just enables the form to validate Fields, and distribute values to Fields. <p style="font-weight: bold">You will not usually call this function. In order to be rendered, a Field must be added to a {@link Ext.Container Container}, usually an {@link Ext.form.FormPanel FormPanel}. The FormPanel to which the field is added takes care of adding the Field to the BasicForm's collection.</p>@param {Field} field1 @param {Field} field2 (optional) @param {Field} etc (optional) @return {BasicForm} this Removes a field from the items collection (does NOT remove its markup). @param {Field} field @return {BasicForm} this Iterates through the {@link Ext.form.Field Field}s which have been {@link #add add}ed to this BasicForm, checks them for an id attribute, and calls {@link Ext.form.Field#applyToMarkup} on the existing dom element with that id. @return {BasicForm} this Calls {@link Ext#apply} for all fields in this form with the passed object. @param {Object} values @return {BasicForm} this Calls {@link Ext#applyIf} for all field in this form with the passed object. @param {Object} values @return {BasicForm} this
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.FieldSet'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:all>
            <xs:element name='checkboxToggle' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    <tt>true</tt> to render a checkbox into the fieldset frame just in front of the legend to expand/collapse the fieldset when the checkbox is toggled. (defaults to <tt>false</tt>). <p>A {@link Ext.DomHelper DomHelper} element spec may also be specified to create the checkbox. If <tt>true</tt> is specified, the default DomHelper config object used to create the element is:</p><pre><code>{tag: 'input', type: 'checkbox', name: this.checkboxName || this.id+'-checkbox'}
</code></pre>
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='checkboxToggle'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to render a checkbox into the fieldset frame just in front of the legend to expand/collapse the fieldset when the checkbox is toggled. (defaults to <tt>false</tt>). <p>A {@link Ext.DomHelper DomHelper} element spec may also be specified to create the checkbox. If <tt>true</tt> is specified, the default DomHelper config object used to create the element is:</p><pre><code>{tag: 'input', type: 'checkbox', name: this.checkboxName || this.id+'-checkbox'}
</code></pre>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='checkboxName'>
          <xs:annotation>
            <xs:documentation>
The name to assign to the fieldset's checkbox if <tt>{@link #checkboxToggle} = true</tt> (defaults to <tt>'[checkbox id]-checkbox'</tt>).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='labelWidth'>
          <xs:annotation>
            <xs:documentation>
The width of labels. This property cascades to child containers.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='fieldset' type='ext:ext.form.FieldSet' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
@event clientvalidation If the monitorValid config option is true, this event fires repetitively to notify of valid state @param {Ext.form.FormPanel} this @param {Boolean} valid true if the form has passed client-side validation Provides access to the {@link Ext.form.BasicForm Form} which this Panel contains. @return {Ext.form.BasicForm} The {@link Ext.form.BasicForm Form} which this Panel contains. Starts monitoring of the valid state of this form. Usually this is done by passing the config option "monitorValid" Stops monitoring of the valid state of this form This is a proxy for the underlying BasicForm's {@link Ext.form.BasicForm#load} call. @param {Object} options The options to pass to the action (see {@link Ext.form.BasicForm#doAction} for details) Standard container used for grouping items within a {@link Ext.form.FormPanel form}. <pre><code>var form = new Ext.FormPanel({
title: 'Simple Form with FieldSets',
labelWidth: 75, // label settings here cascade unless overridden
url: 'save-form.php',
frame:true,
bodyStyle:'padding:5px 5px 0',
width: 700,
renderTo: document.body,
layout:'column', // arrange items in columns
defaults: {      // defaults applied to items
layout: 'form',
border: false,
bodyStyle: 'padding:4px'
},
items: [{
// Fieldset in Column 1
xtype:'fieldset',
columnWidth: 0.5,
title: 'Fieldset 1',
collapsible: true,
autoHeight:true,
defaults: {
anchor: '-20' // leave room for error icon
},
defaultType: 'textfield',
items :[{
fieldLabel: 'Field 1'
}, {
fieldLabel: 'Field 2'
}, {
fieldLabel: 'Field 3'
}
]
},{
// Fieldset in Column 2 - Panel inside
xtype:'fieldset',
title: 'Show Panel', // title, header, or checkboxToggle creates fieldset header
autoHeight:true,
columnWidth: 0.5,
checkboxToggle: true,
collapsed: true, // fieldset initially collapsed
layout:'anchor',
items :[{
xtype: 'panel',
anchor: '100%',
title: 'Panel inside a fieldset',
frame: true,
height: 100
}]
}]
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.HtmlEditor'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.Field'>
        <xs:all>
            <xs:element name='fontFamilies' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of available font families
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:boolean' name='enableFormat'>
          <xs:annotation>
            <xs:documentation>
Enable the bold, italic and underline buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableFontSize'>
          <xs:annotation>
            <xs:documentation>
Enable the increase/decrease font size buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColors'>
          <xs:annotation>
            <xs:documentation>
Enable the fore/highlight color buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableAlignments'>
          <xs:annotation>
            <xs:documentation>
Enable the left, center, right alignment buttons (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableLists'>
          <xs:annotation>
            <xs:documentation>
Enable the bullet and numbered list buttons. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableSourceEdit'>
          <xs:annotation>
            <xs:documentation>
Enable the switch to source edit button. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableLinks'>
          <xs:annotation>
            <xs:documentation>
Enable the create link button. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableFont'>
          <xs:annotation>
            <xs:documentation>
Enable font selection. Not available in Safari. (defaults to true)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='createLinkText'>
          <xs:annotation>
            <xs:documentation>
The default text for the create link prompt
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultLinkValue'>
          <xs:annotation>
            <xs:documentation>
The default value for the create link prompt (defaults to http:/ /)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='fontFamilies'>
          <xs:annotation>
            <xs:documentation>
An array of available font families
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='defaultValue'>
          <xs:annotation>
            <xs:documentation>
A default value to be put into the editor to resolve focus issues (defaults to ​ (Zero-width space),   (Non-breaking space) in Opera and IE6).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='htmleditor' type='ext:ext.form.HtmlEditor' substitutionGroup='ext:field'>
    <xs:annotation>
      <xs:documentation>
@property header @hide @property footer @hide @method focus @hide @method getBottomToolbar @hide @method getTopToolbar @hide @method setIconClass @hide @event activate @hide @event beforeclose @hide @event bodyresize @hide @event close @hide @event deactivate @hide Provides a lightweight HTML Editor component. Some toolbar features are not supported by Safari and will be automatically hidden when needed. These are noted in the config options where appropriate. <br/><br/>The editor's toolbar buttons have tooltips defined in the {@link #buttonTips} property, but they are not enabled by default unless the global {@link Ext.QuickTips} singleton is {@link Ext.QuickTips#init initialized}. <br/><br/><b>Note: The focus/blur and validation marking functionality inherited from Ext.form.Field is NOT supported by this editor.</b> <br/><br/>An Editor is a sensitive component that can't be used in all spots standard fields can be used. Putting an Editor within any element that has display set to 'none' can cause problems in Safari and Firefox due to their default iframe reloading bugs. <br/><br/>Example usage: <pre><code>// Simple example rendered with default options:
Ext.QuickTips.init();  // enable tooltips
new Ext.form.HtmlEditor({
renderTo: Ext.getBody(),
width: 800,
height: 300
});

// Passed via xtype into a container and with custom options:
Ext.QuickTips.init();  // enable tooltips
new Ext.Panel({
title: 'HTML Editor',
renderTo: Ext.getBody(),
width: 600,
height: 300,
frame: true,
layout: 'fit',
items: {
xtype: 'htmleditor',
enableColors: false,
enableAlignments: false
}
});
</code></pre>
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.TimeField'>
    <xs:complexContent>
      <xs:extension base='ext:ext.form.ComboBox'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:string' name='minValue'>
          <xs:annotation>
            <xs:documentation>
The minimum allowed time. Can be either a Javascript date object with a valid time value or a string time in a valid format -- see {@link #format} and {@link #altFormats} (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxValue'>
          <xs:annotation>
            <xs:documentation>
The maximum allowed time. Can be either a Javascript date object with a valid time value or a string time in a valid format -- see {@link #format} and {@link #altFormats} (defaults to null).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='minText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the date in the cell is before minValue (defaults to 'The time in this field must be equal to or after {0}').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='maxText'>
          <xs:annotation>
            <xs:documentation>
The error text to display when the time is after maxValue (defaults to 'The time in this field must be equal to or before {0}').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='format'>
          <xs:annotation>
            <xs:documentation>
The default time format string which can be overriden for localization support. The format must be valid according to {@link Date#parseDate} (defaults to 'g:i A', e.g., '3:15 PM'). For 24-hour time format try 'H:i' instead.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='altFormats'>
          <xs:annotation>
            <xs:documentation>
Multiple date formats separated by "|" to try when parsing a user input value and it doesn't match the defined format (defaults to 'g:ia|g:iA|g:i a|g:i A|h:i|g:i|H:i|ga|ha|gA|h a|g a|g A|gi|hi|gia|hia|g|H').
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='increment'>
          <xs:annotation>
            <xs:documentation>
The number of minutes between each time value in the list (defaults to 15).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='timefield' type='ext:ext.form.TimeField' substitutionGroup='ext:combo'>
    <xs:annotation>
      <xs:documentation>
@property disabled @hide @method applyToMarkup @hide @method disable @hide @method enable @hide @method validate @hide @event valid @hide @method setDisabled @hide @cfg keys @hide
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.form.Label'>
    <xs:complexContent>
      <xs:extension base='ext:ext.BoxComponent'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:string' name='text'>
          <xs:annotation>
            <xs:documentation>
The plain text to display within the label (defaults to ''). If you need to include HTML tags within the label's innerHTML, use the {@link #html} config instead.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='forId'>
          <xs:annotation>
            <xs:documentation>
The id of the input element to which this label will be bound via the standard HTML 'for' attribute. If not specified, the attribute will not be added to the label.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='html'>
          <xs:annotation>
            <xs:documentation>
An HTML fragment that will be used as the label's innerHTML (defaults to ''). Note that if {@link #text} is specified it will take precedence and this value will be ignored.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='label' type='ext:ext.form.Label' substitutionGroup='ext:box'>
    <xs:annotation>
      <xs:documentation>
@hide @method autoSize
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.grid.GridPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.Panel'>
        <xs:all>
            <xs:element name='cm' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Shorthand for <tt>{@link #colModel}</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='colModel' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.grid.ColumnModel} to use when rendering the grid (required).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='columns' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An array of {@link Ext.grid.Column columns} to auto create a {@link Ext.grid.ColumnModel}. The ColumnModel may be explicitly created via the <tt>{@link #colModel}</tt> configuration property.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:sequence>
                  <xs:any minOccurs="0" maxOccurs="unbounded" processContents="lax"/>
                </xs:sequence>
              </xs:complexType>
            </xs:element>
            <xs:element name='loadMask' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    An {@link Ext.LoadMask} config or true to mask the grid while loading. Defaults to <code>false</code>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='sm' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Shorthand for <tt>{@link #selModel}</tt>.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='selModel' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    Any subclass of {@link Ext.grid.AbstractSelectionModel} that will provide the selection model for the grid (defaults to {@link Ext.grid.RowSelectionModel} if not specified).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='store' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.data.Store} the grid should use as its data source (required).
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='view' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    The {@link Ext.grid.GridView} used by the grid. This can be set before a call to {@link Ext.Component#render render()}.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
            <xs:element name='viewConfig' minOccurs="0" maxOccurs="1">
              <xs:annotation>
                <xs:documentation>
    A config object that will be applied to the grid's UI view. Any of the config options available for {@link Ext.grid.GridView} can be specified here. This option is ignored if <tt>{@link #view}</tt> is specified.
                </xs:documentation>
              </xs:annotation>
              <xs:complexType>
                <xs:simpleContent>
                  <xs:extension base="xs:string">
                    <xs:anyAttribute processContents="skip"/>
                  </xs:extension>
                </xs:simpleContent>
              </xs:complexType>
            </xs:element>
        </xs:all>
        <xs:attribute type='xs:string' name='autoExpandColumn'>
          <xs:annotation>
            <xs:documentation>
<p>The <tt>{@link Ext.grid.Column#id id}</tt> of a {@link Ext.grid.Column column} in this grid that should expand to fill unused space. This value specified here can not be <tt>0</tt>.</p><br/><p><b>Note</b>: If the Grid's {@link Ext.grid.GridView view} is configured with <tt>{@link Ext.grid.GridView#forceFit forceFit}=true</tt> the <tt>autoExpandColumn</tt> is ignored. See {@link Ext.grid.Column}.<tt>{@link Ext.grid.Column#width width}</tt> for additional details.</p><p>See <tt>{@link #autoExpandMax}</tt> and <tt>{@link #autoExpandMin}</tt> also.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='autoExpandMax'>
          <xs:annotation>
            <xs:documentation>
The maximum width the <tt>{@link #autoExpandColumn}</tt> can have (if enabled). Defaults to <tt>1000</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='autoExpandMin'>
          <xs:annotation>
            <xs:documentation>
The minimum width the <tt>{@link #autoExpandColumn}</tt> can have (if enabled). Defaults to <tt>50</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='columnLines'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to add css for column separation lines. Default is <tt>false</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='cm'>
          <xs:annotation>
            <xs:documentation>
Shorthand for <tt>{@link #colModel}</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='colModel'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.grid.ColumnModel} to use when rendering the grid (required).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='columns'>
          <xs:annotation>
            <xs:documentation>
An array of {@link Ext.grid.Column columns} to auto create a {@link Ext.grid.ColumnModel}. The ColumnModel may be explicitly created via the <tt>{@link #colModel}</tt> configuration property.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ddGroup'>
          <xs:annotation>
            <xs:documentation>
The DD group this GridPanel belongs to. Defaults to <tt>'GridDD'</tt> if not specified.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='ddText'>
          <xs:annotation>
            <xs:documentation>
Configures the text in the drag proxy. Defaults to: <pre><code>ddText : '{0} selected row{1}'
</code></pre><tt>{0}</tt> is replaced with the number of selected rows.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='deferRowRender'>
          <xs:annotation>
            <xs:documentation>
<p>Defaults to <tt>true</tt> to enable deferred row rendering.</p><p>This allows the GridPanel to be initially rendered empty, with the expensive update of the row structure deferred so that layouts with GridPanels appear more quickly.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='disableSelection'>
          <xs:annotation>
            <xs:documentation>
<p><tt>true</tt> to disable selections in the grid. Defaults to <tt>false</tt>.</p><p>Ignored if a {@link #selModel SelectionModel} is specified.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColumnResize'>
          <xs:annotation>
            <xs:documentation>
<tt>false</tt> to turn off column resizing for the whole grid. Defaults to <tt>true</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColumnHide'>
          <xs:annotation>
            <xs:documentation>
Defaults to <tt>true</tt> to enable {@link Ext.grid.Column#hidden hiding of columns} with the {@link #enableHdMenu header menu}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableColumnMove'>
          <xs:annotation>
            <xs:documentation>
Defaults to <tt>true</tt> to enable drag and drop reorder of columns. <tt>false</tt> to turn off column reordering via drag drop.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableDragDrop'>
          <xs:annotation>
            <xs:documentation>
<p>Enables dragging of the selected rows of the GridPanel. Defaults to <tt>false</tt>.</p><p>Setting this to <b><tt>true</tt></b> causes this GridPanel's {@link #getView GridView} to create an instance of {@link Ext.grid.GridDragZone}. <b>Note</b>: this is available only <b>after</b> the Grid has been rendered as the GridView's <tt>{@link Ext.grid.GridView#dragZone dragZone}</tt> property.</p><p>A cooperating {@link Ext.dd.DropZone DropZone} must be created who's implementations of {@link Ext.dd.DropZone#onNodeEnter onNodeEnter}, {@link Ext.dd.DropZone#onNodeOver onNodeOver}, {@link Ext.dd.DropZone#onNodeOut onNodeOut} and {@link Ext.dd.DropZone#onNodeDrop onNodeDrop} are able to process the {@link Ext.grid.GridDragZone#getDragData data} which is provided.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='enableHdMenu'>
          <xs:annotation>
            <xs:documentation>
Defaults to <tt>true</tt> to enable the drop down button for menu in the headers.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='hideHeaders'>
          <xs:annotation>
            <xs:documentation>
True to hide the grid's header. Defaults to <code>false</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='loadMask'>
          <xs:annotation>
            <xs:documentation>
An {@link Ext.LoadMask} config or true to mask the grid while loading. Defaults to <code>false</code>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='maxHeight'>
          <xs:annotation>
            <xs:documentation>
Sets the maximum height of the grid - ignored if <tt>autoHeight</tt> is not on.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:int' name='minColumnWidth'>
          <xs:annotation>
            <xs:documentation>
The minimum width a column can be resized to. Defaults to <tt>25</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='sm'>
          <xs:annotation>
            <xs:documentation>
Shorthand for <tt>{@link #selModel}</tt>.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='selModel'>
          <xs:annotation>
            <xs:documentation>
Any subclass of {@link Ext.grid.AbstractSelectionModel} that will provide the selection model for the grid (defaults to {@link Ext.grid.RowSelectionModel} if not specified).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='store'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.data.Store} the grid should use as its data source (required).
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='stripeRows'>
          <xs:annotation>
            <xs:documentation>
<tt>true</tt> to stripe the rows. Default is <tt>false</tt>. <p>This causes the CSS class <tt><b>x-grid3-row-alt</b></tt> to be added to alternate rows of the grid. A default CSS rule is provided which sets a background colour, but you can override this with a rule which either overrides the <b>background-color</b> style using the '!important' modifier, or which uses a CSS selector of higher specificity.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='trackMouseOver'>
          <xs:annotation>
            <xs:documentation>
True to highlight rows when the mouse is over. Default is <tt>true</tt> for GridPanel, but <tt>false</tt> for EditorGridPanel.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='view'>
          <xs:annotation>
            <xs:documentation>
The {@link Ext.grid.GridView} used by the grid. This can be set before a call to {@link Ext.Component#render render()}.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:string' name='viewConfig'>
          <xs:annotation>
            <xs:documentation>
A config object that will be applied to the grid's UI view. Any of the config options available for {@link Ext.grid.GridView} can be specified here. This option is ignored if <tt>{@link #view}</tt> is specified.
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='grid' type='ext:ext.grid.GridPanel' substitutionGroup='ext:panel'>
    <xs:annotation>
      <xs:documentation>
The function used to validate email addresses. Note that this is a very basic validation -- complete validation per the email RFC specifications is very complex and beyond the scope of this class, although this function can be overridden if a more comprehensive validation scheme is desired. See the validation section of the <a href="http://en.wikipedia.org/wiki/E-mail_address">Wikipedia article on email addresses</a> for additional information. This implementation is intended to validate the following emails:<tt>'barney@example.de', 'barney.rubble@example.com', 'barney-rubble@example.coop', 'barney+rubble@example.com'</tt> . @param {String} value The email address @return {Boolean} true if the RegExp test passed, and false if not. The error text to display when the email validation function returns false. Defaults to: <tt>'This field should be an e-mail address in the format "user@example.com"'</tt> @type String The keystroke filter mask to be applied on email input. See the {@link #email} method for information about more complex email validation. Defaults to: <tt>/[a-z0-9_\.\-@]/i</tt> @type RegExp The function used to validate URLs @param {String} value The URL @return {Boolean} true if the RegExp test passed, and false if not. The error text to display when the url validation function returns false. Defaults to: <tt>'This field should be a URL in the format "http:/'+'/www.example.com"'</tt> @type String The function used to validate alpha values @param {String} value The value @return {Boolean} true if the RegExp test passed, and false if not. The error text to display when the alpha validation function returns false. Defaults to: <tt>'This field should only contain letters and _'</tt> @type String The keystroke filter mask to be applied on alpha input. Defaults to: <tt>/[a-z_]/i</tt> @type RegExp The function used to validate alphanumeric values @param {String} value The value @return {Boolean} true if the RegExp test passed, and false if not. The error text to display when the alphanumeric validation function returns false. Defaults to: <tt>'This field should only contain letters, numbers and _'</tt> @type String The keystroke filter mask to be applied on alphanumeric input. Defaults to: <tt>/[a-z0-9_]/i</tt> @type RegExp
      </xs:documentation>
    </xs:annotation>
  </xs:element>
  <xs:complexType name='ext.grid.EditorGridPanel'>
    <xs:complexContent>
      <xs:extension base='ext:ext.grid.GridPanel'>
        <xs:all>
        </xs:all>
        <xs:attribute type='xs:int' name='clicksToEdit'>
          <xs:annotation>
            <xs:documentation>
<p>The number of clicks on a cell required to display the cell's editor (defaults to 2).</p><p>Setting this option to 'auto' means that mousedown <i>on the selected cell</i> starts editing that cell.</p>
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='forceValidation'>
          <xs:annotation>
            <xs:documentation>
True to force validation even if the value is unmodified (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
        <xs:attribute type='xs:boolean' name='autoEncode'>
          <xs:annotation>
            <xs:documentation>
True to automatically HTML encode and decode values pre and post edit (defaults to false)
            </xs:documentation>
          </xs:annotation>
        </xs:attribute>
      </xs:extension>
    </xs:complexContent>
  </xs:complexType>
  <xs:element name='editorgrid' type='ext:ext.grid.EditorGridPanel' substitutionGroup='ext:grid'>
    <xs:annotation>
      <xs:documentation>
@event cellselect Fires when a cell is selected. @param {SelectionModel} this @param {Number} rowIndex The selected row index @param {Number} colIndex The selected cell index @event selectionchange Fires when the active selection changes. @param {SelectionModel} this @param {Object} selection null for no selection or an object with two properties <div class="mdetail-params"><ul><li><b>cell</b> : see {@link #getSelectedCell}</li><li><b>record</b> : Ext.data.record<p class="sub-desc">The {@link Ext.data.Record Record} which provides the data for the row containing the selection</p></li></ul></div>Returns an array containing the row and column indexes of the currently selected cell (e.g., [0, 0]), or null if none selected. The array has elements: <div class="mdetail-params"><ul><li><b>rowIndex</b> : Number<p class="sub-desc">The index of the selected row</p></li><li><b>cellIndex</b> : Number<p class="sub-desc">The index of the selected cell. Due to possible column reordering, the cellIndex should <b>not</b> be used as an index into the Record's data. Instead, use the cellIndex to determine the <i>name</i> of the selected cell and use the field name to retrieve the data value from the record:</p><pre><code>// get name
var fieldName = grid.getColumnModel().getDataIndex(cellIndex);
// get data value based on name
var data = record.get(fieldName);
</code></pre><br/><br/></li></ul></div>@return {Array} An array containing the row and column indexes of the selected cell, or null if none selected. If anything is selected, clears all selections and fires the selectionchange event. @param {Boolean} preventNotify <tt>true</tt> to prevent the gridview from being notified about the change. Returns <tt>true</tt> if there is a selection. @return {Boolean} Selects a cell. Before selecting a cell, fires the {@link #beforecellselect} event. If this check is satisfied the cell will be selected and followed up by firing the {@link #cellselect} and {@link #selectionchange} events. @param {Number} rowIndex The index of the row to select @param {Number} colIndex The index of the column to select @param {Boolean} preventViewNotify (optional) Specify <tt>true</tt> to prevent notifying the view (disables updating the selected appearance) @param {Boolean} preventFocus (optional) Whether to prevent the cell at the specified rowIndex / colIndex from being focused. @param {Ext.data.Record} r (optional) The record to select
      </xs:documentation>
    </xs:annotation>
  </xs:element>
</xs:schema>
